{
    "version": "https://jsonfeed.org/version/1",
    "title": "潇十七 • All posts by \"算法\" category",
    "description": "可生活不是电影，我也少了点运气",
    "home_page_url": "https://x-17.top",
    "items": [
        {
            "id": "https://x-17.top/2022/10/08/LeetCode/870-%E4%BC%98%E5%8A%BF%E6%B4%97%E7%89%8C/",
            "url": "https://x-17.top/2022/10/08/LeetCode/870-%E4%BC%98%E5%8A%BF%E6%B4%97%E7%89%8C/",
            "title": "870. 优势洗牌",
            "date_published": "2022-10-08T07:32:59.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"870-优势洗牌\"><a href=\"#870-优势洗牌\" class=\"headerlink\" title=\"870. 优势洗牌\"></a><a href=\"https://leetcode.cn/problems/advantage-shuffle/\">870. 优势洗牌</a></h1><p>给定两个大小相等的数组 nums1 和 nums2，nums1 相对于 nums2 的优势可以用满足 nums1[i] &gt; nums2[i] 的索引 i 的数目来描述。</p>\n<p>返回 nums1 的任意排列，使其相对于 nums2 的优势最大化。</p>\n<p>示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums1 = [2,7,11,15], nums2 = [1,10,4,11]</span><br><span class=\"line\">输出：[2,11,7,15]</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums1 = [12,24,8,32], nums2 = [13,25,32,11]</span><br><span class=\"line\">输出：[24,32,8,12]</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li><p>1 &lt;= nums1.length &lt;= 105</p>\n</li>\n<li><p>nums2.length == nums1.length</p>\n</li>\n<li>0 &lt;= nums1[i], nums2[i] &lt;= 109</li>\n</ul>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">advantageCount</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt; &amp;nums1, vector&lt;<span class=\"type\">int</span>&gt; &amp;nums2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = nums1.<span class=\"built_in\">size</span>(), ids[n];</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">ans</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(nums1.<span class=\"built_in\">begin</span>(), nums1.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"built_in\">iota</span>(ids, ids + n, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(ids, ids + n, [&amp;](<span class=\"type\">int</span> i, <span class=\"type\">int</span> j) &#123; <span class=\"keyword\">return</span> nums2[i] &lt; nums2[j]; &#125;);</span><br><span class=\"line\">        <span class=\"type\">int</span> left = <span class=\"number\">0</span>, right = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> x : nums1)</span><br><span class=\"line\">            ans[x &gt; nums2[ids[left]] ? ids[left++] : ids[right--]] = x;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度：<script type=\"math/tex\">O(nlogn)</script></li>\n<li>空间复杂度：<script type=\"math/tex\">O(n)</script></li>\n</ul>\n",
            "tags": [
                "Medium",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/10/07/LeetCode/1800-%E6%9C%80%E5%A4%A7%E5%8D%87%E5%BA%8F%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/",
            "url": "https://x-17.top/2022/10/07/LeetCode/1800-%E6%9C%80%E5%A4%A7%E5%8D%87%E5%BA%8F%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/",
            "title": "1800. 最大升序子数组和",
            "date_published": "2022-10-06T23:33:33.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"1800-最大升序子数组和\"><a href=\"#1800-最大升序子数组和\" class=\"headerlink\" title=\"1800. 最大升序子数组和\"></a><a href=\"https://leetcode.cn/problems/maximum-ascending-subarray-sum/\">1800. 最大升序子数组和</a></h1><blockquote>\n<p>给你一个正整数组成的数组 nums ，返回 nums 中一个 升序 子数组的最大可能元素和。</p>\n<p>子数组是数组中的一个连续数字序列。</p>\n<p>已知子数组 [numsl, numsl+1, …, numsr-1, numsr] ，若对所有 i（l &lt;= i &lt; r），numsi &lt; numsi+1 都成立，则称这一子数组为 升序 子数组。注意，大小为 1 的子数组也视作 升序 子数组。</p>\n<p>示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [10,20,30,5,10,50]</span><br><span class=\"line\">输出：65</span><br><span class=\"line\">解释：[5,10,50] 是元素和最大的升序子数组，最大元素和为 65 。</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [10,20,30,40,50]</span><br><span class=\"line\">输出：150</span><br><span class=\"line\">解释：[10,20,30,40,50] 是元素和最大的升序子数组，最大元素和为 150 。 </span><br></pre></td></tr></table></figure>\n<p>示例 3：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [12,17,15,13,10,11,12]</span><br><span class=\"line\">输出：33</span><br><span class=\"line\">解释：[10,11,12] 是元素和最大的升序子数组，最大元素和为 33 。</span><br></pre></td></tr></table></figure>\n<p>示例 4：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [100,10,1]</span><br><span class=\"line\">输出：100</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li><p>1 &lt;= nums.length &lt;= 100</p>\n</li>\n<li><p>1 &lt;= nums[i] &lt;= 100</p>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maxAscendingSum</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> m=nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;nums.<span class=\"built_in\">size</span>();i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[i]&gt;nums[i<span class=\"number\">-1</span>])&#123;</span><br><span class=\"line\">                m+=nums[i];</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                ans=<span class=\"built_in\">max</span>(m,ans);</span><br><span class=\"line\">                m=nums[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans=<span class=\"built_in\">max</span>(ans,m);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度$O(n)$</li>\n<li>空间复杂度$O(1)$</li>\n</ul>\n",
            "tags": [
                "Easy",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/10/06/LeetCode/927-%E4%B8%89%E7%AD%89%E5%88%86/",
            "url": "https://x-17.top/2022/10/06/LeetCode/927-%E4%B8%89%E7%AD%89%E5%88%86/",
            "title": "927. 三等分",
            "date_published": "2022-10-06T05:23:56.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"927-三等分\"><a href=\"#927-三等分\" class=\"headerlink\" title=\"927. 三等分\"></a><a href=\"https://leetcode.cn/problems/three-equal-parts/\">927. 三等分</a></h1><blockquote>\n<p>给定一个由 0 和 1 组成的数组 arr ，将数组分成  3 个非空的部分 ，使得所有这些部分表示相同的二进制值。</p>\n<p>如果可以做到，请返回任何 [i, j]，其中 i+1 &lt; j，这样一来：</p>\n<ul>\n<li><p>arr[0], arr[1], …, arr[i] 为第一部分；</p>\n</li>\n<li><p>arr[i + 1], arr[i + 2], …, arr[j - 1] 为第二部分；</p>\n</li>\n<li>arr[j], arr[j + 1], …, arr[arr.length - 1] 为第三部分。</li>\n<li>这三个部分所表示的二进制值相等。</li>\n<li>如果无法做到，就返回 [-1, -1]。</li>\n</ul>\n<p>注意，在考虑每个部分所表示的二进制时，应当将其看作一个整体。例如，[1,1,0] 表示十进制中的 6，而不会是 3。此外，前导零也是被允许的，所以 [0,1,1] 和 [1,1] 表示相同的值。</p>\n<p>示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：arr = [1,0,1,0,1]</span><br><span class=\"line\">输出：[0,3]</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：arr = [1,1,0,1,1]</span><br><span class=\"line\">输出：[-1,-1]</span><br></pre></td></tr></table></figure>\n<p>示例 3:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：arr = [1,1,0,0,1]</span><br><span class=\"line\">输出：[0,2]</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li><p>3 &lt;= arr.length &lt;= 3 * 104</p>\n</li>\n<li><p>arr[i] 是 0 或 1</p>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">threeEqualParts</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> sum = <span class=\"built_in\">accumulate</span>(arr.<span class=\"built_in\">begin</span>(), arr.<span class=\"built_in\">end</span>(), <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sum % <span class=\"number\">3</span> != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123;<span class=\"number\">-1</span>, <span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sum == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123;<span class=\"number\">0</span>, <span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> partial = sum / <span class=\"number\">3</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> first = <span class=\"number\">0</span>, second = <span class=\"number\">0</span>, third = <span class=\"number\">0</span>, cur = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; arr.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[i] == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cur == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    first = i;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cur == partial) &#123;</span><br><span class=\"line\">                    second = i;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cur == <span class=\"number\">2</span> * partial) &#123;</span><br><span class=\"line\">                    third = i;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                cur++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> len = (<span class=\"type\">int</span>)arr.<span class=\"built_in\">size</span>() - third;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (first + len &lt;= second &amp;&amp; second + len &lt;= third) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (third + i &lt; arr.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (arr[first + i] != arr[second + i] || arr[first + i] != arr[third + i]) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> &#123;<span class=\"number\">-1</span>, <span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123;first + len - <span class=\"number\">1</span>, second + len&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;<span class=\"number\">-1</span>, <span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度：$O(n)$</li>\n<li>空间复杂度：$O(1)$</li>\n</ul>\n",
            "tags": [
                "Hard",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/10/05/LeetCode/811-%E5%AD%90%E5%9F%9F%E5%90%8D%E8%AE%BF%E9%97%AE%E8%AE%A1%E6%95%B0/",
            "url": "https://x-17.top/2022/10/05/LeetCode/811-%E5%AD%90%E5%9F%9F%E5%90%8D%E8%AE%BF%E9%97%AE%E8%AE%A1%E6%95%B0/",
            "title": "811. 子域名访问计数",
            "date_published": "2022-10-04T23:48:49.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"811-子域名访问计数\"><a href=\"#811-子域名访问计数\" class=\"headerlink\" title=\"811. 子域名访问计数\"></a><a href=\"https://leetcode.cn/problems/subdomain-visit-count/\">811. 子域名访问计数</a></h1><blockquote>\n<p>网站域名 “discuss.leetcode.com” 由多个子域名组成。顶级域名为 “com” ，二级域名为 “leetcode.com” ，最低一级为 “discuss.leetcode.com” 。当访问域名 “discuss.leetcode.com” 时，同时也会隐式访问其父域名 “leetcode.com” 以及 “com” 。</p>\n<p>计数配对域名 是遵循 “rep d1.d2.d3” 或 “rep d1.d2” 格式的一个域名表示，其中 rep 表示访问域名的次数，d1.d2.d3 为域名本身。</p>\n<p>例如，”9001 discuss.leetcode.com” 就是一个 计数配对域名 ，表示 discuss.leetcode.com 被访问了 9001 次。<br>给你一个 计数配对域名 组成的数组 cpdomains ，解析得到输入中每个子域名对应的 计数配对域名 ，并以数组形式返回。可以按 任意顺序 返回答案。</p>\n<p> 示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：cpdomains = [&quot;9001 discuss.leetcode.com&quot;]</span><br><span class=\"line\">输出：[&quot;9001 leetcode.com&quot;,&quot;9001 discuss.leetcode.com&quot;,&quot;9001 com&quot;]</span><br><span class=\"line\">解释：例子中仅包含一个网站域名：&quot;discuss.leetcode.com&quot;。</span><br><span class=\"line\">按照前文描述，子域名 &quot;leetcode.com&quot; 和 &quot;com&quot; 都会被访问，所以它们都被访问了 9001 次。</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：cpdomains = [&quot;900 google.mail.com&quot;, &quot;50 yahoo.com&quot;, &quot;1 intel.mail.com&quot;, &quot;5 wiki.org&quot;]</span><br><span class=\"line\">输出：[&quot;901 mail.com&quot;,&quot;50 yahoo.com&quot;,&quot;900 google.mail.com&quot;,&quot;5 wiki.org&quot;,&quot;5 org&quot;,&quot;1 intel.mail.com&quot;,&quot;951 com&quot;]</span><br><span class=\"line\">解释：按照前文描述，会访问 &quot;google.mail.com&quot; 900 次，&quot;yahoo.com&quot; 50 次，&quot;intel.mail.com&quot; 1 次，&quot;wiki.org&quot; 5 次。</span><br><span class=\"line\">而对于父域名，会访问 &quot;mail.com&quot; 900 + 1 = 901 次，&quot;com&quot; 900 + 50 + 1 = 951 次，和 &quot;org&quot; 5 次。</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li><p>1 &lt;= cpdomain.length &lt;= 100</p>\n</li>\n<li><p>1 &lt;= cpdomain[i].length &lt;= 100</p>\n</li>\n<li>cpdomain[i] 会遵循 “repi d1i.d2i.d3i” 或 “repi d1i.d2i” 格式</li>\n<li>repi 是范围 [1, 104] 内的一个整数</li>\n<li>d1i、d2i 和 d3i 由小写英文字母组成</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;string&gt; <span class=\"title\">subdomainVisits</span><span class=\"params\">(vector&lt;string&gt;&amp; cpdomains)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;string&gt; ans;</span><br><span class=\"line\">        unordered_map&lt;string, <span class=\"type\">int</span>&gt; counts;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;&amp;cpdomain : cpdomains) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> space = cpdomain.<span class=\"built_in\">find</span>(<span class=\"string\">&#x27; &#x27;</span>);</span><br><span class=\"line\">            <span class=\"type\">int</span> count = <span class=\"built_in\">stoi</span>(cpdomain.<span class=\"built_in\">substr</span>(<span class=\"number\">0</span>, space));</span><br><span class=\"line\">            string domain = cpdomain.<span class=\"built_in\">substr</span>(space + <span class=\"number\">1</span>);</span><br><span class=\"line\">            counts[domain] += count;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; domain.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (domain[i] == <span class=\"string\">&#x27;.&#x27;</span>) &#123;</span><br><span class=\"line\">                    string subdomain = domain.<span class=\"built_in\">substr</span>(i + <span class=\"number\">1</span>);</span><br><span class=\"line\">                    counts[subdomain] += count;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;&amp;[subdomain, count] : counts) &#123;</span><br><span class=\"line\">            ans.<span class=\"built_in\">emplace_back</span>(<span class=\"built_in\">to_string</span>(count) + <span class=\"string\">&quot; &quot;</span> + subdomain);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><ul>\n<li>时间复杂度：$O(n)$</li>\n<li>空间复杂度：$O(n)$</li>\n</ul>\n",
            "tags": [
                "Medium",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/10/03/LeetCode/1784-%E6%A3%80%E6%9F%A5%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E6%AE%B5/",
            "url": "https://x-17.top/2022/10/03/LeetCode/1784-%E6%A3%80%E6%9F%A5%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E6%AE%B5/",
            "title": "1784. 检查二进制字符串字段",
            "date_published": "2022-10-02T23:41:35.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/check-if-binary-string-has-at-most-one-segment-of-ones/\">https://leetcode.cn/problems/check-if-binary-string-has-at-most-one-segment-of-ones/</a> 给你一个二进制字符串 s ，该字符串 不含前导零 。 如果 s 包含 零个或一个由连续的 ‘1’ 组成的字段 ，返回 true​​​ 。否则，返回 false 。 如果 s 中 由连续若干个 ‘1’ 组成的字段 数量不超过 1，返回 true​​​ 。否则，返回 false 。 示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;1001&quot;</span><br><span class=\"line\">输出：false</span><br><span class=\"line\">解释：由连续若干个 &#x27;1&#x27; 组成的字段数量为 2，返回 false</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;110&quot;</span><br><span class=\"line\">输出：true</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>1 &lt;= s.length &lt;= 100</li>\n<li>s[i]​​​​ 为 ‘0’ 或 ‘1’</li>\n<li>s[0] 为 ‘1’</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    bool checkOnesSegment(string s) &#123;</span><br><span class=\"line\">        int flag=1;</span><br><span class=\"line\">        for(int i=0;i&lt;s.length();i++)&#123;</span><br><span class=\"line\">            if(!flag&amp;&amp;s[i]==&#x27;1&#x27;)&#123;</span><br><span class=\"line\">                return false;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if(s[i]==&#x27;1&#x27;&amp;&amp;flag)&#123;</span><br><span class=\"line\">                for(int j=i;j&lt;s.length();j++)&#123;</span><br><span class=\"line\">                    if(s[j]!=&#x27;1&#x27;)&#123;</span><br><span class=\"line\">                        i=j-1;</span><br><span class=\"line\">                        flag=0;</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度\\(O(n)\\)</li>\n<li>空间复杂度\\(O(1)\\)</li>\n</ul>\n",
            "tags": [
                "Easy",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/10/02/LeetCode/777-%E5%9C%A8lr%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E4%BA%A4%E6%8D%A2%E7%9B%B8%E9%82%BB%E5%AD%97%E7%AC%A6/",
            "url": "https://x-17.top/2022/10/02/LeetCode/777-%E5%9C%A8lr%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E4%BA%A4%E6%8D%A2%E7%9B%B8%E9%82%BB%E5%AD%97%E7%AC%A6/",
            "title": "777. 在LR字符串中交换相邻字符",
            "date_published": "2022-10-01T23:42:54.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/swap-adjacent-in-lr-string/\">https://leetcode.cn/problems/swap-adjacent-in-lr-string/</a> 在一个由 ‘L’ , ‘R’ 和 ‘X’ 三个字符组成的字符串（例如”RXXLRXRXL”）中进行移动操作。一次移动操作指用一个”LX”替换一个”XL”，或者用一个”XR”替换一个”RX”。现给定起始字符串start和结束字符串end，请编写代码，当且仅当存在一系列移动操作使得start可以转换成end时， 返回True。 示例 :</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: start = &quot;RXXLRXRXL&quot;, end = &quot;XRLXXRRLX&quot;</span><br><span class=\"line\">输出: True</span><br><span class=\"line\">解释:</span><br><span class=\"line\">我们可以通过以下几步将start转换成end:</span><br><span class=\"line\">RXXLRXRXL -&gt;</span><br><span class=\"line\">XRXLRXRXL -&gt;</span><br><span class=\"line\">XRLXRXRXL -&gt;</span><br><span class=\"line\">XRLXXRRXL -&gt;</span><br><span class=\"line\">XRLXXRRLX</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>1 &lt;= len(start) = len(end) &lt;= 10000。</li>\n<li>start和end中的字符串仅限于’L’, ‘R’和’X’。</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    bool canTransform(string start, string end) &#123;</span><br><span class=\"line\">        int n = start.length();</span><br><span class=\"line\">        int i = 0, j = 0;</span><br><span class=\"line\">        while (i &lt; n &amp;&amp; j &lt; n) &#123;</span><br><span class=\"line\">            while (i &lt; n &amp;&amp; start[i] == &#x27;X&#x27;) &#123;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            while (j &lt; n &amp;&amp; end[j] == &#x27;X&#x27;) &#123;</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (i &lt; n &amp;&amp; j &lt; n) &#123;</span><br><span class=\"line\">                if (start[i] != end[j]) &#123;</span><br><span class=\"line\">                    return false;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                char c = start[i];</span><br><span class=\"line\">                if ((c == &#x27;L&#x27; &amp;&amp; i &lt; j)  (c == &#x27;R&#x27; &amp;&amp; i &gt; j)) &#123;</span><br><span class=\"line\">                    return false;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        while (i &lt; n) &#123;</span><br><span class=\"line\">            if (start[i] != &#x27;X&#x27;) &#123;</span><br><span class=\"line\">                return false;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        while (j &lt; n) &#123;</span><br><span class=\"line\">            if (end[j] != &#x27;X&#x27;) &#123;</span><br><span class=\"line\">                return false;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度\\(O(n)\\)</li>\n<li>空间复杂度\\(O(1)\\)</li>\n</ul>\n",
            "tags": [
                "Medium",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/10/01/LeetCode/1694-%E9%87%8D%E6%96%B0%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81/",
            "url": "https://x-17.top/2022/10/01/LeetCode/1694-%E9%87%8D%E6%96%B0%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81/",
            "title": "1694. 重新格式化电话号码",
            "date_published": "2022-10-01T00:06:52.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/reformat-phone-number/\">https://leetcode.cn/problems/reformat-phone-number/</a> 给你一个字符串形式的电话号码 number 。number 由数字、空格 ‘ ‘、和破折号 ‘-‘ 组成。 请你按下述方式重新格式化电话号码。 首先，删除 所有的空格和破折号。 其次，将数组从左到右 每 3 个一组 分块，直到 剩下 4 个或更少数字。剩下的数字将按下述规定再分块： 2 个数字：单个含 2 个数字的块。 3 个数字：单个含 3 个数字的块。 4 个数字：两个分别含 2 个数字的块。 最后用破折号将这些块连接起来。注意，重新格式化过程中 不应该 生成仅含 1 个数字的块，并且 最多 生成两个含 2 个数字的块。 返回格式化后的电话号码。 示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：number = &quot;1-23-45 6&quot;</span><br><span class=\"line\">输出：&quot;123-456&quot;</span><br><span class=\"line\">解释：数字是 &quot;123456&quot;</span><br><span class=\"line\">步骤 1：共有超过 4 个数字，所以先取 3 个数字分为一组。第 1 个块是 &quot;123&quot; 。</span><br><span class=\"line\">步骤 2：剩下 3 个数字，将它们放入单个含 3 个数字的块。第 2 个块是 &quot;456&quot; 。</span><br><span class=\"line\">连接这些块后得到 &quot;123-456&quot; 。</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：number = &quot;123 4-567&quot;</span><br><span class=\"line\">输出：&quot;123-45-67&quot;</span><br><span class=\"line\">解释：数字是 &quot;1234567&quot;.</span><br><span class=\"line\">步骤 1：共有超过 4 个数字，所以先取 3 个数字分为一组。第 1 个块是 &quot;123&quot; 。</span><br><span class=\"line\">步骤 2：剩下 4 个数字，所以将它们分成两个含 2 个数字的块。这 2 块分别是 &quot;45&quot; 和 &quot;67&quot; 。</span><br><span class=\"line\">连接这些块后得到 &quot;123-45-67&quot; 。</span><br></pre></td></tr></table></figure>\n<p>示例 3：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：number = &quot;123 4-5678&quot;</span><br><span class=\"line\">输出：&quot;123-456-78&quot;</span><br><span class=\"line\">解释：数字是 &quot;12345678&quot; 。</span><br><span class=\"line\">步骤 1：第 1 个块 &quot;123&quot; 。</span><br><span class=\"line\">步骤 2：第 2 个块 &quot;456&quot; 。</span><br><span class=\"line\">步骤 3：剩下 2 个数字，将它们放入单个含 2 个数字的块。第 3 个块是 &quot;78&quot; 。</span><br><span class=\"line\">连接这些块后得到 &quot;123-456-78&quot; 。</span><br></pre></td></tr></table></figure>\n<p>示例 4：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：number = &quot;12&quot;</span><br><span class=\"line\">输出：&quot;12&quot;</span><br></pre></td></tr></table></figure>\n<p>示例 5：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：number = &quot;--17-5 229 35-39475 &quot;</span><br><span class=\"line\">输出：&quot;175-229-353-94-75&quot;</span><br></pre></td></tr></table></figure>\n<p>  提示：</p>\n<ul>\n<li>2 &lt;= number.length &lt;= 100</li>\n<li>number 由数字和字符 ‘-‘ 及 ‘ ‘ 组成。</li>\n<li>number 中至少含 2 个数字。</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    string reformatNumber(string number) &#123;</span><br><span class=\"line\">        deque&lt;char&gt; d;</span><br><span class=\"line\">        for(int i=0;i&lt;number.length();i++)&#123; </span><br><span class=\"line\">            if(number[i]!=&#x27; &#x27;&amp;&amp;number[i]!=&#x27;-&#x27;) </span><br><span class=\"line\">                d.push_back(number[i]); </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        string ans=&quot;&quot;; </span><br><span class=\"line\">        while(d.size()&gt;4)&#123;</span><br><span class=\"line\">            for(int i=0;i&lt;3;i++)&#123;</span><br><span class=\"line\">                ans+=d.front();</span><br><span class=\"line\">                d.pop_front();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ans+=&#x27;-&#x27;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        if(d.size()==4)&#123;</span><br><span class=\"line\">            for(int i=0;i&lt;2;i++)&#123;</span><br><span class=\"line\">                ans+=d.front();</span><br><span class=\"line\">                d.pop_front();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ans+=&#x27;-&#x27;;</span><br><span class=\"line\">            for(int i=0;i&lt;2;i++)&#123;</span><br><span class=\"line\">                ans+=d.front();</span><br><span class=\"line\">                d.pop_front();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;else if(d.size()==3)&#123;</span><br><span class=\"line\">            for(int i=0;i&lt;3;i++)&#123;</span><br><span class=\"line\">                ans+=d.front();</span><br><span class=\"line\">                d.pop_front();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            for(int i=0;i&lt;2;i++)&#123;</span><br><span class=\"line\">                ans+=d.front();</span><br><span class=\"line\">                d.pop_front();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度\\(O(n)\\)</li>\n<li>空间复杂度\\(O(n)\\)</li>\n</ul>\n",
            "tags": [
                "Easy",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/09/30/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%98-01-08-%E9%9B%B6%E7%9F%A9%E9%98%B5/",
            "url": "https://x-17.top/2022/09/30/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%98-01-08-%E9%9B%B6%E7%9F%A9%E9%98%B5/",
            "title": "面试题 01.08. 零矩阵",
            "date_published": "2022-09-29T23:41:21.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/zero-matrix-lcci/\">https://leetcode.cn/problems/zero-matrix-lcci/</a> 编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。 示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\">[</span><br><span class=\"line\">[1,1,1],</span><br><span class=\"line\">[1,0,1],</span><br><span class=\"line\">[1,1,1]</span><br><span class=\"line\">]</span><br><span class=\"line\">输出：</span><br><span class=\"line\">[</span><br><span class=\"line\">[1,0,1],</span><br><span class=\"line\">[0,0,0],</span><br><span class=\"line\">[1,0,1]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\">[</span><br><span class=\"line\">[0,1,2,0],</span><br><span class=\"line\">[3,4,5,2],</span><br><span class=\"line\">[1,3,1,5]</span><br><span class=\"line\">]</span><br><span class=\"line\">输出：</span><br><span class=\"line\">[</span><br><span class=\"line\">[0,0,0,0],</span><br><span class=\"line\">[0,4,5,0],</span><br><span class=\"line\">[0,3,1,0]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class=\"line\">        vector&lt;int&gt; h(matrix[0].size(),0);</span><br><span class=\"line\">        vector&lt;int&gt; s(matrix.size(),0);</span><br><span class=\"line\">        for(int i=0;i&lt;matrix.size();i++)&#123;</span><br><span class=\"line\">            for(int j=0;j&lt;matrix[0].size();j++)&#123;</span><br><span class=\"line\">                if(matrix[i][j]==0)&#123;</span><br><span class=\"line\">                    h[j]=1;</span><br><span class=\"line\">                    s[i]=1;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        for(int i=0;i&lt;matrix.size();i++)&#123;</span><br><span class=\"line\">            if(s[i]==1)&#123;</span><br><span class=\"line\">                for(int j=0;j&lt;matrix[0].size();j++)&#123;</span><br><span class=\"line\">                    matrix[i][j]=0;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        for(int i=0;i&lt;matrix[0].size();i++)&#123;</span><br><span class=\"line\">            if(h[i]==1)&#123;</span><br><span class=\"line\">                for(int j=0;j&lt;matrix.size();j++)&#123;</span><br><span class=\"line\">                    matrix[j][i]=0;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度\\(O(mn)\\)</li>\n<li>空间复杂度\\(O(m+n)\\)</li>\n</ul>\n",
            "tags": [
                "Medium",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/09/29/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%98-01-09-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AE%E8%BD%AC/",
            "url": "https://x-17.top/2022/09/29/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%98-01-09-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AE%E8%BD%AC/",
            "title": "面试题 01.09. 字符串轮转",
            "date_published": "2022-09-28T23:47:17.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/string-rotation-lcci/\">https://leetcode.cn/problems/string-rotation-lcci/</a> 字符串轮转。给定两个字符串s1和s2，请编写代码检查s2是否为s1旋转而成（比如，waterbottle是erbottlewat旋转后的字符串）。 示例1:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：s1 = &quot;waterbottle&quot;, s2 = &quot;erbottlewat&quot;</span><br><span class=\"line\">输出：True</span><br></pre></td></tr></table></figure>\n<p>示例2:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：s1 = &quot;aa&quot;, s2 = &quot;aba&quot;</span><br><span class=\"line\">输出：False</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>字符串长度在[0, 100000]范围内。</li>\n</ul>\n<p>说明:</p>\n<ul>\n<li>你能只调用一次检查子串的方法吗？</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    bool isFlipedString(string s1, string s2) &#123;</span><br><span class=\"line\">        return s1.size() == s2.size() &amp;&amp; (s1 + s1).find(s2) != string::npos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度\\(O(n)\\)</li>\n<li>空间复杂度\\(O(n)\\)</li>\n</ul>\n",
            "tags": [
                "Easy",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/09/28/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%98-17-09-%E7%AC%AC-k-%E4%B8%AA%E6%95%B0/",
            "url": "https://x-17.top/2022/09/28/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%98-17-09-%E7%AC%AC-k-%E4%B8%AA%E6%95%B0/",
            "title": "面试题 17.09. 第 k 个数",
            "date_published": "2022-09-27T23:37:35.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/get-kth-magic-number-lcci/\">https://leetcode.cn/problems/get-kth-magic-number-lcci/</a> 有些数的素因子只有 3，5，7，请设计一个算法找出第 k 个数。注意，不是必须有这些素因子，而是必须不包含其他的素因子。例如，前几个数按顺序应该是 1，3，5，7，9，15，21。 示例 1:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: k = 5</span><br><span class=\"line\">输出: 9</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int getKthMagicNumber(int k) &#123;</span><br><span class=\"line\">        vector&lt;int&gt; factors = &#123;3, 5, 7&#125;;</span><br><span class=\"line\">        unordered_set&lt;long&gt; seen;</span><br><span class=\"line\">        priority_queue&lt;long, vector&lt;long&gt;, greater&lt;long&gt;&gt; heap;</span><br><span class=\"line\">        seen.insert(1L);</span><br><span class=\"line\">        heap.push(1L);</span><br><span class=\"line\">        int ugly = 0;</span><br><span class=\"line\">        for (int i = 0; i &lt; k; i++) &#123;</span><br><span class=\"line\">            long curr = heap.top();</span><br><span class=\"line\">            heap.pop();</span><br><span class=\"line\">            ugly = (int)curr;</span><br><span class=\"line\">            for (int factor : factors) &#123;</span><br><span class=\"line\">                long next = curr * factor;</span><br><span class=\"line\">                if (!seen.count(next)) &#123;</span><br><span class=\"line\">                    seen.insert(next);</span><br><span class=\"line\">                    heap.push(next);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ugly;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度\\(O(klogk)\\)</li>\n<li>空间复杂度\\(O(logk)\\)</li>\n</ul>\n",
            "tags": [
                "Medium",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/09/27/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%98-01-02-%E5%88%A4%E5%AE%9A%E6%98%AF%E5%90%A6%E4%BA%92%E4%B8%BA%E5%AD%97%E7%AC%A6%E9%87%8D%E6%8E%92/",
            "url": "https://x-17.top/2022/09/27/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%98-01-02-%E5%88%A4%E5%AE%9A%E6%98%AF%E5%90%A6%E4%BA%92%E4%B8%BA%E5%AD%97%E7%AC%A6%E9%87%8D%E6%8E%92/",
            "title": "面试题 01.02. 判定是否互为字符重排",
            "date_published": "2022-09-27T00:37:49.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/check-permutation-lcci/\">https://leetcode.cn/problems/check-permutation-lcci/</a> 给定两个字符串 s1 和 s2，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。 示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: s1 = &quot;abc&quot;, s2 = &quot;bca&quot;</span><br><span class=\"line\">输出: true</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: s1 = &quot;abc&quot;, s2 = &quot;bad&quot;</span><br><span class=\"line\">输出: false</span><br></pre></td></tr></table></figure>\n<p>说明：</p>\n<ul>\n<li>0 &lt;= len(s1) &lt;= 100</li>\n<li>0 &lt;= len(s2) &lt;= 100</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>排序，哈希都可以</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    bool CheckPermutation(string s1, string s2) &#123;</span><br><span class=\"line\">        sort(s1.begin(),s1.end());</span><br><span class=\"line\">        sort(s2.begin(),s2.end());</span><br><span class=\"line\">        if(s1==s2)</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        else</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度\\(O(nlogn)\\)</li>\n<li>空间复杂度\\(O(logn)\\)</li>\n</ul>\n",
            "tags": [
                "Easy",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/09/26/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%98-17-19-%E6%B6%88%E5%A4%B1%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/",
            "url": "https://x-17.top/2022/09/26/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%98-17-19-%E6%B6%88%E5%A4%B1%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/",
            "title": "面试题 17.19. 消失的两个数字",
            "date_published": "2022-09-25T23:31:31.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/missing-two-lcci/\">https://leetcode.cn/problems/missing-two-lcci/</a> 给定一个数组，包含从 1 到 N 所有的整数，但其中缺了两个数字。你能在 O(N) 时间内只用 O(1) 的空间找到它们吗？ 以任意顺序返回这两个数字均可。 示例 1:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: [1]</span><br><span class=\"line\">输出: [2,3]</span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: [2,3]</span><br><span class=\"line\">输出: [1,4]</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>nums.length &lt;= 30000</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    vector missingTwo(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class=\"line\">        long n = nums.size() + 2;</span><br><span class=\"line\">        int a = -accumulate(nums.cbegin(), nums.cend(), -(1 + n) * n / 2);</span><br><span class=\"line\">        int b = -inner_product(nums.cbegin(), nums.cend(), nums.cbegin(), -(1 + n) * n / 2 * (2 * n + 1) / 3);</span><br><span class=\"line\">        int tmp = sqrt(2 * b - a * a);</span><br><span class=\"line\">        return &#123; (a + tmp) / 2, (a - tmp) / 2 &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度\\(O(n)\\)</li>\n<li>空间复杂度\\(O(1)\\)</li>\n</ul>\n",
            "tags": [
                "Hard",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/09/25/LeetCode/788-%E6%97%8B%E8%BD%AC%E6%95%B0%E5%AD%97/",
            "url": "https://x-17.top/2022/09/25/LeetCode/788-%E6%97%8B%E8%BD%AC%E6%95%B0%E5%AD%97/",
            "title": "788. 旋转数字",
            "date_published": "2022-09-24T23:47:22.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/rotated-digits/\">https://leetcode.cn/problems/rotated-digits/</a> 我们称一个数 X 为好数, 如果它的每位数字逐个地被旋转 180 度后，我们仍可以得到一个有效的，且和 X 不同的数。要求每位数字都要被旋转。 如果一个数的每位数字被旋转以后仍然还是一个数字， 则这个数是有效的。0, 1, 和 8 被旋转后仍然是它们自己；2 和 5 可以互相旋转成对方（在这种情况下，它们以不同的方向旋转，换句话说，2 和 5 互为镜像）；6 和 9 同理，除了这些以外其他的数字旋转以后都不再是有效的数字。 现在我们有一个正整数 N, 计算从 1 到 N 中有多少个数 X 是好数？ 示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: 10</span><br><span class=\"line\">输出: 4</span><br><span class=\"line\">解释: </span><br><span class=\"line\">在[1, 10]中有四个好数： 2, 5, 6, 9。</span><br><span class=\"line\">注意 1 和 10 不是好数, 因为他们在旋转之后不变。</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>N 的取值范围是 [1, 10000]。</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    map&lt;int,int&gt; m;</span><br><span class=\"line\"></span><br><span class=\"line\">    bool is(int n)&#123;</span><br><span class=\"line\">        bool flag=false;</span><br><span class=\"line\">        while(n)&#123;</span><br><span class=\"line\">            if(m.count(n%10)&amp;&amp;m[n%10]==1)&#123;</span><br><span class=\"line\">                flag=true;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if(m.count(n%10)==0)&#123;</span><br><span class=\"line\">                flag=false;</span><br><span class=\"line\">                return flag;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            n/=10;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return flag;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    int rotatedDigits(int n) &#123;</span><br><span class=\"line\">        m[0]=0;</span><br><span class=\"line\">        m[1]=0;</span><br><span class=\"line\">        m[2]=1;</span><br><span class=\"line\">        m[5]=1;</span><br><span class=\"line\">        m[6]=1;</span><br><span class=\"line\">        m[8]=0;</span><br><span class=\"line\">        m[9]=1;</span><br><span class=\"line\">        int ans=0;</span><br><span class=\"line\">        for(int i=1;i&lt;=n;i++)&#123;</span><br><span class=\"line\">            if(is(i))&#123;</span><br><span class=\"line\">                ans++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度\\(O(nlogn)\\)</li>\n<li>空间复杂度\\(O(1)\\)</li>\n</ul>\n",
            "tags": [
                "Medium",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/09/24/LeetCode/1652-%E6%8B%86%E7%82%B8%E5%BC%B9/",
            "url": "https://x-17.top/2022/09/24/LeetCode/1652-%E6%8B%86%E7%82%B8%E5%BC%B9/",
            "title": "1652. 拆炸弹",
            "date_published": "2022-09-24T00:22:47.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/defuse-the-bomb/\">https://leetcode.cn/problems/defuse-the-bomb/</a> 你有一个炸弹需要拆除，时间紧迫！你的情报员会给你一个长度为 n 的 循环 数组 code 以及一个密钥 k 。 为了获得正确的密码，你需要替换掉每一个数字。所有数字会 同时 被替换。 如果 k &gt; 0 ，将第 i 个数字用 接下来 k 个数字之和替换。 如果 k &lt; 0 ，将第 i 个数字用 之前 k 个数字之和替换。 如果 k == 0 ，将第 i 个数字用 0 替换。 由于 code 是循环的， code[n-1] 下一个元素是 code[0] ，且 code[0] 前一个元素是 code[n-1] 。 给你 循环 数组 code 和整数密钥 k ，请你返回解密后的结果来拆除炸弹！ 示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：code = [5,7,1,4], k = 3</span><br><span class=\"line\">输出：[12,10,16,13]</span><br><span class=\"line\">解释：每个数字都被接下来 3 个数字之和替换。解密后的密码为 [7+1+4, 1+4+5, 4+5+7, 5+7+1]。注意到数组是循环连接的。</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：code = [1,2,3,4], k = 0</span><br><span class=\"line\">输出：[0,0,0,0]</span><br><span class=\"line\">解释：当 k 为 0 时，所有数字都被 0 替换。</span><br></pre></td></tr></table></figure>\n<p>示例 3：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：code = [2,4,9,3], k = -2</span><br><span class=\"line\">输出：[12,5,6,13]</span><br><span class=\"line\">解释：解密后的密码为 [3+9, 2+3, 4+2, 9+4] 。注意到数组是循环连接的。如果 k 是负数，那么和为 之前 的数字。</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>n == code.length</li>\n<li>1 &lt;= n &lt;= 100</li>\n<li>1 &lt;= code[i] &lt;= 100</li>\n<li>-(n - 1) &lt;= k &lt;= n - 1</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    vector&lt;int&gt; decrypt(vector&lt;int&gt;&amp; code, int k) &#123;</span><br><span class=\"line\">        vector&lt;int&gt; ans;</span><br><span class=\"line\">        if (k &gt; 0) &#123;</span><br><span class=\"line\">            for(int i = 0; i &lt; code.size(); i++) &#123;</span><br><span class=\"line\">                int num=0;</span><br><span class=\"line\">                for(int j = 1; j &lt;= k; j++) &#123;</span><br><span class=\"line\">                    num += code[(i+j)%code.size()];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                ans.push_back(num);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;else if (k &lt; 0) &#123;</span><br><span class=\"line\">            k = -k;</span><br><span class=\"line\">            for(int i = 0; i &lt; code.size(); i++) &#123;</span><br><span class=\"line\">                int num=0;</span><br><span class=\"line\">                for(int j = 1; j &lt;= k; j++) &#123;</span><br><span class=\"line\">                    num += code[(i-j+code.size())%code.size()];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                ans.push_back(num);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;else &#123;</span><br><span class=\"line\">            for(int i = 0; i &lt; code.size(); i++) &#123;</span><br><span class=\"line\">                ans.push_back(0);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度\\(O(n)\\)</li>\n<li>空间复杂度\\(O(n)\\)</li>\n</ul>\n",
            "tags": [
                "Easy",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/09/23/LeetCode/707-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/",
            "url": "https://x-17.top/2022/09/23/LeetCode/707-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/",
            "title": "707. 设计链表",
            "date_published": "2022-09-23T00:17:08.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/design-linked-list/\">https://leetcode.cn/problems/design-linked-list/</a> 设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。 在链表类中实现这些功能： get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。 addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。 addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。 addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。 deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。 示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">MyLinkedList linkedList = new MyLinkedList();</span><br><span class=\"line\">linkedList.addAtHead(1);</span><br><span class=\"line\">linkedList.addAtTail(3);</span><br><span class=\"line\">linkedList.addAtIndex(1,2); //链表变为1-&gt; 2-&gt; 3</span><br><span class=\"line\">linkedList.get(1); //返回2</span><br><span class=\"line\">linkedList.deleteAtIndex(1); //现在链表是1-&gt; 3</span><br><span class=\"line\">linkedList.get(1); //返回3</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>所有val值都在 [1, 1000] 之内。</li>\n<li>操作次数将在  [1, 1000] 之内。</li>\n<li>请不要使用内置的 LinkedList 库。</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class MyLinkedList &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">    struct ListNode&#123;</span><br><span class=\"line\">        int val;</span><br><span class=\"line\">        ListNode* next;</span><br><span class=\"line\">        ListNode* prev;</span><br><span class=\"line\">        ListNode(int val):val(val), next(nullptr), prev(nullptr) &#123;&#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    int _size;</span><br><span class=\"line\">    ListNode* _dummyHead;</span><br><span class=\"line\">    ListNode* _dummyTail;</span><br><span class=\"line\">    </span><br><span class=\"line\">public:</span><br><span class=\"line\">    MyLinkedList() &#123;</span><br><span class=\"line\">        _dummyHead = new ListNode(0);</span><br><span class=\"line\">        _dummyTail = new ListNode(0);</span><br><span class=\"line\">        _dummyHead-&gt;next = _dummyTail;</span><br><span class=\"line\">        _dummyTail-&gt;prev = _dummyHead;</span><br><span class=\"line\">        _size = 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    int get(int index) &#123;</span><br><span class=\"line\">        if(index &gt; _size - 1  index &lt; 0)&#123; return -1; &#125; ListNode* cur = _dummyHead-&gt;next;</span><br><span class=\"line\">        while(index--)&#123;</span><br><span class=\"line\">            cur = cur-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return cur-&gt;val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    void addAtHead(int val) &#123;</span><br><span class=\"line\">        ListNode* p = new ListNode(val);</span><br><span class=\"line\">        p-&gt;next = _dummyHead-&gt;next;</span><br><span class=\"line\">        _dummyHead-&gt;next-&gt;prev = p;</span><br><span class=\"line\">        _dummyHead-&gt;next = p;</span><br><span class=\"line\">        p-&gt;prev = _dummyHead;</span><br><span class=\"line\">        _size++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    void addAtTail(int val) &#123;</span><br><span class=\"line\">        ListNode* p = new ListNode(val);</span><br><span class=\"line\">        _dummyTail-&gt;prev-&gt;next = p;</span><br><span class=\"line\">        p-&gt;prev = _dummyTail-&gt;prev;</span><br><span class=\"line\">        p-&gt;next = _dummyTail;</span><br><span class=\"line\">        _dummyTail-&gt;prev = p;</span><br><span class=\"line\">        _size++;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    void addAtIndex(int index, int val) &#123;</span><br><span class=\"line\">        if(index &gt; _size  index &lt; 0)&#123; return ; &#125; ListNode* cur = _dummyHead-&gt;next;</span><br><span class=\"line\">        ListNode* p = new ListNode(val);</span><br><span class=\"line\">        while(index--)&#123;</span><br><span class=\"line\">            cur = cur-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cur-&gt;prev-&gt;next = p;</span><br><span class=\"line\">        p-&gt;prev = cur-&gt;prev;</span><br><span class=\"line\">        p-&gt;next = cur;</span><br><span class=\"line\">        cur-&gt;prev = p;</span><br><span class=\"line\">        _size++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    void deleteAtIndex(int index) &#123;</span><br><span class=\"line\">        if(index &gt; _size - 1  index &lt; 0)&#123; return ; &#125; ListNode* cur = _dummyHead-&gt;next;</span><br><span class=\"line\">        while(index--)&#123;</span><br><span class=\"line\">            cur = cur-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cur-&gt;prev-&gt;next = cur-&gt;next;</span><br><span class=\"line\">        cur-&gt;next-&gt;prev = cur-&gt;prev;</span><br><span class=\"line\">        delete(cur);</span><br><span class=\"line\">        _size--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Your MyLinkedList object will be instantiated and called as such:</span><br><span class=\"line\"> * MyLinkedList* obj = new MyLinkedList();</span><br><span class=\"line\"> * int param_1 = obj-&gt;get(index);</span><br><span class=\"line\"> * obj-&gt;addAtHead(val);</span><br><span class=\"line\"> * obj-&gt;addAtTail(val);</span><br><span class=\"line\"> * obj-&gt;addAtIndex(index,val);</span><br><span class=\"line\"> * obj-&gt;deleteAtIndex(index);</span><br><span class=\"line\"> */</span><br></pre></td></tr></table></figure>",
            "tags": [
                "Medium",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/09/22/LeetCode/1640-%E8%83%BD%E5%90%A6%E8%BF%9E%E6%8E%A5%E5%BD%A2%E6%88%90%E6%95%B0%E7%BB%84/",
            "url": "https://x-17.top/2022/09/22/LeetCode/1640-%E8%83%BD%E5%90%A6%E8%BF%9E%E6%8E%A5%E5%BD%A2%E6%88%90%E6%95%B0%E7%BB%84/",
            "title": "1640. 能否连接形成数组",
            "date_published": "2022-09-21T23:48:07.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/check-array-formation-through-concatenation/\">https://leetcode.cn/problems/check-array-formation-through-concatenation/</a> 给你一个整数数组 arr ，数组中的每个整数 互不相同 。另有一个由整数数组构成的数组 pieces，其中的整数也 互不相同 。请你以 任意顺序 连接 pieces 中的数组以形成 arr 。但是，不允许 对每个数组 pieces[i] 中的整数重新排序。 如果可以连接 pieces 中的数组形成 arr ，返回 true ；否则，返回 false 。 示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：arr = [15,88], pieces = [[88],[15]]</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">解释：依次连接 [15] 和 [88]</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：arr = [49,18,16], pieces = [[16,18,49]]</span><br><span class=\"line\">输出：false</span><br><span class=\"line\">解释：即便数字相符，也不能重新排列 pieces[0]</span><br></pre></td></tr></table></figure>\n<p>示例 3：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：arr = [91,4,64,78], pieces = [[78],[4,64],[91]]</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">解释：依次连接 [91]、[4,64] 和 [78]</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>1 &lt;= pieces.length &lt;= arr.length &lt;= 100</li>\n<li>sum(pieces[i].length) == arr.length</li>\n<li>1 &lt;= pieces[i].length &lt;= arr.length</li>\n<li>1 &lt;= arr[i], pieces[i][j] &lt;= 100</li>\n<li>arr 中的整数 互不相同</li>\n<li>pieces 中的整数 互不相同（也就是说，如果将 pieces 扁平化成一维数组，数组中的所有整数互不相同）</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    bool canFormArray(vector&lt;int&gt;&amp; arr, vector&lt;vector&lt;int&gt;&gt;&amp; pieces) &#123;</span><br><span class=\"line\">        map&lt;int,int&gt; m;</span><br><span class=\"line\">        for(int i=0;i&lt;arr.size();i++)&#123;</span><br><span class=\"line\">            m[arr[i]]=i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        map&lt;int,int&gt; n;</span><br><span class=\"line\">        for(int i=0;i&lt;pieces.size();i++)&#123;</span><br><span class=\"line\">            if(m.count(pieces[i][0])==0)&#123;</span><br><span class=\"line\">                return false;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            for(int j=1;j&lt;pieces[i].size();j++)&#123;</span><br><span class=\"line\">                if(m.count(pieces[i][0])==0)&#123;</span><br><span class=\"line\">                    return false;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if(m[pieces[i][j]]!=m[pieces[i][j-1]]+1)&#123;</span><br><span class=\"line\">                    return false;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度\\(O(n)\\)</li>\n<li>空间复杂度\\(O(n)\\)</li>\n</ul>\n",
            "tags": [
                "Easy",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/09/21/LeetCode/854-%E7%9B%B8%E4%BC%BC%E5%BA%A6%E4%B8%BA-k-%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/",
            "url": "https://x-17.top/2022/09/21/LeetCode/854-%E7%9B%B8%E4%BC%BC%E5%BA%A6%E4%B8%BA-k-%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/",
            "title": "854. 相似度为 K 的字符串",
            "date_published": "2022-09-21T01:05:22.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/k-similar-strings/\">https://leetcode.cn/problems/k-similar-strings/</a> 对于某些非负整数 k ，如果交换 s1 中两个字母的位置恰好 k 次，能够使结果字符串等于 s2 ，则认为字符串 s1 和 s2 的 相似度为 k 。 给你两个字母异位词 s1 和 s2 ，返回 s1 和 s2 的相似度 k 的最小值。 示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：s1 = &quot;ab&quot;, s2 = &quot;ba&quot;</span><br><span class=\"line\">输出：1</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：s1 = &quot;abc&quot;, s2 = &quot;bca&quot;</span><br><span class=\"line\">输出：2</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>1 &lt;= s1.length &lt;= 20</li>\n<li>s2.length == s1.length</li>\n<li>s1 和 s2  只包含集合 {‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’} 中的小写字母</li>\n<li>s2 是 s1 的一个字母异位词</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int kSimilarity(string s1, string s2) &#123;</span><br><span class=\"line\">        int n = s1.size();</span><br><span class=\"line\">        queue&lt;pair&lt;string, int&gt;&gt; qu;</span><br><span class=\"line\">        unordered_set&lt;string&gt; visit;</span><br><span class=\"line\">        qu.emplace(s1, 0);</span><br><span class=\"line\">        visit.emplace(s1);</span><br><span class=\"line\">        for (int step = 0;; step++) &#123;</span><br><span class=\"line\">            int sz = qu.size();</span><br><span class=\"line\">            for (int i = 0; i &lt; sz; i++) &#123;</span><br><span class=\"line\">                auto [cur, pos] = qu.front();</span><br><span class=\"line\">                qu.pop();</span><br><span class=\"line\">                if (cur == s2) &#123;</span><br><span class=\"line\">                    return step;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                while (pos &lt; n &amp;&amp; cur[pos] == s2[pos]) &#123;</span><br><span class=\"line\">                    pos++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                for (int j = pos + 1; j &lt; n; j++) &#123;</span><br><span class=\"line\">                    if (cur[j] != s2[j] &amp;&amp; cur[j] == s2[pos]) &#123; // 剪枝，只在 cur[j] != s2[j] 时去交换</span><br><span class=\"line\">                        swap(cur[pos], cur[j]);</span><br><span class=\"line\">                        if (!visit.count(cur)) &#123;</span><br><span class=\"line\">                            visit.emplace(cur);</span><br><span class=\"line\">                            qu.emplace(cur, pos + 1);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        swap(cur[pos], cur[j]);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>",
            "tags": [
                "Hard",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/09/20/LeetCode/698-%E5%88%92%E5%88%86%E4%B8%BAk%E4%B8%AA%E7%9B%B8%E7%AD%89%E7%9A%84%E5%AD%90%E9%9B%86/",
            "url": "https://x-17.top/2022/09/20/LeetCode/698-%E5%88%92%E5%88%86%E4%B8%BAk%E4%B8%AA%E7%9B%B8%E7%AD%89%E7%9A%84%E5%AD%90%E9%9B%86/",
            "title": "698. 划分为k个相等的子集",
            "date_published": "2022-09-20T00:20:31.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/\">https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/</a> 给定一个整数数组  nums 和一个正整数 k，找出是否有可能把这个数组分成 k 个非空子集，其总和都相等。 示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入： nums = [4, 3, 2, 3, 5, 2, 1], k = 4</span><br><span class=\"line\">输出： True</span><br><span class=\"line\">说明： 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和。</span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: nums = [1,2,3,4], k = 3</span><br><span class=\"line\">输出: false</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>1 &lt;= k &lt;= len(nums) &lt;= 16</li>\n<li>0 &lt; nums[i] &lt; 10000</li>\n<li>每个元素的频率在 [1,4] 范围内</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    bool canPartitionKSubsets(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class=\"line\">        int all = accumulate(nums.begin(), nums.end(), 0);</span><br><span class=\"line\">        if (all % k &gt; 0) &#123;</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        int per = all / k; </span><br><span class=\"line\">        sort(nums.begin(), nums.end());</span><br><span class=\"line\">        if (nums.back() &gt; per) &#123;</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        int n = nums.size();</span><br><span class=\"line\">        vector&lt;bool&gt; dp(1 &lt;&lt; n, false);</span><br><span class=\"line\">        vector&lt;int&gt; curSum(1 &lt;&lt; n, 0);</span><br><span class=\"line\">        dp[0] = true;</span><br><span class=\"line\">        for (int i = 0; i &lt; 1 &lt;&lt; n; i++) &#123;</span><br><span class=\"line\">            if (!dp[i]) &#123;</span><br><span class=\"line\">                continue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            for (int j = 0; j &lt; n; j++) &#123; if (curSum[i] + nums[j] &gt; per) &#123;</span><br><span class=\"line\">                    break;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if (((i &gt;&gt; j) &amp; 1) == 0) &#123;</span><br><span class=\"line\">                    int next = i  (1 &lt;&lt; j);</span><br><span class=\"line\">                    if (!dp[next]) &#123;</span><br><span class=\"line\">                        curSum[next] = (curSum[i] + nums[j]) % per;</span><br><span class=\"line\">                        dp[next] = true;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return dp[(1 &lt;&lt; n) - 1];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度\\(O(n*2^n)\\)</li>\n<li>空间复杂度\\(O(2^n)\\)</li>\n</ul>\n",
            "tags": [
                "Medium",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/09/19/LeetCode/1636-%E6%8C%89%E7%85%A7%E9%A2%91%E7%8E%87%E5%B0%86%E6%95%B0%E7%BB%84%E5%8D%87%E5%BA%8F%E6%8E%92%E5%BA%8F/",
            "url": "https://x-17.top/2022/09/19/LeetCode/1636-%E6%8C%89%E7%85%A7%E9%A2%91%E7%8E%87%E5%B0%86%E6%95%B0%E7%BB%84%E5%8D%87%E5%BA%8F%E6%8E%92%E5%BA%8F/",
            "title": "1636. 按照频率将数组升序排序",
            "date_published": "2022-09-19T00:15:06.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/sort-array-by-increasing-frequency/\">https://leetcode.cn/problems/sort-array-by-increasing-frequency/</a> 给你一个整数数组 nums ，请你将数组按照每个值的频率 升序 排序。如果有多个值的频率相同，请你按照数值本身将它们 降序 排序。 请你返回排序后的数组。 示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,1,2,2,2,3]</span><br><span class=\"line\">输出：[3,1,1,2,2,2]</span><br><span class=\"line\">解释：&#x27;3&#x27; 频率为 1，&#x27;1&#x27; 频率为 2，&#x27;2&#x27; 频率为 3 。</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [2,3,1,3,2]</span><br><span class=\"line\">输出：[1,3,3,2,2]</span><br><span class=\"line\">解释：&#x27;2&#x27; 和 &#x27;3&#x27; 频率都为 2 ，所以它们之间按照数值本身降序排序。</span><br></pre></td></tr></table></figure>\n<p>示例 3：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [-1,1,-6,4,5,-6,1,4,1]</span><br><span class=\"line\">输出：[5,-1,4,4,-6,-6,1,1,1]</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>1 &lt;= nums.length &lt;= 100</li>\n<li>-100 &lt;= nums[i] &lt;= 100</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    vector&lt;int&gt; frequencySort(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class=\"line\">        unordered_map&lt;int, int&gt; cnt;</span><br><span class=\"line\">        for (int num : nums) &#123;</span><br><span class=\"line\">            cnt[num]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sort(nums.begin(), nums.end(), [&amp;](const int a, const int b) &#123;</span><br><span class=\"line\">            if (cnt[a] != cnt[b]) &#123;</span><br><span class=\"line\">                return cnt[a] &lt; cnt[b]; </span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">            return a &gt; b;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        return nums;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度\\(O(nlogn)\\)</li>\n<li>空间复杂度\\(O(n)\\)</li>\n</ul>\n",
            "tags": [
                "Easy",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/09/18/LeetCode/827-%E6%9C%80%E5%A4%A7%E4%BA%BA%E5%B7%A5%E5%B2%9B/",
            "url": "https://x-17.top/2022/09/18/LeetCode/827-%E6%9C%80%E5%A4%A7%E4%BA%BA%E5%B7%A5%E5%B2%9B/",
            "title": "827. 最大人工岛",
            "date_published": "2022-09-18T00:29:56.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/making-a-large-island/\">https://leetcode.cn/problems/making-a-large-island/</a> 给你一个大小为 n x n 二进制矩阵 grid 。最多 只能将一格 0 变成 1 。 返回执行此操作后，grid 中最大的岛屿面积是多少？ 岛屿 由一组上、下、左、右四个方向相连的 1 形成。 示例 1:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: grid = [[1, 0], [0, 1]]</span><br><span class=\"line\">输出: 3</span><br><span class=\"line\">解释: 将一格0变成1，最终连通两个小岛得到面积为 3 的岛屿。</span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: grid = [[1, 1], [1, 0]]</span><br><span class=\"line\">输出: 4</span><br><span class=\"line\">解释: 将一格0变成1，岛屿的面积扩大为 4。</span><br></pre></td></tr></table></figure>\n<p>示例 3:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: grid = [[1, 1], [1, 1]]</span><br><span class=\"line\">输出: 4</span><br><span class=\"line\">解释: 没有0可以让我们变成1，面积依然为 4。</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>n == grid.length</li>\n<li>n == grid[i].length</li>\n<li>1 &lt;= n &lt;= 500</li>\n<li>grid[i][j] 为 0 或 1</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const vector&lt;int&gt; d = &#123;0, -1, 0, 1, 0&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    bool valid(int n, int x, int y) &#123;</span><br><span class=\"line\">        return x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    int dfs(const vector&lt;vector&lt;int&gt;&gt; &amp;grid, int x, int y, vector&lt;vector&lt;int&gt;&gt; &amp;tag, int t) &#123;</span><br><span class=\"line\">        int n = grid.size(), res = 1;</span><br><span class=\"line\">        tag[x][y] = t;</span><br><span class=\"line\">        for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class=\"line\">            int x1 = x + d[i], y1 = y + d[i + 1];</span><br><span class=\"line\">            if (valid(n, x1, y1) &amp;&amp; grid[x1][y1] == 1 &amp;&amp; tag[x1][y1] == 0) &#123;</span><br><span class=\"line\">                res += dfs(grid, x1, y1, tag, t);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    int largestIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class=\"line\">        int n = grid.size(), res = 0;</span><br><span class=\"line\">        vector&lt;vector&lt;int&gt;&gt; tag(n, vector&lt;int&gt;(n));</span><br><span class=\"line\">        unordered_map&lt;int, int&gt; area;</span><br><span class=\"line\">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class=\"line\">            for (int j = 0; j &lt; n; j++) &#123;</span><br><span class=\"line\">                if (grid[i][j] == 1 &amp;&amp; tag[i][j] == 0) &#123;</span><br><span class=\"line\">                    int t = i * n + j + 1;</span><br><span class=\"line\">                    area[t] = dfs(grid, i, j, tag, t);</span><br><span class=\"line\">                    res = max(res, area[t]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class=\"line\">            for (int j = 0; j &lt; n; j++) &#123;</span><br><span class=\"line\">                if (grid[i][j] == 0) &#123;</span><br><span class=\"line\">                    int z = 1;</span><br><span class=\"line\">                    unordered_set&lt;int&gt; connected;</span><br><span class=\"line\">                    for (int k = 0; k &lt; 4; k++) &#123; int x = i + d[k], y = j + d[k + 1]; if (!valid(n, x, y)  tag[x][y] == 0  connected.count(tag[x][y]) &gt; 0) &#123;</span><br><span class=\"line\">                            continue;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        z += area[tag[x][y]];</span><br><span class=\"line\">                        connected.insert(tag[x][y]);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    res = max(res, z);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度\\(O(n^2)\\)</li>\n<li>空间复杂度\\(O(n^2)\\)</li>\n</ul>\n",
            "tags": [
                "Hard",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/09/17/LeetCode/1624-%E4%B8%A4%E4%B8%AA%E7%9B%B8%E5%90%8C%E5%AD%97%E7%AC%A6%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/",
            "url": "https://x-17.top/2022/09/17/LeetCode/1624-%E4%B8%A4%E4%B8%AA%E7%9B%B8%E5%90%8C%E5%AD%97%E7%AC%A6%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/",
            "title": "1624. 两个相同字符之间的最长子字符串",
            "date_published": "2022-09-17T06:06:02.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/largest-substring-between-two-equal-characters/\">https://leetcode.cn/problems/largest-substring-between-two-equal-characters/</a> 给你一个字符串 s，请你返回 两个相同字符之间的最长子字符串的长度 ，计算长度时不含这两个字符。如果不存在这样的子字符串，返回 -1 。 子字符串 是字符串中的一个连续字符序列。 示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;aa&quot;</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：最优的子字符串是两个 &#x27;a&#x27; 之间的空子字符串。</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;abca&quot;</span><br><span class=\"line\">输出：2</span><br><span class=\"line\">解释：最优的子字符串是 &quot;bc&quot; 。</span><br></pre></td></tr></table></figure>\n<p>示例 3：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;cbzxy&quot;</span><br><span class=\"line\">输出：-1</span><br><span class=\"line\">解释：s 中不存在出现出现两次的字符，所以返回 -1 。</span><br></pre></td></tr></table></figure>\n<p>示例 4：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;cabbac&quot;</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：最优的子字符串是 &quot;abba&quot; ，其他的非最优解包括 &quot;bb&quot; 和 &quot;&quot; 。</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>1 &lt;= s.length &lt;= 300</li>\n<li>s 只含小写英文字母</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int maxLengthBetweenEqualCharacters(string s) &#123;</span><br><span class=\"line\">        map&lt;char,vector&lt;int&gt;&gt; m;</span><br><span class=\"line\">        for(int i=0;i&lt;s.length();i++)&#123;</span><br><span class=\"line\">            m[s[i]].push_back(i); </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        int ans=-1; </span><br><span class=\"line\">        for(auto it=m.begin();it!=m.end();it++)&#123; </span><br><span class=\"line\">            if(it-&gt;second.size()&gt;=2)&#123;</span><br><span class=\"line\">                ans=max(ans,it-&gt;second[it-&gt;second.size()-1]-it-&gt;second[0]-1);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度\\(O(n)\\)</li>\n<li>空间复杂度\\(O(n)\\)</li>\n</ul>\n",
            "tags": [
                "Easy",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/09/16/LeetCode/850-%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF-ii/",
            "url": "https://x-17.top/2022/09/16/LeetCode/850-%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF-ii/",
            "title": "850. 矩形面积 II",
            "date_published": "2022-09-16T02:04:12.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/rectangle-area-ii/\">https://leetcode.cn/problems/rectangle-area-ii/</a> 我们给出了一个（轴对齐的）二维矩形列表 rectangles 。 对于 rectangle[i] = [x1, y1, x2, y2]，其中（x1，y1）是矩形 i 左下角的坐标， (xi1, yi1) 是该矩形 左下角 的坐标， (xi2, yi2) 是该矩形 右上角 的坐标。 计算平面中所有 rectangles 所覆盖的 总面积 。任何被两个或多个矩形覆盖的区域应只计算 一次 。 返回 总面积 。因为答案可能太大，返回 \\(10^9 + 7\\) 的 模 。 示例 1： <img src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/06/rectangle_area_ii_pic.png\" alt=\"\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：rectangles = [[0,0,2,2],[1,0,2,3],[1,0,3,1]]</span><br><span class=\"line\">输出：6</span><br><span class=\"line\">解释：如图所示，三个矩形覆盖了总面积为6的区域。</span><br><span class=\"line\">从(1,1)到(2,2)，绿色矩形和红色矩形重叠。</span><br><span class=\"line\">从(1,0)到(2,3)，三个矩形都重叠。</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：rectangles = [[0,0,1000000000,1000000000]]</span><br><span class=\"line\">输出：49</span><br></pre></td></tr></table></figure>\n<p>解释：答案是 \\(10^{18} 对 (10^9 + 7) \\)取模的结果， 即 49 。 提示：</p>\n<ul>\n<li>1 &lt;= rectangles.length &lt;= 200</li>\n<li>rectanges[i].length = 4</li>\n<li>\\(0 &lt;= x_{i1}, y_{i1}, x_{i2}, y_{i2} &lt;= 10^9\\)</li>\n<li>矩形叠加覆盖后的总面积不会超越 \\(2^{63}  - 1 \\)，这意味着可以用一个 64 位有符号整数来保存面积结果。</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int rectangleArea(vector&lt;vector&lt;int&gt;&gt;&amp; rectangles) &#123;</span><br><span class=\"line\">        int n = rectangles.size();</span><br><span class=\"line\">        vector&lt;int&gt; hbound;</span><br><span class=\"line\">        for (const auto&amp; rect: rectangles) &#123;</span><br><span class=\"line\">            // 下边界</span><br><span class=\"line\">            hbound.push_back(rect[1]);</span><br><span class=\"line\">            // 上边界</span><br><span class=\"line\">            hbound.push_back(rect[3]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sort(hbound.begin(), hbound.end());</span><br><span class=\"line\">        hbound.erase(unique(hbound.begin(), hbound.end()), hbound.end());</span><br><span class=\"line\">        int m = hbound.size();</span><br><span class=\"line\">        // 「思路与算法部分」的 length 数组并不需要显式地存储下来</span><br><span class=\"line\">        // length[i] 可以通过 hbound[i+1] - hbound[i] 得到</span><br><span class=\"line\">        vector&lt;int&gt; seg(m - 1);</span><br><span class=\"line\"></span><br><span class=\"line\">        vector&lt;tuple&lt;int, int, int&gt;&gt; sweep;</span><br><span class=\"line\">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            // 左边界</span><br><span class=\"line\">            sweep.emplace_back(rectangles[i][0], i, 1);</span><br><span class=\"line\">            // 右边界</span><br><span class=\"line\">            sweep.emplace_back(rectangles[i][2], i, -1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sort(sweep.begin(), sweep.end());</span><br><span class=\"line\"></span><br><span class=\"line\">        long long ans = 0;</span><br><span class=\"line\">        for (int i = 0; i &lt; sweep.size(); ++i) &#123;</span><br><span class=\"line\">            int j = i;</span><br><span class=\"line\">            while (j + 1 &lt; sweep.size() &amp;&amp; get&lt;0&gt;(sweep[i]) == get&lt;0&gt;(sweep[j + 1])) &#123;</span><br><span class=\"line\">                ++j;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (j + 1 == sweep.size()) &#123;</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            // 一次性地处理掉一批横坐标相同的左右边界</span><br><span class=\"line\">            for (int k = i; k &lt;= j; ++k) &#123;</span><br><span class=\"line\">                auto&amp;&amp; [_, idx, diff] = sweep[k];</span><br><span class=\"line\">                int left = rectangles[idx][1], right = rectangles[idx][3];</span><br><span class=\"line\">                for (int x = 0; x &lt; m - 1; ++x) &#123;</span><br><span class=\"line\">                    if (left &lt;= hbound[x] &amp;&amp; hbound[x + 1] &lt;= right) &#123;</span><br><span class=\"line\">                        seg[x] += diff;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            int cover = 0;</span><br><span class=\"line\">            for (int k = 0; k &lt; m - 1; ++k) &#123; if (seg[k] &gt; 0) &#123;</span><br><span class=\"line\">                    cover += (hbound[k + 1] - hbound[k]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ans += static_cast&lt;long long&gt;(cover) * (get&lt;0&gt;(sweep[j + 1]) - get&lt;0&gt;(sweep[j]));</span><br><span class=\"line\">            i = j;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ans % static_cast&lt;int&gt;(1e9 + 7);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度\\(O(n^2)\\)</li>\n<li>空间复杂度\\(O(n)\\)</li>\n</ul>\n",
            "tags": [
                "Hard",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/09/15/LeetCode/672-%E7%81%AF%E6%B3%A1%E5%BC%80%E5%85%B3-%E2%85%B1/",
            "url": "https://x-17.top/2022/09/15/LeetCode/672-%E7%81%AF%E6%B3%A1%E5%BC%80%E5%85%B3-%E2%85%B1/",
            "title": "672. 灯泡开关 Ⅱ",
            "date_published": "2022-09-15T12:55:47.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/bulb-switcher-ii/\">https://leetcode.cn/problems/bulb-switcher-ii/</a> 房间中有 n 只已经打开的灯泡，编号从 1 到 n 。墙上挂着 4 个开关 。 这 4 个开关各自都具有不同的功能，其中： 开关 1 ：反转当前所有灯的状态（即开变为关，关变为开） 开关 2 ：反转编号为偶数的灯的状态（即 2, 4, …） 开关 3 ：反转编号为奇数的灯的状态（即 1, 3, …） 开关 4 ：反转编号为 j = 3k + 1 的灯的状态，其中 k = 0, 1, 2, …（即 1, 4, 7, 10, …） 你必须 恰好 按压开关 presses 次。每次按压，你都需要从 4 个开关中选出一个来执行按压操作。 给你两个整数 n 和 presses ，执行完所有按压之后，返回 不同可能状态 的数量。 示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：n = 1, presses = 1</span><br><span class=\"line\">输出：2</span><br><span class=\"line\">解释：状态可以是：</span><br><span class=\"line\">- 按压开关 1 ，[关]</span><br><span class=\"line\">- 按压开关 2 ，[开]</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：n = 2, presses = 1</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：状态可以是：</span><br><span class=\"line\">- 按压开关 1 ，[关, 关]</span><br><span class=\"line\">- 按压开关 2 ，[开, 关]</span><br><span class=\"line\">- 按压开关 3 ，[关, 开]</span><br></pre></td></tr></table></figure>\n<p>示例 3：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：n = 3, presses = 1</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：状态可以是：</span><br><span class=\"line\">- 按压开关 1 ，[关, 关, 关]</span><br><span class=\"line\">- 按压开关 2 ，[关, 开, 关]</span><br><span class=\"line\">- 按压开关 3 ，[开, 开, 开]</span><br><span class=\"line\">- 按压开关 4 ，[关, 开, 开]</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>1 &lt;= n &lt;= 1000</li>\n<li>0 &lt;= presses &lt;= 1000</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int flipLights(int n, int presses) &#123;</span><br><span class=\"line\">        if(presses==0)</span><br><span class=\"line\">            return 1;</span><br><span class=\"line\">        if(n==1)</span><br><span class=\"line\">            return 2;</span><br><span class=\"line\">        else if(n==2)</span><br><span class=\"line\">            return presses==1?3:4;</span><br><span class=\"line\">        else</span><br><span class=\"line\">            return presses==1?4:presses==2?7:8;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度\\(O(1)\\)</li>\n<li>空间复杂度\\(O(1)\\)</li>\n</ul>\n",
            "tags": [
                "Medium",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/09/14/LeetCode/1619-%E5%88%A0%E9%99%A4%E6%9F%90%E4%BA%9B%E5%85%83%E7%B4%A0%E5%90%8E%E7%9A%84%E6%95%B0%E7%BB%84%E5%9D%87%E5%80%BC/",
            "url": "https://x-17.top/2022/09/14/LeetCode/1619-%E5%88%A0%E9%99%A4%E6%9F%90%E4%BA%9B%E5%85%83%E7%B4%A0%E5%90%8E%E7%9A%84%E6%95%B0%E7%BB%84%E5%9D%87%E5%80%BC/",
            "title": "1619. 删除某些元素后的数组均值",
            "date_published": "2022-09-14T05:55:59.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/mean-of-array-after-removing-some-elements/\">https://leetcode.cn/problems/mean-of-array-after-removing-some-elements/</a> 给你一个整数数组 arr ，请你删除最小 5% 的数字和最大 5% 的数字后，剩余数字的平均值。 与 标准答案 误差在 10-5 的结果都被视为正确结果。 示例 1： 输入：arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3] 输出：2.00000 解释：删除数组中最大和最小的元素后，所有元素都等于 2，所以平均值为 2 。 示例 2： 输入：arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0] 输出：4.00000 示例 3： 输入：arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4] 输出：4.77778 示例 4： 输入：arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3] 输出：5.27778 示例 5： 输入：arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1] 输出：5.29167 提示：</p>\n<ul>\n<li>20 &lt;= arr.length &lt;= 1000</li>\n<li>arr.length 是 20 的 倍数</li>\n<li>\\(0 &lt;= arr[i] &lt;= 10^5\\)</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    double trimMean(vector&lt;int&gt;&amp; arr) &#123;</span><br><span class=\"line\">        sort(arr.begin(),arr.end());</span><br><span class=\"line\">        double ans=0;</span><br><span class=\"line\">        int n=arr.size();</span><br><span class=\"line\">        for(int i=n/20;i&lt;n-n/20;i++)&#123;</span><br><span class=\"line\">            ans+=arr[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ans/(n-n/10);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度\\(O(nlogn)\\)</li>\n<li>空间复杂度\\(O(logn)\\)</li>\n</ul>\n",
            "tags": [
                "Easy",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/09/13/LeetCode/670-%E6%9C%80%E5%A4%A7%E4%BA%A4%E6%8D%A2/",
            "url": "https://x-17.top/2022/09/13/LeetCode/670-%E6%9C%80%E5%A4%A7%E4%BA%A4%E6%8D%A2/",
            "title": "670. 最大交换",
            "date_published": "2022-09-13T05:28:29.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/maximum-swap/\">https://leetcode.cn/problems/maximum-swap/</a>给定一个非负整数，你至多可以交换一次数字中的任意两位。返回你能得到的最大值。 示例 1 :</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: 2736</span><br><span class=\"line\">输出: 7236</span><br><span class=\"line\">解释: 交换数字2和数字7。</span><br></pre></td></tr></table></figure>\n<p>示例 2 :</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: 9973</span><br><span class=\"line\">输出: 9973</span><br><span class=\"line\">解释: 不需要交换。</span><br></pre></td></tr></table></figure>\n<p>注意:</p>\n<ul>\n<li>给定数字的范围是 \\([0, 10^8]\\)</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>暴力</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int maximumSwap(int num) &#123;</span><br><span class=\"line\">        vector&lt;int&gt; a;</span><br><span class=\"line\">        while(num)&#123;</span><br><span class=\"line\">            a.push_back(num%10);</span><br><span class=\"line\">            num/=10;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        int t=1;</span><br><span class=\"line\">        for(int j=1;j&lt;a.size();j++)&#123; </span><br><span class=\"line\">            if(t)&#123; </span><br><span class=\"line\">                int n=a[a.size()-j]; </span><br><span class=\"line\">                int flag=a.size()-j; </span><br><span class=\"line\">                for(int i=flag-1;i&gt;=0;i--)&#123;</span><br><span class=\"line\">                    if((a[i]&gt;n&amp;&amp;t==1)(a[i]&gt;=n&amp;&amp;t==0))&#123;</span><br><span class=\"line\">                        n=a[i];</span><br><span class=\"line\">                        flag=i;</span><br><span class=\"line\">                        t=0;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                a[flag]=a[a.size()-j];</span><br><span class=\"line\">                a[a.size()-j]=n;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        for(int i=a.size()-1;i&gt;=0;i--)&#123;</span><br><span class=\"line\">            num*=10;</span><br><span class=\"line\">            num+=a[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return num;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度\\(O(log^2n)\\)</li>\n<li>空间复杂度\\(O(logn)\\)</li>\n</ul>\n",
            "tags": [
                "Medium",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/09/12/LeetCode/1608-%E7%89%B9%E6%AE%8A%E6%95%B0%E7%BB%84%E7%9A%84%E7%89%B9%E5%BE%81%E5%80%BC/",
            "url": "https://x-17.top/2022/09/12/LeetCode/1608-%E7%89%B9%E6%AE%8A%E6%95%B0%E7%BB%84%E7%9A%84%E7%89%B9%E5%BE%81%E5%80%BC/",
            "title": "1608. 特殊数组的特征值",
            "date_published": "2022-09-12T06:55:57.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/special-array-with-x-elements-greater-than-or-equal-x/\">https://leetcode.cn/problems/special-array-with-x-elements-greater-than-or-equal-x/</a>给你一个非负整数数组 nums 。如果存在一个数 x ，使得 nums 中恰好有 x 个元素 大于或者等于 x ，那么就称 nums 是一个 特殊数组 ，而 x 是该数组的 特征值 。 注意： x 不必 是 nums 的中的元素。 如果数组 nums 是一个 特殊数组 ，请返回它的特征值 x 。否则，返回 -1 。可以证明的是，如果 nums 是特殊数组，那么其特征值 x 是 唯一的 。 示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [3,5]</span><br><span class=\"line\">输出：2</span><br><span class=\"line\">解释：有 2 个元素（3 和 5）大于或等于 2 。</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [0,0]</span><br><span class=\"line\">输出：-1</span><br><span class=\"line\">解释：没有满足题目要求的特殊数组，故而也不存在特征值 x 。</span><br><span class=\"line\">如果 x = 0，应该有 0 个元素 &gt;= x，但实际有 2 个。</span><br><span class=\"line\">如果 x = 1，应该有 1 个元素 &gt;= x，但实际有 0 个。</span><br><span class=\"line\">如果 x = 2，应该有 2 个元素 &gt;= x，但实际有 0 个。</span><br><span class=\"line\">x 不能取更大的值，因为 nums 中只有两个元素。</span><br></pre></td></tr></table></figure>\n<p>示例 3：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [0,4,3,0,4]</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：有 3 个元素大于或等于 3 。</span><br></pre></td></tr></table></figure>\n<p>示例 4：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [3,6,7,7,0]</span><br><span class=\"line\">输出：-1</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>1 &lt;= nums.length &lt;= 100</li>\n<li>0 &lt;= nums[i] &lt;= 1000</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>降序排列找到第i位元素大于等于i且第i+1位小于i,i即为所求。(前面所述的i从1开始，代码中从0开始所以i+1为所求）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    static bool compare(int a,int b)&#123;</span><br><span class=\"line\">        return a&gt;b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    int specialArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class=\"line\">        sort(nums.begin(),nums.end(),compare);</span><br><span class=\"line\">        for(int i=0;i&lt;nums.size();i++)&#123; </span><br><span class=\"line\">            if(nums[i]&gt;i)&#123;</span><br><span class=\"line\">                if(i+1==nums.size())&#123;</span><br><span class=\"line\">                    return nums.size();</span><br><span class=\"line\">                &#125;else if(nums[i+1]&lt;=i)&#123;</span><br><span class=\"line\">                    return i+1;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度\\(O(nlogn)\\)</li>\n<li>空间复杂度\\(O(logn)\\)</li>\n</ul>\n",
            "tags": [
                "Easy",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/09/11/LeetCode/857-%E9%9B%87%E4%BD%A3-k-%E5%90%8D%E5%B7%A5%E4%BA%BA%E7%9A%84%E6%9C%80%E4%BD%8E%E6%88%90%E6%9C%AC/",
            "url": "https://x-17.top/2022/09/11/LeetCode/857-%E9%9B%87%E4%BD%A3-k-%E5%90%8D%E5%B7%A5%E4%BA%BA%E7%9A%84%E6%9C%80%E4%BD%8E%E6%88%90%E6%9C%AC/",
            "title": "857. 雇佣 K 名工人的最低成本",
            "date_published": "2022-09-11T10:19:46.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/minimum-cost-to-hire-k-workers/\">https://leetcode.cn/problems/minimum-cost-to-hire-k-workers/</a> 有 n 名工人。 给定两个数组 quality 和 wage ，其中，quality[i] 表示第 i 名工人的工作质量，其最低期望工资为 wage[i] 。 现在我们想雇佣 k 名工人组成一个工资组。在雇佣 一组 k 名工人时，我们必须按照下述规则向他们支付工资： 对工资组中的每名工人，应当按其工作质量与同组其他工人的工作质量的比例来支付工资。 工资组中的每名工人至少应当得到他们的最低期望工资。 给定整数 k ，返回 组成满足上述条件的付费群体所需的最小金额 。在实际答案的 10-5 以内的答案将被接受。。 示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入： quality = [10,20,5], wage = [70,50,30], k = 2</span><br><span class=\"line\">输出： 105.00000</span><br><span class=\"line\">解释： 我们向 0 号工人支付 70，向 2 号工人支付 35。</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入： quality = [3,1,10,10,1], wage = [4,8,2,2,7], k = 3</span><br><span class=\"line\">输出： 30.66667</span><br><span class=\"line\">解释： 我们向 0 号工人支付 4，向 2 号和 3 号分别支付 13.33333。</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>n == quality.length == wage.length</li>\n<li>\\(1 &lt;= k &lt;= n &lt;= 10^4\\)</li>\n<li>\\(1 &lt;= quality[i], wage[i] &lt;= 10^4\\)</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    double mincostToHireWorkers(vector&lt;int&gt;&amp; quality, vector&lt;int&gt;&amp; wage, int k) &#123;</span><br><span class=\"line\">        int n = quality.size();</span><br><span class=\"line\">        vector&lt;int&gt; h(n, 0);</span><br><span class=\"line\">        iota(h.begin(), h.end(), 0);</span><br><span class=\"line\">        sort(h.begin(), h.end(), [&amp;](int&amp; a, int&amp; b) &#123;</span><br><span class=\"line\">            return quality[a] * wage[b] &gt; quality[b] * wage[a];</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        double res = 1e9;</span><br><span class=\"line\">        double totalq = 0.0;</span><br><span class=\"line\">        priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; q;</span><br><span class=\"line\">        for (int i = 0; i &lt; k - 1; i++) &#123;</span><br><span class=\"line\">            totalq += quality[h[i]];</span><br><span class=\"line\">            q.push(quality[h[i]]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        for (int i = k - 1; i &lt; n; i++) &#123;</span><br><span class=\"line\">            int idx = h[i];</span><br><span class=\"line\">            totalq += quality[idx];</span><br><span class=\"line\">            q.push(quality[idx]);</span><br><span class=\"line\">            double totalc = ((double) wage[idx] / quality[idx]) * totalq;</span><br><span class=\"line\">            res = min(res, totalc);</span><br><span class=\"line\">            totalq -= q.top();</span><br><span class=\"line\">            q.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度\\(O(nlogn)\\)</li>\n<li>空间复杂度\\(O(n)\\)</li>\n</ul>\n",
            "tags": [
                "Hard",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/09/10/LeetCode/669-%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/",
            "url": "https://x-17.top/2022/09/10/LeetCode/669-%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/",
            "title": "669. 修剪二叉搜索树",
            "date_published": "2022-09-10T10:58:44.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/trim-a-binary-search-tree/\">https://leetcode.cn/problems/trim-a-binary-search-tree/</a> 给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 不应该 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 唯一的答案 。 所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。 示例 1： <img src=\"https://assets.leetcode.com/uploads/2020/09/09/trim1.jpg\" alt=\"\"> 输入：root = [1,0,2], low = 1, high = 2 输出：[1,null,2] 示例 2： <img src=\"https://assets.leetcode.com/uploads/2020/09/09/trim2.jpg\" alt=\"\"> 输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3 输出：[3,2,null,1] 提示：</p>\n<ul>\n<li>树中节点数在范围 [1, 104] 内</li>\n<li>0 &lt;= Node.val &lt;= 104</li>\n<li>树中每个节点的值都是 唯一 的</li>\n<li>题目数据保证输入是一棵有效的二叉搜索树</li>\n<li>0 &lt;= low &lt;= high &lt;= 104</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    TreeNode* trimBST(TreeNode* root, int low, int high) &#123;</span><br><span class=\"line\">        if (root == nullptr) &#123;</span><br><span class=\"line\">            return nullptr;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (root-&gt;val &lt; low) &#123; </span><br><span class=\"line\">            return trimBST(root-&gt;right, low, high);</span><br><span class=\"line\">        &#125; else if (root-&gt;val &gt; high) &#123;</span><br><span class=\"line\">            return trimBST(root-&gt;left, low, high);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            root-&gt;left = trimBST(root-&gt;left, low, high);</span><br><span class=\"line\">            root-&gt;right = trimBST(root-&gt;right, low, high);</span><br><span class=\"line\">            return root;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度\\(O(n)\\)</li>\n<li>空间复杂度\\(O(n)\\)</li>\n</ul>\n",
            "tags": [
                "Medium",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/09/09/LeetCode/1598-%E6%96%87%E4%BB%B6%E5%A4%B9%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97%E6%90%9C%E9%9B%86%E5%99%A8/",
            "url": "https://x-17.top/2022/09/09/LeetCode/1598-%E6%96%87%E4%BB%B6%E5%A4%B9%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97%E6%90%9C%E9%9B%86%E5%99%A8/",
            "title": "1598. 文件夹操作日志搜集器",
            "date_published": "2022-09-09T01:19:19.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/crawler-log-folder/\">https://leetcode.cn/problems/crawler-log-folder/</a> 每当用户执行变更文件夹操作时，LeetCode 文件系统都会保存一条日志记录。 下面给出对变更操作的说明： “../“ ：移动到当前文件夹的父文件夹。如果已经在主文件夹下，则 继续停留在当前文件夹 。 “./“ ：继续停留在当前文件夹。 “x/“ ：移动到名为 x 的子文件夹中。题目数据 保证总是存在文件夹 x 。 给你一个字符串列表 logs ，其中 logs[i] 是用户在 ith 步执行的操作。 文件系统启动时位于主文件夹，然后执行 logs 中的操作。 执行完所有变更文件夹操作后，请你找出 返回主文件夹所需的最小步数 。 示例 1： <img src=\"https://x-17.top/wp-content/uploads/2022/09/sample_11_1957-300x58.png\" alt=\"\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：logs = [&quot;d1/&quot;,&quot;d2/&quot;,&quot;../&quot;,&quot;d21/&quot;,&quot;./&quot;]</span><br><span class=\"line\">输出：2</span><br><span class=\"line\">解释：执行 &quot;../&quot; 操作变更文件夹 2 次，即可回到主文件夹</span><br></pre></td></tr></table></figure>\n<p>示例 2： <img src=\"https://x-17.top/wp-content/uploads/2022/09/sample_22_1957-300x128.png\" alt=\"\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：logs = [&quot;d1/&quot;,&quot;d2/&quot;,&quot;./&quot;,&quot;d3/&quot;,&quot;../&quot;,&quot;d31/&quot;]</span><br><span class=\"line\">输出：3</span><br></pre></td></tr></table></figure>\n<p>示例 3：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：logs = [&quot;d1/&quot;,&quot;../&quot;,&quot;../&quot;,&quot;../&quot;]</span><br><span class=\"line\">输出：0</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>1 &lt;= logs.length &lt;= 103</li>\n<li>2 &lt;= logs[i].length &lt;= 10</li>\n<li>logs[i] 包含小写英文字母，数字，’.’ 和 ‘/‘</li>\n<li>logs[i] 符合语句中描述的格式</li>\n<li>文件夹名称由小写英文字母和数字组成</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>遍历比较字符串是否为”../“和”./“，不是则记录值加一，是”../“且记录值不为0则记录值减一。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int minOperations(vector&lt;string&gt;&amp; logs) &#123;</span><br><span class=\"line\">        string s1=&quot;./&quot;,s2=&quot;../&quot;;</span><br><span class=\"line\">        int ans=0;</span><br><span class=\"line\">        for(int i=0;i&lt;logs.size();i++)&#123;</span><br><span class=\"line\">            if(logs[i]==s2)&#123;</span><br><span class=\"line\">                if(ans) ans--;</span><br><span class=\"line\">            &#125;else if(logs[i]!=s1)&#123;</span><br><span class=\"line\">                ans++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度\\(O(n)\\)</li>\n<li>空间复杂度\\(O(1)\\)</li>\n</ul>\n",
            "tags": [
                "Easy",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/09/08/LeetCode/667-%E4%BC%98%E7%BE%8E%E7%9A%84%E6%8E%92%E5%88%97-ii/",
            "url": "https://x-17.top/2022/09/08/LeetCode/667-%E4%BC%98%E7%BE%8E%E7%9A%84%E6%8E%92%E5%88%97-ii/",
            "title": "667. 优美的排列 II",
            "date_published": "2022-09-08T08:32:21.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/beautiful-arrangement-ii/\">https://leetcode.cn/problems/beautiful-arrangement-ii/</a> 给你两个整数 n 和 k ，请你构造一个答案列表 answer ，该列表应当包含从 1 到 n 的 n 个不同正整数，并同时满足下述条件： 假设该列表是 answer = [a1, a2, a3, … , an] ，那么列表 [a1 - a2, a2 - a3, a3 - a4, … , an-1 - an] 中应该有且仅有 k 个不同整数。 返回列表 answer 。如果存在多种答案，只需返回其中 任意一种 。 示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：n = 3, k = 1</span><br><span class=\"line\">输出：[1, 2, 3]</span><br><span class=\"line\">解释：[1, 2, 3] 包含 3 个范围在 1-3 的不同整数，并且 [1, 1] 中有且仅有 1 个不同整数：1</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：n = 3, k = 2</span><br><span class=\"line\">输出：[1, 3, 2]</span><br><span class=\"line\">解释：[1, 3, 2] 包含 3 个范围在 1-3 的不同整数，并且 [2, 1] 中有且仅有 2 个不同整数：1 和 2</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>\\(1 &lt;= k &lt; n &lt;= 10^4\\)</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>思维题</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    vector&lt;int&gt; constructArray(int n, int k) &#123;</span><br><span class=\"line\">        vector&lt;int&gt; answer;</span><br><span class=\"line\">        for (int i = 1; i &lt; n - k; ++i) &#123;</span><br><span class=\"line\">            answer.push_back(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        for (int i = n - k, j = n; i &lt;= j; ++i, --j) &#123;</span><br><span class=\"line\">            answer.push_back(i);</span><br><span class=\"line\">            if (i != j) &#123;</span><br><span class=\"line\">                answer.push_back(j);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return answer;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度\\(O(n)\\)</li>\n<li>空间复杂度\\(O(1)\\)</li>\n</ul>\n",
            "tags": [
                "Medium",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/09/07/LeetCode/1592-%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E5%8D%95%E8%AF%8D%E9%97%B4%E7%9A%84%E7%A9%BA%E6%A0%BC/",
            "url": "https://x-17.top/2022/09/07/LeetCode/1592-%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E5%8D%95%E8%AF%8D%E9%97%B4%E7%9A%84%E7%A9%BA%E6%A0%BC/",
            "title": "1592. 重新排列单词间的空格",
            "date_published": "2022-09-07T09:04:47.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/rearrange-spaces-between-words/\">https://leetcode.cn/problems/rearrange-spaces-between-words/</a> 给你一个字符串 text ，该字符串由若干被空格包围的单词组成。每个单词由一个或者多个小写英文字母组成，并且两个单词之间至少存在一个空格。题目测试用例保证 text 至少包含一个单词 。 请你重新排列空格，使每对相邻单词之间的空格数目都 相等 ，并尽可能 最大化 该数目。如果不能重新平均分配所有空格，请 将多余的空格放置在字符串末尾 ，这也意味着返回的字符串应当与原 text 字符串的长度相等。 返回 重新排列空格后的字符串 。 示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：text = &quot; this is a sentence &quot;</span><br><span class=\"line\">输出：&quot;this is a sentence&quot;</span><br><span class=\"line\">解释：总共有 9 个空格和 4 个单词。可以将 9 个空格平均分配到相邻单词之间，相邻单词间空格数为：9 / (4-1) = 3 个。</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：text = &quot; practice makes perfect&quot;</span><br><span class=\"line\">输出：&quot;practice makes perfect &quot;</span><br><span class=\"line\">解释：总共有 7 个空格和 3 个单词。7 / (3-1) = 3 个空格加上 1 个多余的空格。多余的空格需要放在字符串的末尾。</span><br></pre></td></tr></table></figure>\n<p>示例 3：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：text = &quot;hello world&quot;</span><br><span class=\"line\">输出：&quot;hello world&quot;</span><br></pre></td></tr></table></figure>\n<p>示例 4：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：text = &quot; walks udp package into bar a&quot;</span><br><span class=\"line\">输出：&quot;walks udp package into bar a &quot;</span><br></pre></td></tr></table></figure>\n<p>示例 5：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：text = &quot;a&quot;</span><br><span class=\"line\">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>1 &lt;= text.length &lt;= 100</li>\n<li>text 由小写英文字母和 ‘ ‘ 组成</li>\n<li>text 中至少包含一个单词</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>模拟</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    string reorderSpaces(string text) &#123;</span><br><span class=\"line\">        list&lt;char&gt; a;</span><br><span class=\"line\">        vector&lt;string&gt; b;</span><br><span class=\"line\">        int ans=0;</span><br><span class=\"line\">        for(int i=0;i&lt;text.length();i++)&#123;</span><br><span class=\"line\">            if(text[i]==&#x27; &#x27;)&#123;</span><br><span class=\"line\">                ans++;</span><br><span class=\"line\">                string s;</span><br><span class=\"line\">                while(!a.empty())&#123;</span><br><span class=\"line\">                    s+=a.front();</span><br><span class=\"line\">                    a.pop_front();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if(!s.empty())&#123;</span><br><span class=\"line\">                    b.push_back(s);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else</span><br><span class=\"line\">                a.push_back(text[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        string s1;</span><br><span class=\"line\">        while(!a.empty())&#123;</span><br><span class=\"line\">            s1+=a.front();</span><br><span class=\"line\">            a.pop_front();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if(!s1.empty())&#123;</span><br><span class=\"line\">            b.push_back(s1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        int n=b.size()-1;</span><br><span class=\"line\">        string s=&quot;&quot;;</span><br><span class=\"line\">        s+=b[0];</span><br><span class=\"line\">        if(n==0)&#123;</span><br><span class=\"line\">            for(int i=0;i&lt;ans;i++)&#123;</span><br><span class=\"line\">                s+=&#x27; &#x27;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            for(int i=1;i&lt;b.size();i++)&#123;</span><br><span class=\"line\">                for(int j=0;j&lt;ans/n;j++)&#123;</span><br><span class=\"line\">                    s+=&#x27; &#x27;;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                s+=b[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            for(int i=0;i&lt;ans%n;i++)&#123;</span><br><span class=\"line\">                s+=&#x27; &#x27;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return s;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度\\(O(n)\\)</li>\n<li>空间复杂度\\(O(n)\\)</li>\n</ul>\n",
            "tags": [
                "Easy",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/09/06/LeetCode/828-%E7%BB%9F%E8%AE%A1%E5%AD%90%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6/",
            "url": "https://x-17.top/2022/09/06/LeetCode/828-%E7%BB%9F%E8%AE%A1%E5%AD%90%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6/",
            "title": "828. 统计子串中的唯一字符",
            "date_published": "2022-09-06T07:47:08.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/\">https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/</a> 我们定义了一个函数 countUniqueChars(s) 来统计字符串 s 中的唯一字符，并返回唯一字符的个数。 例如：s = “LEETCODE” ，则其中 “L”, “T”,”C”,”O”,”D” 都是唯一字符，因为它们只出现一次，所以 countUniqueChars(s) = 5 。 本题将会给你一个字符串 s ，我们需要返回 countUniqueChars(t) 的总和，其中 t 是 s 的子字符串。输入用例保证返回值为 32 位整数。 注意，某些子字符串可能是重复的，但你统计时也必须算上这些重复的子字符串（也就是说，你必须统计 s 的所有子字符串中的唯一字符）。 示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: s = &quot;ABC&quot;</span><br><span class=\"line\">输出: 10</span><br><span class=\"line\">解释: 所有可能的子串为：&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;AB&quot;,&quot;BC&quot; 和 &quot;ABC&quot;。</span><br><span class=\"line\">其中，每一个子串都由独特字符构成。</span><br><span class=\"line\">所以其长度总和为：1 + 1 + 1 + 2 + 2 + 3 = 10</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: s = &quot;ABA&quot;</span><br><span class=\"line\">输出: 8</span><br><span class=\"line\">解释: 除了 countUniqueChars(&quot;ABA&quot;) = 1 之外，其余与示例 1 相同。</span><br></pre></td></tr></table></figure>\n<p>示例 3：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;LEETCODE&quot;</span><br><span class=\"line\">输出：92</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>1 &lt;= s.length &lt;= 10^5</li>\n<li>s 只包含大写英文字符</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>题意是求出给定字符串的全部子串中唯一字符的个数，因此只需要计算每个字符能在多少个子串中成为唯一字符，即一个字符分别在第i,j,k位出现的话，就应该有\\((j-i)*(k-j)\\)个字符串中位于j位的该字符是唯一字符。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int uniqueLetterString(string s) &#123;</span><br><span class=\"line\">        map&lt;char,vector&lt;int&gt;&gt; a;</span><br><span class=\"line\">        for(int i=0;i&lt;s.length();i++)&#123;</span><br><span class=\"line\">            a[s[i]].push_back(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        int ans=0;</span><br><span class=\"line\">        for(auto it=a.begin();it!=a.end();it++)&#123;</span><br><span class=\"line\">            vector&lt;int&gt; b;</span><br><span class=\"line\">            b.push_back(-1);</span><br><span class=\"line\">            for(int i=0;i&lt;it-&gt;second.size();i++)&#123;</span><br><span class=\"line\">                b.push_back(it-&gt;second[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            b.push_back(s.length());</span><br><span class=\"line\">            for(int i=1;i&lt;b.size()-1;i++)&#123;</span><br><span class=\"line\">                ans+=(b[i]-b[i-1])*(b[i+1]-b[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度\\(O(n)\\)</li>\n<li>空间复杂度\\(O(n)\\)</li>\n</ul>\n",
            "tags": [
                "Hard",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/09/04/LeetCode/1582-%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E4%BD%8D%E7%BD%AE/",
            "url": "https://x-17.top/2022/09/04/LeetCode/1582-%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E4%BD%8D%E7%BD%AE/",
            "title": "1582. 二进制矩阵中的特殊位置",
            "date_published": "2022-09-04T04:19:09.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/special-positions-in-a-binary-matrix/\">https://leetcode.cn/problems/special-positions-in-a-binary-matrix/</a> 给你一个大小为 rows x cols 的矩阵 mat，其中 mat[i][j] 是 0 或 1，请返回 矩阵 mat 中特殊位置的数目 。 特殊位置 定义：如果 mat[i][j] == 1 并且第 i 行和第 j 列中的所有其他元素均为 0（行和列的下标均 从 0 开始 ），则位置 (i, j) 被称为特殊位置。 示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：mat = [[1,0,0],</span><br><span class=\"line\">  [0,0,1],</span><br><span class=\"line\">  [1,0,0]]</span><br><span class=\"line\">输出：1</span><br><span class=\"line\">解释：(1,2) 是一个特殊位置，因为 mat[1][2] == 1 且所处的行和列上所有其他元素都是 0</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：mat = [[1,0,0],</span><br><span class=\"line\">  [0,1,0],</span><br><span class=\"line\">  [0,0,1]]</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：(0,0), (1,1) 和 (2,2) 都是特殊位置</span><br></pre></td></tr></table></figure>\n<p>示例 3：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：mat = [[0,0,0,1],</span><br><span class=\"line\">  [1,0,0,0],</span><br><span class=\"line\">  [0,1,1,0],</span><br><span class=\"line\">  [0,0,0,0]]</span><br><span class=\"line\">输出：2</span><br></pre></td></tr></table></figure>\n<p>示例 4：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：mat = [[0,0,0,0,0],</span><br><span class=\"line\">  [1,0,0,0,0],</span><br><span class=\"line\">  [0,1,0,0,0],</span><br><span class=\"line\">  [0,0,1,0,0],</span><br><span class=\"line\">  [0,0,0,1,1]]</span><br><span class=\"line\">输出：3</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>rows == mat.length</li>\n<li>cols == mat[i].length</li>\n<li>1 &lt;= rows, cols &lt;= 100</li>\n<li>mat[i][j] 是 0 或 1</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>模拟即可</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int numSpecial(vector&lt;vector&lt;int&gt;&gt;&amp; mat) &#123;</span><br><span class=\"line\">        vector&lt;int&gt; h;</span><br><span class=\"line\">        vector&lt;int&gt; s;</span><br><span class=\"line\">        for(int i=0;i&lt;mat.size();i++)&#123;</span><br><span class=\"line\">            int num=0;</span><br><span class=\"line\">            for(int j=0;j&lt;mat[i].size();j++)&#123;</span><br><span class=\"line\">                num+=mat[i][j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            h.push_back(num);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        for(int i=0;i&lt;mat[0].size();i++)&#123;</span><br><span class=\"line\">            int num=0;</span><br><span class=\"line\">            for(int j=0;j&lt;mat.size();j++)&#123;</span><br><span class=\"line\">                num+=mat[j][i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            s.push_back(num);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        int ans=0;</span><br><span class=\"line\">        for(int i=0;i&lt;h.size();i++)&#123;</span><br><span class=\"line\">            for(int j=0;j&lt;s.size();j++)&#123;</span><br><span class=\"line\">                if(h[i]==1&amp;&amp;s[j]==1&amp;&amp;mat[i][j]==1)&#123;</span><br><span class=\"line\">                    ans++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度\\(O(m*n)\\)</li>\n<li>空间复杂度\\(O(m+n)\\)</li>\n</ul>\n",
            "tags": [
                "Easy",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/09/02/LeetCode/687-%E6%9C%80%E9%95%BF%E5%90%8C%E5%80%BC%E8%B7%AF%E5%BE%84/",
            "url": "https://x-17.top/2022/09/02/LeetCode/687-%E6%9C%80%E9%95%BF%E5%90%8C%E5%80%BC%E8%B7%AF%E5%BE%84/",
            "title": "687. 最长同值路径",
            "date_published": "2022-09-02T11:08:40.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/longest-univalue-path/\">https://leetcode.cn/problems/longest-univalue-path/</a> 给定一个二叉树的 root ，返回 最长的路径的长度 ，这个路径中的 每个节点具有相同值 。 这条路径可以经过也可以不经过根节点。 两个节点之间的路径长度 由它们之间的边数表示。 示例 1: <img src=\"https://assets.leetcode.com/uploads/2020/10/13/ex1.jpg\" alt=\"\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [5,4,5,1,1,5]</span><br><span class=\"line\">输出：2</span><br></pre></td></tr></table></figure>\n<p>示例 2: <img src=\"https://assets.leetcode.com/uploads/2020/10/13/ex2.jpg\" alt=\"\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [1,4,5,4,4,5]</span><br><span class=\"line\">输出：2</span><br></pre></td></tr></table></figure>\n<p>提示:</p>\n<ul>\n<li>树的节点数的范围是 [0, 104]</li>\n<li>-1000 &lt;= Node.val &lt;= 1000</li>\n<li>树的深度将不超过 1000</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>利用深搜递归获得经过某个父节点得到的最长规定路径，从而得到全局最长规定路径</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for a binary tree node.</span><br><span class=\"line\"> * struct TreeNode &#123;</span><br><span class=\"line\"> *     int val;</span><br><span class=\"line\"> *     TreeNode *left;</span><br><span class=\"line\"> *     TreeNode *right;</span><br><span class=\"line\"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class=\"line\"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class=\"line\"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class=\"line\"> * &#125;;</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    int ans;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int longestUnivaluePath(TreeNode* root) &#123;</span><br><span class=\"line\">        ans=0;</span><br><span class=\"line\">        dfs(root);</span><br><span class=\"line\">        return ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    int dfs(TreeNode* root)&#123;</span><br><span class=\"line\">        if(!root)&#123;</span><br><span class=\"line\">            return 0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        int left=dfs(root-&gt;left);</span><br><span class=\"line\">        int right=dfs(root-&gt;right);</span><br><span class=\"line\">        if(root&amp;&amp;root-&gt;left&amp;&amp;root-&gt;val==root-&gt;left-&gt;val)&#123;</span><br><span class=\"line\">            left++;</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            left=0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if(root&amp;&amp;root-&gt;right&amp;&amp;root-&gt;val==root-&gt;right-&gt;val)&#123;</span><br><span class=\"line\">            right++;</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            right=0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans=max(ans,right+left);</span><br><span class=\"line\">        return max(right,left);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度\\(O(n)\\)</li>\n<li>空间复杂度\\(O(n)\\)</li>\n</ul>\n",
            "tags": [
                "Medium",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/09/01/LeetCode/1475-%E5%95%86%E5%93%81%E6%8A%98%E6%89%A3%E5%90%8E%E7%9A%84%E6%9C%80%E7%BB%88%E4%BB%B7%E6%A0%BC/",
            "url": "https://x-17.top/2022/09/01/LeetCode/1475-%E5%95%86%E5%93%81%E6%8A%98%E6%89%A3%E5%90%8E%E7%9A%84%E6%9C%80%E7%BB%88%E4%BB%B7%E6%A0%BC/",
            "title": "1475. 商品折扣后的最终价格",
            "date_published": "2022-09-01T09:05:37.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/final-prices-with-a-special-discount-in-a-shop/\">https://leetcode.cn/problems/final-prices-with-a-special-discount-in-a-shop/</a> 给你一个数组 prices ，其中 prices[i] 是商店里第 i 件商品的价格。 商店里正在进行促销活动，如果你要买第 i 件商品，那么你可以得到与 prices[j] 相等的折扣，其中 j 是满足 j &gt; i 且 prices[j] &lt;= prices[i] 的 最小下标 ，如果没有满足条件的 j ，你将没有任何折扣。 请你返回一个数组，数组中第 i 个元素是折扣后你购买商品 i 最终需要支付的价格。 示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：prices = [8,4,6,2,3]</span><br><span class=\"line\">输出：[4,2,4,2,3]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">商品 0 的价格为 price[0]=8 ，你将得到 prices[1]=4 的折扣，所以最终价格为 8 - 4 = 4 。</span><br><span class=\"line\">商品 1 的价格为 price[1]=4 ，你将得到 prices[3]=2 的折扣，所以最终价格为 4 - 2 = 2 。</span><br><span class=\"line\">商品 2 的价格为 price[2]=6 ，你将得到 prices[3]=2 的折扣，所以最终价格为 6 - 2 = 4 。</span><br><span class=\"line\">商品 3 和 4 都没有折扣。</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：prices = [1,2,3,4,5]</span><br><span class=\"line\">输出：[1,2,3,4,5]</span><br><span class=\"line\">解释：在这个例子中，所有商品都没有折扣。</span><br></pre></td></tr></table></figure>\n<p>示例 3：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：prices = [10,1,1,6]</span><br><span class=\"line\">输出：[9,0,1,6]</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>1 &lt;= prices.length &lt;= 500</li>\n<li>1 &lt;= prices[i] &lt;= 10^3</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>按题意直接遍历即可</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    vector finalPrices(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class=\"line\">        vector a;</span><br><span class=\"line\">        for(int i=0;i&lt;prices.size()-1;i++)&#123;</span><br><span class=\"line\">            int flag=1;</span><br><span class=\"line\">            for(int j=i+1;j&lt;prices.size();j++)&#123; </span><br><span class=\"line\">                if(prices[i]&gt;=prices[j])&#123;</span><br><span class=\"line\">                    a.push_back(prices[i]-prices[j]);</span><br><span class=\"line\">                    flag=0;</span><br><span class=\"line\">                    break;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if(flag)&#123;</span><br><span class=\"line\">                a.push_back(prices[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        a.push_back(prices[prices.size()-1]);</span><br><span class=\"line\">        return a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度\\(O(n^2)\\)</li>\n<li>空间复杂度\\(O(1)\\)</li>\n</ul>\n",
            "tags": [
                "Easy",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/08/31/LeetCode/946-%E9%AA%8C%E8%AF%81%E6%A0%88%E5%BA%8F%E5%88%97/",
            "url": "https://x-17.top/2022/08/31/LeetCode/946-%E9%AA%8C%E8%AF%81%E6%A0%88%E5%BA%8F%E5%88%97/",
            "title": "946. 验证栈序列",
            "date_published": "2022-08-31T04:53:01.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/validate-stack-sequences/\">https://leetcode.cn/problems/validate-stack-sequences/</a> 给定 pushed 和 popped 两个序列，每个序列中的 值都不重复，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 true；否则，返回 false 。 示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">解释：我们可以按以下顺序执行：</span><br><span class=\"line\">push(1), push(2), push(3), push(4), pop() -&gt; 4,</span><br><span class=\"line\">push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]</span><br><span class=\"line\">输出：false</span><br><span class=\"line\">解释：1 不能在 2 之前弹出。</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>1 &lt;= pushed.length &lt;= 1000</li>\n<li>0 &lt;= pushed[i] &lt;= 1000</li>\n<li>pushed 的所有元素 互不相同</li>\n<li>popped.length == pushed.length</li>\n<li>popped 是 pushed 的一个排列</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>栈模拟</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    bool validateStackSequences(vector&lt;int&gt;&amp; pushed, vector&lt;int&gt;&amp; popped) &#123;</span><br><span class=\"line\">        int flag=0;</span><br><span class=\"line\">        stack s;</span><br><span class=\"line\">        for(int i=0;i&lt;pushed.size();i++)&#123;</span><br><span class=\"line\">            s.push(pushed[i]);</span><br><span class=\"line\">            while(s.top()==popped[flag])&#123;</span><br><span class=\"line\">                s.pop();</span><br><span class=\"line\">                flag++;</span><br><span class=\"line\">                if(flag==popped.size())&#123;</span><br><span class=\"line\">                    return true;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if(s.empty())&#123;</span><br><span class=\"line\">                    break;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度：\\(O(n)\\)</li>\n<li>空间复杂度：\\(O(n)\\)</li>\n</ul>\n",
            "tags": [
                "Medium",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/08/30/LeetCode/998-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91-ii/",
            "url": "https://x-17.top/2022/08/30/LeetCode/998-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91-ii/",
            "title": "998. 最大二叉树 II",
            "date_published": "2022-08-30T02:42:42.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/maximum-binary-tree-ii/\">https://leetcode.cn/problems/maximum-binary-tree-ii/</a> 最大树 定义：一棵树，并满足：其中每个节点的值都大于其子树中的任何其他值。 给你最大树的根节点 root 和一个整数 val 。 就像 之前的问题 那样，给定的树是利用 Construct(a) 例程从列表 a（root = Construct(a)）递归地构建的： 如果 a 为空，返回 null 。 否则，令 a[i] 作为 a 的最大元素。创建一个值为 a[i] 的根节点 root 。 root 的左子树将被构建为 Construct([a[0], a[1], …, a[i - 1]]) 。 root 的右子树将被构建为 Construct([a[i + 1], a[i + 2], …, a[a.length - 1]]) 。 返回 root 。 请注意，题目没有直接给出 a ，只是给出一个根节点 root = Construct(a) 。 假设 b 是 a 的副本，并在末尾附加值 val。题目数据保证 b 中的值互不相同。 返回 Construct(b) 。 示例 1： <img src=\"https://x-17.top/wp-content/uploads/2022/08/maximum-binary-tree-1-1.png\" alt=\"\"><img src=\"https://x-17.top/wp-content/uploads/2022/08/maximum-binary-tree-1-2.png\" alt=\"\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [4,1,3,null,null,2], val = 5</span><br><span class=\"line\">输出：[5,4,null,1,3,null,null,2]</span><br><span class=\"line\">解释：a = [1,4,2,3], b = [1,4,2,3,5]</span><br></pre></td></tr></table></figure>\n<p>示例 2： <img src=\"https://x-17.top/wp-content/uploads/2022/08/maximum-binary-tree-2-1.png\" alt=\"\"><img src=\"https://x-17.top/wp-content/uploads/2022/08/maximum-binary-tree-2-2.png\" alt=\"\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [5,2,4,null,1], val = 3</span><br><span class=\"line\">输出：[5,2,4,null,1,null,3]</span><br><span class=\"line\">解释：a = [2,1,5,4], b = [2,1,5,4,3]</span><br></pre></td></tr></table></figure>\n<p>示例 3： <img src=\"https://x-17.top/wp-content/uploads/2022/08/maximum-binary-tree-3-1.png\" alt=\"\"><img src=\"https://x-17.top/wp-content/uploads/2022/08/maximum-binary-tree-3-2.png\" alt=\"\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [5,2,3,null,1], val = 4</span><br><span class=\"line\">输出：[5,2,4,null,1,3]</span><br><span class=\"line\">解释：a = [2,1,5,3], b = [2,1,5,3,4]</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>\\(树中节点数目在范围 [1, 100] 内\\)</li>\n<li>\\(1 &lt;= Node.val &lt;= 100\\)</li>\n<li>\\(树中的所有值 互不相同\\)</li>\n<li>\\(1 &lt;= val &lt;= 100\\)</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>因为val是附加在末尾的，所以根据题意，如果val大于a中所有值，那只需要将整个a作为以val为根节点的左子树即可得到b；否则就在a的右子树中找到小于val的节点值，将值为val的节点插在此处并将该节点及其子树作为val节点的左子树即可。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    TreeNode* insertIntoMaxTree(TreeNode* root, int val) &#123;</span><br><span class=\"line\">        TreeNode* parent = nullptr;</span><br><span class=\"line\">        TreeNode* cur = root;</span><br><span class=\"line\">        while (cur) &#123;</span><br><span class=\"line\">            if (val &gt; cur-&gt;val) &#123;</span><br><span class=\"line\">                if (!parent) &#123;</span><br><span class=\"line\">                    return new TreeNode(val, root, nullptr);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                TreeNode* node = new TreeNode(val, cur, nullptr);</span><br><span class=\"line\">                parent-&gt;right = node;</span><br><span class=\"line\">                return root;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else &#123;</span><br><span class=\"line\">                parent = cur;</span><br><span class=\"line\">                cur = cur-&gt;right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        parent-&gt;right = new TreeNode(val);</span><br><span class=\"line\">        return root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度：\\(O(n)\\)</li>\n<li>空间复杂度：\\(O(1)\\)</li>\n</ul>\n",
            "tags": [
                "Medium",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/08/29/LeetCode/1470-%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E6%95%B0%E7%BB%84/",
            "url": "https://x-17.top/2022/08/29/LeetCode/1470-%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E6%95%B0%E7%BB%84/",
            "title": "1470. 重新排列数组",
            "date_published": "2022-08-29T03:55:49.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/shuffle-the-array/\">https://leetcode.cn/problems/shuffle-the-array/</a> 给你一个数组 nums ，数组中有 2n 个元素，按 [x1,x2,…,xn,y1,y2,…,yn] 的格式排列。 请你将数组按 [x1,y1,x2,y2,…,xn,yn] 格式重新排列，返回重排后的数组。 示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [2,5,1,3,4,7], n = 3</span><br><span class=\"line\">输出：[2,3,5,4,1,7]</span><br><span class=\"line\">解释：由于 x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 ，所以答案为 [2,3,5,4,1,7]</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,2,3,4,4,3,2,1], n = 4</span><br><span class=\"line\">输出：[1,4,2,3,3,2,4,1]</span><br></pre></td></tr></table></figure>\n<p>示例 3：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,1,2,2], n = 2</span><br><span class=\"line\">输出：[1,2,1,2]</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>\\(1 &lt;= n &lt;= 500\\)</li>\n<li>\\(nums.length == 2n\\)</li>\n<li>\\(1 &lt;= nums[i] &lt;= 10^3\\)</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>按题意模拟即可。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    vector shuffle(vector&lt;int&gt;&amp; nums, int n) &#123;</span><br><span class=\"line\">        vector ans;</span><br><span class=\"line\">        for(int i=0;i&lt;n;i++)&#123;</span><br><span class=\"line\">            ans.push_back(nums[i]);</span><br><span class=\"line\">            ans.push_back(nums[i+n]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度：\\(O(n)\\)</li>\n<li>空间复杂度：\\(O(1)\\)</li>\n</ul>\n",
            "tags": [
                "Easy",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/08/28/LeetCode/793-%E9%98%B6%E4%B9%98%E5%87%BD%E6%95%B0%E5%90%8E-k-%E4%B8%AA%E9%9B%B6/",
            "url": "https://x-17.top/2022/08/28/LeetCode/793-%E9%98%B6%E4%B9%98%E5%87%BD%E6%95%B0%E5%90%8E-k-%E4%B8%AA%E9%9B%B6/",
            "title": "793. 阶乘函数后 K 个零",
            "date_published": "2022-08-28T13:46:52.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/preimage-size-of-factorial-zeroes-function/\">https://leetcode.cn/problems/preimage-size-of-factorial-zeroes-function/</a> f(x) 是 x! 末尾是 0 的数量。回想一下 x! = 1 * 2 * 3 * … * x，且 0! = 1 。 例如， f(3) = 0 ，因为 3! = 6 的末尾没有 0 ；而 f(11) = 2 ，因为 11!= 39916800 末端有 2 个 0 。 给定 k，找出返回能满足 f(x) = k 的非负整数 x 的数量。 示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：k = 0</span><br><span class=\"line\">输出：5</span><br><span class=\"line\">解释：0!, 1!, 2!, 3!, 和 4! 均符合 k = 0 的条件。</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：k = 5</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：没有匹配到这样的 x!，符合 k = 5 的条件。</span><br></pre></td></tr></table></figure>\n<p>示例 3:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: k = 3</span><br><span class=\"line\">输出: 5</span><br></pre></td></tr></table></figure>\n<p>提示:</p>\n<ul>\n<li>\\(0 &lt;= k &lt;= 10^9\\)</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>根据题意，只有因子2和5相乘能得到以0为结尾的数。 又因为2出现次数远大于5，因此只需求5为因子出现的次数（25及类似的要记多次），也可分析出所求其实只有0和5两种结果。（官方代码）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int zeta(long x) &#123;</span><br><span class=\"line\">        int res = 0;</span><br><span class=\"line\">        while (x) &#123;</span><br><span class=\"line\">            res += x / 5;</span><br><span class=\"line\">            x /= 5;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    long long help(int k) &#123;</span><br><span class=\"line\">        long long r = 5LL * k;</span><br><span class=\"line\">        long long l = 0;</span><br><span class=\"line\">        while (l &lt;= r) &#123;</span><br><span class=\"line\">            long long mid = (l + r) / 2;</span><br><span class=\"line\">            if (zeta(mid) &lt; k) &#123;</span><br><span class=\"line\">                l = mid + 1;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                r = mid - 1;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return r + 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    int preimageSizeFZF(int k) &#123;</span><br><span class=\"line\">        return help(k + 1) - help(k);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度：\\(O(log^2k)\\)</li>\n<li>空间复杂度：\\(O(1)\\)</li>\n</ul>\n",
            "tags": [
                "Hard",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/08/27/LeetCode/662-%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6/",
            "url": "https://x-17.top/2022/08/27/LeetCode/662-%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6/",
            "title": "662. 二叉树最大宽度",
            "date_published": "2022-08-27T04:07:20.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/maximum-width-of-binary-tree/\">https://leetcode.cn/problems/maximum-width-of-binary-tree/</a> 给你一棵二叉树的根节点 root ，返回树的 最大宽度 。 树的 最大宽度 是所有层中最大的 宽度 。 每一层的 宽度 被定义为该层最左和最右的非空节点（即，两个端点）之间的长度。将这个二叉树视作与满二叉树结构相同，两端点间会出现一些延伸到这一层的 null 节点，这些 null 节点也计入长度。 题目数据保证答案将会在  32 位 带符号整数范围内。 示例 1： <img src=\"https://assets.leetcode.com/uploads/2021/05/03/width1-tree.jpg\" alt=\"\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [1,3,2,5,3,null,9]</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：最大宽度出现在树的第 3 层，宽度为 4 (5,3,null,9) 。</span><br></pre></td></tr></table></figure>\n<p>示例 2： <img src=\"https://assets.leetcode.com/uploads/2022/03/14/maximum-width-of-binary-tree-v3.jpg\" alt=\"\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [1,3,2,5,null,null,9,6,null,7]</span><br><span class=\"line\">输出：7</span><br><span class=\"line\">解释：最大宽度出现在树的第 4 层，宽度为 7 (6,null,null,null,null,null,7) 。</span><br></pre></td></tr></table></figure>\n<p>示例 3： <img src=\"https://assets.leetcode.com/uploads/2021/05/03/width3-tree.jpg\" alt=\"\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [1,3,2,5]</span><br><span class=\"line\">输出：2</span><br><span class=\"line\">解释：最大宽度出现在树的第 2 层，宽度为 2 (3,2) 。</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>\\(树中节点的数目范围是 [1, 3000]\\)</li>\n<li>\\(-100&lt;=Node.val&lt;=100\\)</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>解法一：广度优先遍历（官方题解）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int widthOfBinaryTree(TreeNode* root) &#123;</span><br><span class=\"line\">        unsigned long long res = 1;</span><br><span class=\"line\">        vector&lt;pair&gt; arr;</span><br><span class=\"line\">        arr.emplace_back(root, 1L);</span><br><span class=\"line\">        while (!arr.empty()) &#123;</span><br><span class=\"line\">            vector&lt;pair&gt; tmp;</span><br><span class=\"line\">            for (auto &amp;[node, index] : arr) &#123;</span><br><span class=\"line\">                if (node-&gt;left) &#123;</span><br><span class=\"line\">                    tmp.emplace_back(node-&gt;left, index * 2);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if (node-&gt;right) &#123;</span><br><span class=\"line\">                    tmp.emplace_back(node-&gt;right, index * 2 + 1);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res = max(res, arr.back().second - arr[0].second + 1);</span><br><span class=\"line\">            arr = move(tmp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度：\\(O(n)\\)</li>\n<li>空间复杂度：\\(O(n)\\)</li>\n</ul>\n<p>解法二：深度优先遍历（官方题解）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">using ULL = unsigned long long;</span><br><span class=\"line\"></span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int widthOfBinaryTree(TreeNode* root) &#123;</span><br><span class=\"line\">        unordered_map&lt;int, ULL&gt; levelMin;</span><br><span class=\"line\">        function&lt;ULL(TreeNode*, int, ULL)&gt; dfs = [&amp;](TreeNode* node, int depth, ULL index)-&gt;ULL &#123;</span><br><span class=\"line\">            if (node == nullptr) &#123;</span><br><span class=\"line\">                return 0LL;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (!levelMin.count(depth)) &#123;</span><br><span class=\"line\">                levelMin[depth] = index; // 每一层最先访问到的节点会是最左边的节点，即每一层编号的最小值</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return max(&#123;index - levelMin[depth] + 1LL, dfs(node-&gt;left, depth + 1, index * 2), dfs(node-&gt;right, depth + 1, index * 2 + 1)&#125;);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        return dfs(root, 1, 1LL);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度：\\(O(n)\\)</li>\n<li>空间复杂度：\\(O(n)\\)</li>\n</ul>\n",
            "tags": [
                "Medium",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/08/26/LeetCode/1464-%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%A4%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/",
            "url": "https://x-17.top/2022/08/26/LeetCode/1464-%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%A4%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/",
            "title": "1464. 数组中两元素的最大乘积",
            "date_published": "2022-08-26T04:23:17.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/maximum-product-of-two-elements-in-an-array/\">https://leetcode.cn/problems/maximum-product-of-two-elements-in-an-array/</a> 给你一个整数数组 nums，请你选择数组的两个不同下标 i 和 j，使 (nums[i]-1)*(nums[j]-1) 取得最大值。 请你计算并返回该式的最大值。 示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [3,4,5,2]</span><br><span class=\"line\">输出：12 </span><br><span class=\"line\">解释：如果选择下标 i=1 和 j=2（下标从 0 开始），则可以获得最大值，(nums[1]-1)*(nums[2]-1) = (4-1)*(5-1) = 3*4 = 12 。</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,5,4,5]</span><br><span class=\"line\">输出：16</span><br><span class=\"line\">解释：选择下标 i=1 和 j=3（下标从 0 开始），则可以获得最大值 (5-1)*(5-1) = 16 。</span><br></pre></td></tr></table></figure>\n<p>示例 3：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [3,7]</span><br><span class=\"line\">输出：12</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">2 &lt;= nums.length &lt;= 500</span><br><span class=\"line\">1 &lt;= nums[i] &lt;= 10^3</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>解法一：数据最多是500，而暴力求解时间复杂度是\\(O(n^2)\\),显然可以通过。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int maxProduct(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class=\"line\">        int ans=0;</span><br><span class=\"line\">        for(int i=0;i&lt;nums.size()-1;i++)&#123;</span><br><span class=\"line\">            for(int j=i+1;j&lt;nums.size();j++)&#123;</span><br><span class=\"line\">                ans=max(ans,(nums[i]-1)*(nums[j]-1));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度：\\(O(n^2)\\)</li>\n<li>空间复杂度：\\(O(1)\\)</li>\n</ul>\n<p>解法二：根据题意我们只需要找出最大值和次大值即可，所以可以排序实现。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int maxProduct(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class=\"line\">        sort(nums.begin(),nums.end());</span><br><span class=\"line\">        return (nums[nums.size()-1]-1)*(nums[nums.size()-2]-1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度：\\(O(nlogn)\\)</li>\n<li>空间复杂度：\\(O(1)\\)</li>\n</ul>\n<p>解法三：一次遍历维护最大值和次大值即可。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int maxProduct(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class=\"line\">        int a=max(nums[0],nums[1]),b=min(nums[0],nums[1]);</span><br><span class=\"line\">        for(int i=2;i&lt;nums.size();i++)&#123;</span><br><span class=\"line\">            int c=a;</span><br><span class=\"line\">            a=max(a,nums[i]);</span><br><span class=\"line\">            if(a==nums[i])&#123;</span><br><span class=\"line\">                b=max(c,b);</span><br><span class=\"line\">            &#125;else&#123;</span><br><span class=\"line\">                b=max(b,nums[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return (a-1)*(b-1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度：\\(O(n)\\)</li>\n<li>空间复杂度：\\(O(1)\\)</li>\n</ul>\n",
            "tags": [
                "Easy",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/08/25/LeetCode/658-%E6%89%BE%E5%88%B0-k-%E4%B8%AA%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E5%85%83%E7%B4%A0/",
            "url": "https://x-17.top/2022/08/25/LeetCode/658-%E6%89%BE%E5%88%B0-k-%E4%B8%AA%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E5%85%83%E7%B4%A0/",
            "title": "658. 找到 K 个最接近的元素",
            "date_published": "2022-08-25T03:36:02.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/find-k-closest-elements/\">https://leetcode.cn/problems/find-k-closest-elements/</a> 给定一个 排序好 的数组 arr ，两个整数 k 和 x ，从数组中找到最靠近 x（两数之差最小）的 k 个数。返回的结果必须要是按升序排好的。 整数 a 比整数 b 更接近 x 需要满足： a - x &lt; b - x 或者 a - x == b - x 且 a &lt; b 示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：arr = [1,2,3,4,5], k = 4, x = 3</span><br><span class=\"line\">输出：[1,2,3,4]</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：arr = [1,2,3,4,5], k = 4, x = -1</span><br><span class=\"line\">输出：[1,2,3,4]</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1 &lt;= k &lt;= arr.length</span><br><span class=\"line\">1 &lt;= arr.length &lt;= 104</span><br><span class=\"line\">arr 按 升序 排列</span><br><span class=\"line\">-104 &lt;= arr[i], x &lt;= 104</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>解法一：按照题意进行排序，返回前k个，官方解法写的确实短。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    vector findClosestElements(vector&lt;int&gt;&amp; arr, int k, int x) &#123;</span><br><span class=\"line\">        sort(arr.begin(), arr.end(), [x](int a, int b) -&gt; bool &#123;</span><br><span class=\"line\">            return abs(a - x) &lt; abs(b - x)  abs(a - x) == abs(b - x) &amp;&amp; a &lt; b;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        sort(arr.begin(), arr.begin() + k);</span><br><span class=\"line\">        return vector(arr.begin(), arr.begin() + k);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>解法二：二分加双指针，依旧是简短的官方代码。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    vector findClosestElements(vector&lt;int&gt;&amp; arr, int k, int x) &#123;</span><br><span class=\"line\">        int right = lower_bound(arr.begin(), arr.end(), x) - arr.begin();</span><br><span class=\"line\">        int left = right - 1;</span><br><span class=\"line\">        while (k--) &#123;</span><br><span class=\"line\">            if (left &lt; 0) &#123; right++; &#125; else if (right &gt;= arr.size()) &#123;</span><br><span class=\"line\">                left--;</span><br><span class=\"line\">            &#125; else if (x - arr[left] &lt;= arr[right] - x) &#123;</span><br><span class=\"line\">                left--;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                right++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return vector(arr.begin() + left + 1, arr.begin() + right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>",
            "tags": [
                "Medium",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/08/24/LeetCode/1460-%E9%80%9A%E8%BF%87%E7%BF%BB%E8%BD%AC%E5%AD%90%E6%95%B0%E7%BB%84%E4%BD%BF%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9B%B8%E7%AD%89/",
            "url": "https://x-17.top/2022/08/24/LeetCode/1460-%E9%80%9A%E8%BF%87%E7%BF%BB%E8%BD%AC%E5%AD%90%E6%95%B0%E7%BB%84%E4%BD%BF%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9B%B8%E7%AD%89/",
            "title": "1460. 通过翻转子数组使两个数组相等",
            "date_published": "2022-08-24T04:12:49.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/make-two-arrays-equal-by-reversing-sub-arrays/\">https://leetcode.cn/problems/make-two-arrays-equal-by-reversing-sub-arrays/</a> 给你两个长度相同的整数数组 target 和 arr 。每一步中，你可以选择 arr 的任意 非空子数组 并将它翻转。你可以执行此过程任意次。 如果你能让 arr 变得与 target 相同，返回 True；否则，返回 False 。 示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：target = [1,2,3,4], arr = [2,4,1,3]</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">解释：你可以按照如下步骤使 arr 变成 target：</span><br><span class=\"line\">1- 翻转子数组 [2,4,1] ，arr 变成 [1,4,2,3]</span><br><span class=\"line\">2- 翻转子数组 [4,2] ，arr 变成 [1,2,4,3]</span><br><span class=\"line\">3- 翻转子数组 [4,3] ，arr 变成 [1,2,3,4]</span><br><span class=\"line\">上述方法并不是唯一的，还存在多种将 arr 变成 target 的方法。</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：target = [7], arr = [7]</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">解释：arr 不需要做任何翻转已经与 target 相等。</span><br></pre></td></tr></table></figure>\n<p>示例 3：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：target = [3,7,9], arr = [3,7,11]</span><br><span class=\"line\">输出：false</span><br><span class=\"line\">解释：arr 没有数字 9 ，所以无论如何也无法变成 target 。</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">target.length == arr.length</span><br><span class=\"line\">1 &lt;= target.length &lt;= 1000</span><br><span class=\"line\">1 &lt;= target[i] &lt;= 1000</span><br><span class=\"line\">1 &lt;= arr[i] &lt;= 1000</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>如果target和arr的长度为1，那么只需要判断二者是否相等即可； 如果它们的长度大于一，以二为例，只要它们的元素都相等，就可以通过最多一次交换得到相同的两个数组；同理可证，可在不改变其他数字位置的情况下交换任意两个数字的位置，因此，只需判断两数组所包含的元素是否完全相等即可。 解法一：利用map存储出现的整数及次数，比较是否相等即可。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    bool canBeEqual(vector&lt;int&gt;&amp; target, vector&lt;int&gt;&amp; arr) &#123;</span><br><span class=\"line\">        if(target.size()==1)&#123;</span><br><span class=\"line\">            if(target[0]==arr[0])</span><br><span class=\"line\">                return true;</span><br><span class=\"line\">            else</span><br><span class=\"line\">                return false;</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            map&lt;int,int&gt; t;</span><br><span class=\"line\">            map&lt;int,int&gt; a;</span><br><span class=\"line\">            for(int i=0;i&lt;target.size();i++)&#123; </span><br><span class=\"line\">                if(t.count(target[i]))&#123; </span><br><span class=\"line\">                    t[target[i]]++; </span><br><span class=\"line\">                &#125;else&#123; </span><br><span class=\"line\">                    t[target[i]]=1; </span><br><span class=\"line\">                &#125; </span><br><span class=\"line\">                if(a.count(arr[i]))&#123; </span><br><span class=\"line\">                    a[arr[i]]++; </span><br><span class=\"line\">                &#125;else&#123; </span><br><span class=\"line\">                    a[arr[i]]=1; </span><br><span class=\"line\">                &#125; </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            for(auto it=t.begin(),ia=a.begin();it!=t.end(),ia!=a.end();it++,ia++)&#123; </span><br><span class=\"line\">                if(it-&gt;first!=ia-&gt;firstit-&gt;second!=ia-&gt;second)&#123;</span><br><span class=\"line\">                    return false;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>解法二：排序后比较即可</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    bool canBeEqual(vector&lt;int&gt;&amp; target, vector&lt;int&gt;&amp; arr) &#123;</span><br><span class=\"line\">        sort(target.begin(),target.end());</span><br><span class=\"line\">        sort(arr.begin(),arr.end());</span><br><span class=\"line\">        for(int i=0;i&lt;target.size();i++)&#123;</span><br><span class=\"line\">            if(target[i]!=arr[i])&#123;</span><br><span class=\"line\">                return false;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>",
            "tags": [
                "Easy",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/08/23/LeetCode/782-%E5%8F%98%E4%B8%BA%E6%A3%8B%E7%9B%98/",
            "url": "https://x-17.top/2022/08/23/LeetCode/782-%E5%8F%98%E4%B8%BA%E6%A3%8B%E7%9B%98/",
            "title": "782.变为棋盘",
            "date_published": "2022-08-23T11:14:21.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/transform-to-chessboard/\">https://leetcode.cn/problems/transform-to-chessboard/</a></p>\n<p>一个 n x n 的二维网络 board 仅由 0 和 1 组成 。每次移动，你能任意交换两列或是两行的位置。<br>返回 将这个矩阵变为  “棋盘”  所需的最小移动次数 。如果不存在可行的变换，输出 -1。<br>“棋盘” 是指任意一格的上下左右四个方向的值均与本身不同的矩阵。<br>示例 1:<br><img src=\"https://x-17.top/wp-content/uploads/2022/08/chessboard1-grid.jpg\" alt=\"\"><br>输入: board = [[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]]<br>输出: 2<br>解释:一种可行的变换方式如下，从左到右：<br>第一次移动交换了第一列和第二列。<br>第二次移动交换了第二行和第三行。<br>示例 2:<br><img src=\"https://x-17.top/wp-content/uploads/2022/08/chessboard2-grid.jpg\" alt=\"\"><br>输入: board = [[0, 1], [1, 0]]<br>输出: 0<br>解释: 注意左上角的格值为0时也是合法的棋盘，也是合法的棋盘.<br>示例 3:<br><img src=\"https://x-17.top/wp-content/uploads/2022/08/chessboard3-grid.jpg\" alt=\"\"><br>输入: board = [[1, 0], [1, 0]]<br>输出: -1<br>解释: 任意的变换都不能使这个输入变为合法的棋盘。  </p>\n<p>提示：<br>n == board.length<br>n == board[i].length<br>2 &lt;= n &lt;= 30<br>board[i][j] 将只包含 0或 1</p>\n</blockquote>\n<h2 id=\"官方解法：\"><a href=\"#官方解法：\" class=\"headerlink\" title=\"官方解法：\"></a>官方解法：</h2><p>方法一：分维度计算</p>\n<p>首先需要思考的是对矩阵做一次交换之后，矩阵的变换状态。比如我们以交换列为代表，在对任意两列进行交换之后，可以看到列交换是不会改变任意相邻两行之间的元素异同对应关系，比如相邻两行的两个元素<em>board</em>[i][j],<em>board</em>[i+1][j]原本就相同，任意列交换之后这个两个元素对应的关系保持不变，如果这两个元素本来就不同，经过列交换之后也仍然不同，因此可以推出矩阵一定只能包含有两种不同的行，要么与第一行的元素相同，要么每一行的元素刚好与第一行的元素“相反”。如果矩阵可以转换为合法的“棋盘”，假设第 1 行的元素为 [0,1,1,1,0]，则其他行的元素要么为 [0,1,1,1,0]，要么为 [1,0,0,0,1]。最终的棋盘一定只有两种不同的行，要么以 0 开始的 [0,1,0,1,⋯]，要么以 11 开始的 [1,0,1,0,⋯]，因此我们可以推出棋盘也一定可以通过列变换将所有的行变为只有以上两种状态的行，否则无法得到最终合法的“棋盘”。同时我们可以观察到，先换行再换列跟先换列再换行结果是一样的，因为我们可以先将所有的行调整到正确的位置，再将所有的列调整到正确的位置。行与列之间的变换实际是相互独立的，二者互不影响，列变换不会影响相邻两行的异同关系，行变换不会不会影响相邻两列的异同关系。</p>\n<p>由于最终只有两种不同的行，要达成最终的“棋盘”实际上等价于将矩阵的行表示成 0,1 相互交替的状态，如果一个行无法变为 0,1 交替的状态，则我们认为矩阵不存在可行的变换。假设矩阵的某行用 [0,1] 表示之后得到数组为 [0,1,1,1,0,0]，那么只需求出这个数组变成 [0,1,0,1,0,1] 或者 [1,0,1,0,1,0] 的最少交换次数即可。同理，对于矩阵的列也是如此，这就将二维问题变成了两个一维问题。我们实际只需要分别将矩阵的第一行变为最终状态和第一列变为最终状态，最终的矩阵一定为合法“棋盘”。</p>\n<p>首先我们需要检测矩阵的合法性，即该矩阵是否可以变为合法的“棋盘”。我们依次检测矩阵的每一行是否是否可以变为 0,1 交替，即变为 [0,1,0,1,⋯],[1,0,1,0,⋯] 两种可能的行；然后依次检测矩阵的每一列是否可以变为 0,10,1 交替，即变为 [0,1,0,1,⋯],[1,0,1,0,⋯] 两种可能的列。设行的数目为 n，检测矩阵的行与列时需要进行如下检测：</p>\n<p>检测每一行和每一列的状态是否合法：由于列变换不改变相邻两行元素的对应关系，因此我们可以知道矩阵的行要么与第 11 行相同，要么与第 11 行“相反”。设第一行的状态为 <em>rowMask</em>，与之相反对应的状态为 <em>reverseRowMask</em>，我们检测每一行是否属于这两个合法的状态 <em>rowMask,reverseRowMask</em>，如果不合法直接返回，对于列也采用同样的检测方法。由于题目中的行与列的值均为 0 或者 1，且行数和列数最大为 30，我们利用压缩位图来表示每一行或者每一列的状态，可以用一个 32 位整数来表示每一行，其中整数每位上的数字对应着每列上的数字。</p>\n<p>检测每一行和每一列中含有的数字是否合法：检测每一行或者每一列若要变为 0,1 交替的状态，如果 n 为偶数，则每一行中 1 的数目与 0 的数目相等；如果 n 为奇数，则每一行中 1 的数目与 0 的数目相差的绝对值一定为 1。此时我们只需要检测第一行中含有的数字 0,1 的个数是否合法，对于列我们也采用同样的检测方法。由于我们用一个 32 位整数来表示每一行或者每一列，我们只需要要快速计算出整数的二进制位上含有的 1 的数目即可。</p>\n<p>检测不同状态的行数和列数是否合法：我们设矩阵中与第一行相同的行的数量为 <em>count</em>。根据我们之前的推论可知，需要满足两种不同的行交替分情况讨论：如果 n 为偶数，由于必须要满足两种不同的行交替，每种行的数目只能占到总行数的一半，此时一定有 <em>count</em>×2=n；如果 n 为奇数，由于必须要满足两种不同的行交替，则另一种行的数量只能为 <em>n−count</em>，由于必须满足交替不同，则二者之间的差值的绝对值一定为 11，因此此时一定满足 ∣2×<em>count</em>−n∣=1，满足以上条件才是合法的行数。我们采用同样的方法对矩阵的列数进行检测。</p>\n<p>其次我们求出将矩阵变为棋盘的最少交换次数。分为两种情况讨论:</p>\n<p>如果 n 为偶数，则此时最终的合法棋盘有两种可能，即第一行的元素的第一个元素 <em>board</em>[0][0]=0 或者 <em>board</em>[0][0]=1。我们可以选择将第 1 行变为以 0 开头，此时只需将偶数位上的 0 全部替换为 1 即可；也可以选择将第 1 行变为以 1 开头，此时只需将奇数位上的 0 全部替换为 1 即可。我们可以用位图来快速计算出偶数位或者奇数位上 1 的个数，可以与特定的数进行布尔代数运算即可快速消除奇数位或者偶数位上的 1。</p>\n<p>如果 n 为奇数，则此时最终的合法棋盘只有一种可能，如果第一行中 0 的数目大于 1 的数目，此时第一行只能变为以 0 为开头交替的序列，此时我们只需要将偶数位上的 0 全部变为 1；如果第一行中 0 的数目小于 1 的数目，此时第一行只能交换变为以 1 为开头交替的序列，此时我们只需要将奇数位上的 0 全部变为 1。可以用位图来快速计算出偶数位或者奇数位上 1 的个数，可以与特定的数进行布尔代数运算即可快速消除奇数位或者偶数位上的 1。</p>\n<p>由于我们采用 32 位整数表示每一行或者每一列，在快速计算偶数位或者上的 1 的数目时可以采用位运算掩码。比如 32 位整数 x，我们只保留 x 偶数位上的 1，此时我们需要去掉奇数位上的 1，此时只需将 x 与掩码：</p>\n<p>\\((1010 1010 1010 1010 1010 1010 1010 1010)_2=0xAAAAAAAA\\)</p>\n<p>相与即可；我们只保留 xx 奇数位上的 11，此时我们需要去掉偶数位上的 11，此时只需将 xx 与掩码：</p>\n<p>\\((0101 0101 0101 0101 0101 0101 0101 0101)_2=0x55555555\\)</p>\n<p>相与即可。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int getMoves(int mask, int count, int n) &#123;</span><br><span class=\"line\">        int ones = __builtin_popcount(mask);</span><br><span class=\"line\">        if (n &amp; 1) &#123;</span><br><span class=\"line\">            /* 如果 n 为奇数，则每一行中 1 与 0 的数目相差为 1，且满足相邻行交替 */</span><br><span class=\"line\">            if (abs(n - 2 * ones) != 1  abs(n - 2 * count) != 1 ) &#123;</span><br><span class=\"line\">                return -1;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (ones == (n &gt;&gt; 1)) &#123;</span><br><span class=\"line\">                /* 偶数位变为 1 的最小交换次数 */</span><br><span class=\"line\">                return n / 2 - __builtin_popcount(mask &amp; 0xAAAAAAAA);</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                /* 奇数位变为 1 的最小交换次数 */</span><br><span class=\"line\">                return (n + 1) / 2 - __builtin_popcount(mask &amp; 0x55555555);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; else &#123; </span><br><span class=\"line\">            /* 如果 n 为偶数，则每一行中 1 与 0 的数目相等，且满足相邻行交替 */</span><br><span class=\"line\">            if (ones != (n &gt;&gt; 1)  count != (n &gt;&gt; 1)) &#123;</span><br><span class=\"line\">                return -1;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            /* 偶数位变为 1 的最小交换次数 */</span><br><span class=\"line\">            int count0 = n / 2 - __builtin_popcount(mask &amp; 0xAAAAAAAA);</span><br><span class=\"line\">            /* 奇数位变为 1 的最小交换次数 */</span><br><span class=\"line\">            int count1 = n / 2 - __builtin_popcount(mask &amp; 0x55555555);  </span><br><span class=\"line\">            return min(count0, count1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    int movesToChessboard(vector&lt;vector&lt;int&gt;&gt;&amp; board) &#123;</span><br><span class=\"line\">        int n = board.size();</span><br><span class=\"line\">        int rowMask = 0, colMask = 0;        </span><br><span class=\"line\"></span><br><span class=\"line\">        /* 检查棋盘的第一行与第一列 */</span><br><span class=\"line\">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class=\"line\">            rowMask = (board[0][i] &lt;&lt; i);</span><br><span class=\"line\">            colMask = (board[i][0] &lt;&lt; i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        int reverseRowMask = ((1 &lt;&lt; n) - 1) ^ rowMask;</span><br><span class=\"line\">        int reverseColMask = ((1 &lt;&lt; n) - 1) ^ colMask;</span><br><span class=\"line\">        int rowCnt = 0, colCnt = 0;</span><br><span class=\"line\">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class=\"line\">            int currRowMask = 0;</span><br><span class=\"line\">            int currColMask = 0;</span><br><span class=\"line\">            for (int j = 0; j &lt; n; j++) &#123;</span><br><span class=\"line\">                currRowMask = (board[i][j] &lt;&lt; j);</span><br><span class=\"line\">                currColMask = (board[j][i] &lt;&lt; j);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            /* 检测每一行的状态是否合法 */</span><br><span class=\"line\">            if (currRowMask != rowMask &amp;&amp; currRowMask != reverseRowMask) &#123;</span><br><span class=\"line\">                return -1;</span><br><span class=\"line\">            &#125; else if (currRowMask == rowMask) &#123;</span><br><span class=\"line\">                /* 记录与第一行相同的行数 */</span><br><span class=\"line\">                rowCnt++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            /* 检测每一列的状态是否合法 */</span><br><span class=\"line\">            if (currColMask != colMask &amp;&amp; currColMask != reverseColMask) &#123;</span><br><span class=\"line\">                return -1;</span><br><span class=\"line\">            &#125; else if (currColMask == colMask) &#123;</span><br><span class=\"line\">                /* 记录与第一列相同的列数 */</span><br><span class=\"line\">                colCnt++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        int rowMoves = getMoves(rowMask, rowCnt, n);</span><br><span class=\"line\">        int colMoves = getMoves(colMask, colCnt, n);</span><br><span class=\"line\">        return (rowMoves == -1  colMoves == -1) ? -1 : (rowMoves + colMoves); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>",
            "tags": [
                "Hard",
                "leetcode每日一题"
            ]
        }
    ]
}