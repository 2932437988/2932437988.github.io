{
    "version": "https://jsonfeed.org/version/1",
    "title": "潇十七 • All posts by \"mit 6.1810\" tag",
    "description": "可生活不是电影，我也少了点运气",
    "home_page_url": "https://x-17.top",
    "items": [
        {
            "id": "https://x-17.top/2022/10/08/MIT-6-1810-Operating-System-Engineering/",
            "url": "https://x-17.top/2022/10/08/MIT-6-1810-Operating-System-Engineering/",
            "title": "MIT 6.1810 Operating System Engineering",
            "date_published": "2022-10-08T12:22:17.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p>课程地址:<a href=\"https://pdos.csail.mit.edu/6.1810/2022/index.html\">https://pdos.csail.mit.edu/6.1810/2022/index.html</a><br>\n 新坑，MIT 6.1810</p>\n</blockquote>\n<h1 id=\"61810-2022-lecture-1-os-overview\"><a class=\"markdownIt-Anchor\" href=\"#61810-2022-lecture-1-os-overview\">#</a> 6.1810 2022 Lecture 1: O/S overview</h1>\n<div class=\"tabs\" id=\"lecture-1\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#lecture-1-1\">Overview</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#lecture-1-2\">Class structure</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#lecture-1-3\">Introduction to UNIX system calls</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#lecture-1-4\">examples</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"lecture-1-1\"><h2 id=\"overview\"><a class=\"markdownIt-Anchor\" href=\"#overview\">#</a> Overview</h2>\n<p><span class=\"bubble-content\">6.1810 goals</span><span class=\"bubble-notation\"><span class=\"bubble-item\" style=\"background-color:#71a4e3;\">Understand operating system (O/S) design and implementation<br>Hands-on experience extending a small O/S<br>Hands-on experience writing systems software</span></span><br>\n<span class=\"bubble-content\">What is the purpose of an O/S?</span><span class=\"bubble-notation\"><span class=\"bubble-item\" style=\"background-color:#71a4e3;\">Abstract the hardware for convenience and portability<br>Multiplex the hardware among many applications<br>Isolate applications in order to contain bugs<br>Allow sharing among cooperating applications<br>Control sharing for security<br>Don’t get in the way of high performance<br>Support a wide range of applications</span></span><br>\n<span class=\"bubble-content\">Organization: layered picture</span><span class=\"bubble-notation\"><span class=\"bubble-item\" style=\"background-color:#71a4e3;\">[user/kernel diagram]<br>- user applications: vi，gcc，DB，&amp;c<br>- kernel services<br>- h/w: CPU，RAM，disk，net，&amp;c<br>we care a lot about the interfaces and internal kernal structure</span></span><br>\n<span class=\"bubble-content\">What services does ans O/S kernel typically provide?</span><span class=\"bubble-notation\"><span class=\"bubble-item\" style=\"background-color:#71a4e3;\">process (a running program)<br>memory allocation<br>file contents<br>file names，directories<br>access control (security)<br>many others: users，IPC，network，time，terminals</span></span><br>\n<span class=\"bubble-content\">What’s the application / kernel interface?</span><span class=\"bubble-notation\"><span class=\"bubble-item\" style=\"background-color:#71a4e3;\">“System calls&quot;<br>Examples，in C，from UNIX (e.g. Linux，macOS，FreeBSD):<br>    fd = open(out”，1);<br>    write(fd，“hello\\n”，6);<br>    pid = fork();<br>There look like function calls but they aren’t&quot;</span></span><br>\n<span class=\"bubble-content\">Why is O/S design+implementation hard and interesting?</span><span class=\"bubble-notation\"><span class=\"bubble-item\" style=\"background-color:#71a4e3;\">many design tensions:<br>- efficient vs abstract/portable/general-purpose<br>- powerful vs simple interfaces<br>- flexible vs secure<br>features interact: <br>    fd = open;<br>    fork()<br>uses are varied: laptops，smart-phones，cloud，virtual machines，embedded<br>evolving hardware: NVRAM，multi-core，fast networks<br>unforgiving environment: quirky h/w，hard to debug</span></span><br>\n<span class=\"bubble-content\">You’ll be glad you took this coourse if you…</span><span class=\"bubble-notation\"><span class=\"bubble-item\" style=\"background-color:#71a4e3;\">care about what gose on under the hood<br>like infrastructure<br>need to track down bugs or security problems<br>care about high performance</span></span></p><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"lecture-1-2\"><h2 id=\"class-structure\"><a class=\"markdownIt-Anchor\" href=\"#class-structure\">#</a> Class structure</h2>\n<p><span class=\"bubble-content\">Online course information:</span><span class=\"bubble-notation\"><span class=\"bubble-item\" style=\"background-color:#ec5830;\"><a href=\"https://pdos.csail.mit.edu/6.1810/\">https://pdos.csail.mit.edu/6.1810/</a> – schedule，assignments，labs<br>Piazza – announcements，discussion，lab help</span></span><br>\n<span class=\"bubble-content\">Lectures</span><span class=\"bubble-notation\"><span class=\"bubble-item\" style=\"background-color:#ec5830;\">O/S ideas<br>case study of xv6，a small O/S，via code and xv6 book<br>lab background<br>O/S papers<br>submit a question about each reading，before lecture.</span></span><br>\n<span class=\"bubble-content\">Labs:</span><span class=\"bubble-notation\"><span class=\"bubble-item\" style=\"background-color:#ec5830;\">The point: hands-on experience<br>Mostly one week each.<br>Three kinds:<br>    Systems programming (due next week…)<br>    O/S primitives，e.g. thread switching.<br>    O/S kernel extensions to xv6，e.g. network.<br>Use piazza to ask/answer lab questions.<br>Discussion is great，but please do not look at others’ solutions!</span></span><br>\n<span class=\"bubble-content\">Grading:</span><span class=\"bubble-notation\"><span class=\"bubble-item\" style=\"background-color:#ec5830;\">70% labs，based on tests (the same tests you run).<br>20% lab check-oof meetings: we’ll ask you about randomly-selected labs.<br>10% home-work and class/piazza discussion.<br>No exams，no quizzes.<br>Note that most of the grade is from labs. Start them early!</span></span></p><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"lecture-1-3\"><h2 id=\"introduction-to-unix-system-calls\"><a class=\"markdownIt-Anchor\" href=\"#introduction-to-unix-system-calls\">#</a> Introduction to UNIX system calls</h2>\n<details class=\"folding-tag\" blue><summary> Introduction to UNIX system calls </summary>\n              <div class='content'>\n              <div class=\"note success simple\"><p>Applications see the O/S via system calls; that interface will be a big focus.<br>let’s start by looking at how programs use system calls.<br>you’ll use these system calls in the first lab.<br>and extend and improve them in subsequent labs.<br>I’ll show some examples, and run them on xv6.<br>xv6 has similar structure to UNIX systems such as Linux.</p></div><details class=\"folding-tag\" red><summary> but much simpler -- you'll be able to digest all of xv6 </summary>              <div class='content'>              <p>accompanying book explains how xv6 works, and why</p>              </div>            </details><details class=\"folding-tag\" red><summary> why UNIX? </summary>              <div class='content'>              <p>open source, well documented, clean design, widely used<br>studying xv6 will help if you ever need to look inside Linux</p>              </div>            </details><details class=\"folding-tag\" red><summary> xv6 has two roles in 6.1810: </summary>              <div class='content'>              <p>example of core functions: virtual memory, multi-core, interrupts, &amp;c<br>starting point for most of the labs</p>              </div>            </details><div class=\"note success simple\"><p>xv6 runs on RISC-V, as in 6.004<br>you’ll run xv6 under the qemu machine emulator</p></div>\n              </div>\n            </details>\n<details class=\"folding-tag\" blue><summary> copy.c </summary>\n              <div class='content'>\n              <p class='p red'>copy input to output</p><div class=\"note success simple\"><p>read bytes from input, write them to the output</p></div><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">copy</span></span><br></pre></td></tr></table></figure><div class=\"note success simple\"><p>copy.c is written in C<br>Kernighan and Ritchie (K&amp;R) book is good for learning C<br>you can find these example programs via the schedule on the web site</p></div><details class=\"folding-tag\" red><summary> read() and write() are system calls </summary>              <div class='content'>              <div class=\"note success simple\"><p><wavy>first</wavy> read()/write() argument is a “file descriptor” (fd)<br>passed to kernel to tell it which “open file” to read/write<br>must previously have been opened<br>an FD connects to a file/device/socket/&amp;c<br>a process can open many files, have many FDs<br>UNIX convention: fd 0 is “standard input”, 1 is “standard output”</p></div><div class=\"note success simple\"><p><wavy>second</wavy> read() argument is a pointer to some memory into which to read</p></div><div class=\"note success simple\"><p><wavy>third</wavy> argument is the number of bytes to read<br>read() may read less, but not more</p></div><div class=\"note success simple\"><p><wavy>return value:</wavy> number of bytes actually read, or -1 for error</p></div><div class=\"note success simple\"><p><wavy>note:</wavy> copy.c does not care about the format of the data<br>UNIX I/O is 8-bit bytes<br>interpretation is application-specific, e.g. database records, C source, &amp;c</p></div>              </div>            </details><div class=\"note red icon-padding disabled\"><i class=\"note-icon fas fa-bullhorn\"></i><p>where do file descriptors come from?</p></div>\n              </div>\n            </details>\n<details class=\"folding-tag\" blue><summary> open.c </summary>\n              <div class='content'>\n              <p class='p red'>create a file</p><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">open</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">cat</span> out</span></span><br></pre></td></tr></table></figure><div class=\"note success simple\"><p>open() creates a file, <wavy>returns a file descriptor (or -1 for error)</wavy><br>FD is a small integer<br>FD indexes into a per-process table maintained by kernel<br>[user/kernel diagram]</p></div><span class=\"bubble-content\">different processes have different FD name-spaces</span><span class=\"bubble-notation\"><span class=\"bubble-item\" style=\"background-color:#71a4e3;\">i.e. FD 1 usually means different things to different processes</span></span><div class=\"note red icon-padding flat\"><i class=\"note-icon fas fa-bullhorn\"></i><p>these examples ignore errors – don’t be this sloppy!</p></div><div class=\"note success simple\"><p>Figure 1.2 in the xv6 book lists system call arguments/return<br>or look at UNIX man pages, e.g. “man 2 open”</p></div>\n              </div>\n            </details>\n<details class=\"folding-tag\" blue><summary> what happens when a program calls a system call like open()? </summary>\n              <div class='content'>\n              <div class=\"note success simple\"><p>looks like a function call, but it’s actually a special instruction<br>hardware saves some user registers<br>hardware increases privilege level<br>hardware jumps to a known “entry point” in the kernel<br>now running C code in the kernel<br>kernel calls system call implementation<br>sys_open() looks up name in file system<br>it might wait for the disk<br>it updates kernel data structures (file block cache, FD table)<br>restore user registers<br>reduce privilege level<br>jump back to calling point in the program, which resumes<br>we’ll see more detail later in the course</p></div>\n              </div>\n            </details>\n<details class=\"folding-tag\" blue><summary> shell </summary>\n              <div class='content'>\n              <div class=\"note success simple\"><p>I’ve been typing to UNIX’s command-line interface, the shell.<br>the shell prints the “$” prompts.<br>the shell lets you run UNIX command-line utilities<br>useful for system management, messing with files, development, scripting</p></div><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">ls</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">ls</span> &gt; out</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">grep x &lt; out</span></span><br></pre></td></tr></table></figure><div class=\"note success simple\"><p>UNIX supports other styles of interaction too<br>window systems, GUIs, servers, routers, &amp;c.<br>but time-sharing via the shell was the original focus of UNIX.<br>we can exercise many system calls via the shell.</p></div>\n              </div>\n            </details>\n<details class=\"folding-tag\" blue><summary> fork.c </summary>\n              <div class='content'>\n              <p class='p red'>create a new process</p><div class=\"note success simple\"><p>the shell creates a new process for each command you type, e. g. for</p></div><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">echo</span> hello</span></span><br></pre></td></tr></table></figure>the fork() system call creates a new process<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">fork</span></span><br></pre></td></tr></table></figure><div class=\"note success simple\"><p>the kernel makes a copy of the calling process<br>instructions, data, registers, file descriptors, current directory<br>“parent” and “child” process<br>only difference: <emp>fork() returns a pid in parent, 0 in child a pid (process ID) is an interger,kernel gives each process a different pid</emp><br>thus:<br>fork.c’s “fork() returned” executes in <em>both</em> processes<br>the “if(pid == 0)” allows code to distinguish<br>ok, fork lets us create a new process</p></div><div class=\"note red icon-padding simple\"><i class=\"note-icon fas fa-bullhorn\"></i><p>how can we run a program in that process?</p></div>\n              </div>\n            </details>\n<details class=\"folding-tag\" blue><summary> exec.c </summary>\n              <div class='content'>\n              <p class='p red'>replace calling process with an executable file</p><div class=\"note success simple\"><p>how does the shell run a program, e. g.</p></div><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">echo</span> a b c</span></span><br></pre></td></tr></table></figure><div class=\"note success simple\"><p>a program is stored in a file: instructions and initial memory created by the compiler and linker<br>so there’s a file called echo, containing instructions</p></div><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">exec</span></span></span><br></pre></td></tr></table></figure><div class=\"note success simple\"><p>exec() replaces current process with an executable file<br>discards instructions and memory from the file<br>preserves file descriptors<br>exec(filename, argument-array)<br>argument-array holds command-line arguments; exec passes to main()<br>cat uesr/echo.c<br>echo.c shows how a program looks at its command-line arguments</p></div>\n              </div>\n            </details>\n<details class=\"folding-tag\" blue><summary> forkexec.c </summary>\n              <div class='content'>\n              <p class='p red'>fork() a new process，exec() a program</p><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">forkexec</span></span><br></pre></td></tr></table></figure><div class=\"note success simple\"><p>forkexec.c contains a common UNIX idiom:<br>fork() a child process<br>exec() a command in the child<br>parent wait()s for child to finish<br>the shell does fork/exec/wait for every command you type<br>after wait(), the shell prints the next prompt<br>to run in the background – &amp; – the shell skips the wait()<br>exit(status) -&gt; wait(&amp;status)<br>status convention: 0 = success, 1 = command encountered an error<br>note: the fork() copies, but exec() discards the copied memory<br>this may seem wasteful<br>you’ll transparently eliminate the copy in the “copy-on-write” lab</p></div>\n              </div>\n            </details>\n<details class=\"folding-tag\" blue><summary> refirect.c </summary>\n              <div class='content'>\n              <p class='p red'>redirect the output of a command</p><div class=\"note success simple\"><p>what does the shell do for this?</p></div><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">echo</span> hello &gt; out</span></span><br></pre></td></tr></table></figure><div class=\"note success simple\"><p>answer: fork, change FD 1 in child, exec echo</p></div><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">redirect</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">cat</span> out</span></span><br></pre></td></tr></table></figure><div class=\"note success simple\"><p>note: open() always chooses lowest unused FD; 1 due to close(1).<br>fork, FDs, and exec interact nicely to implement I/O redirection<br>separate fork-then-exec give child a chance to change FDs before exec FDs provide indirection<br>commands just use FDs 0 and 1, don’t have to know where they go exec preserves the FDs that sh set up<br>thus: only sh has to know about I/O redirection, not each program</p></div>\n              </div>\n            </details>\n<details class=\"folding-tag\" blue><summary> design decisions </summary>\n              <div class='content'>\n              <div class=\"note success simple\"><p>It’s worth asking “why” about design decisions:<br>Why these I/O and process abstractions?<br>Why not something else?<br>Why provide a file system?<br>Why not let programs ues the disk their own way?<br>Why FDs?<br>Why not pass a filename to write()?<br>Why are files streams of bytes, not disk blocks or formatted records?<br>Why not combine fork() and exec()?<br>The UNIX design works well, but we will see other designs!</p></div>\n              </div>\n            </details>\n<details class=\"folding-tag\" blue><summary> pipe1.c </summary>\n              <div class='content'>\n              <p class='p red'>communicate through a pipe</p><div class=\"note success simple\"><p>how does the shell implement</p></div><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">ls</span> | grep x</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">pipe1</span></span><br></pre></td></tr></table></figure><div class=\"note success simple\"><p>an FD can refer to a “pipe”, as well as a file<br>the pipe() system call creates two FDs<br>read from the first FD<br>write to the seconnd FD<br>the hernel maintains a buffer for each pipe<br>[u/k diagram]<br>write() appends to the buffer<br>read() waits until there is data</p></div>\n              </div>\n            </details>\n<details class=\"folding-tag\" blue><summary> pipe2.c </summary>\n              <div class='content'>\n              <p class='p red'>communicate between process</p><div class=\"note success simple\"><p>pipes combine well with fork() to implement ls | grep x<br>shell creates a pipe,<br>then forks (twice),<br>then connects ls’s FD 1 to pipe’s write FD,<br>and grep’s FD 0 to the pipe<br>[diagram]</p></div><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">pipe -- a simplified version</span></span><br></pre></td></tr></table></figure><div class=\"note success simple\"><p>pipes are a separate abstraction, but combine well w/ fork()</p></div>\n              </div>\n            </details>\n<details class=\"folding-tag\" blue><summary> list.c </summary>\n              <div class='content'>\n              <p class='p red'>list files in a directory</p><div class=\"note success simple\"><p>how does ls get a list of the files in a directory?<br>you can open a directory and read it -&gt; file names<br>“.” is a pseudo-name for a process’s current directory<br>see ls.c for more details</p></div>\n              </div>\n            </details>\n<details class=\"folding-tag\" blue><summary> Summary </summary>\n              <div class='content'>\n              <div class=\"note success simple\"><p>We’ve looked at UNIX’s I/O, file system, and process abstractions.<br>The interfaces are simple – just integers and I/O buffers.<br>The abstractions combine well, e. g. for I/O rediretion.</p></div>\n              </div>\n            </details><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"lecture-1-4\"><div class=\"tabs\" id=\"examples\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#examples-1\">copy.c</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#examples-2\">echo.c</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#examples-3\">exec.c</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#examples-4\">fork.c</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#examples-5\">forkexec.c</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#examples-6\">list.c</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#examples-7\">open.c</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#examples-8\">pipe1.c</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#examples-9\">pipe2.c</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#examples-10\">redirect.c</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"examples-1\"><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// copy.c: copy input to output.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;kernel/types.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;user/user.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span></span><br><span class=\"line\"><span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">char</span> buf[<span class=\"number\">64</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = read(<span class=\"number\">0</span>, buf, <span class=\"keyword\">sizeof</span>(buf));</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    write(<span class=\"number\">1</span>, buf, n);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"examples-2\"><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;kernel/types.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;user/user.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span></span><br><span class=\"line\"><span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> *argv[])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(i = <span class=\"number\">1</span>; i &lt; argc; i++)&#123;</span><br><span class=\"line\">    write(<span class=\"number\">1</span>, argv[i], <span class=\"built_in\">strlen</span>(argv[i]));</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i + <span class=\"number\">1</span> &lt; argc)&#123;</span><br><span class=\"line\">      write(<span class=\"number\">1</span>, <span class=\"string\">&quot; &quot;</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      write(<span class=\"number\">1</span>, <span class=\"string\">&quot;\\n&quot;</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"examples-3\"><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// exec.c: replace a process with an executable file</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;kernel/types.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;user/user.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span></span><br><span class=\"line\"><span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">char</span> *argv[] = &#123; <span class=\"string\">&quot;echo&quot;</span>, <span class=\"string\">&quot;this&quot;</span>, <span class=\"string\">&quot;is&quot;</span>, <span class=\"string\">&quot;echo&quot;</span>, <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  exec(<span class=\"string\">&quot;echo&quot;</span>, argv);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;exec failed!\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"examples-4\"><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// fork.c: create a new process</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;kernel/types.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;user/user.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span></span><br><span class=\"line\"><span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> pid;</span><br><span class=\"line\"></span><br><span class=\"line\">  pid = fork();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;fork() returned %d\\n&quot;</span>, pid);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(pid == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;child\\n&quot;</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;parent\\n&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"examples-5\"><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;kernel/types.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;user/user.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// forkexec.c: fork then exec</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span></span><br><span class=\"line\"><span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> pid, status;</span><br><span class=\"line\"></span><br><span class=\"line\">  pid = fork();</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(pid == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> *argv[] = &#123; <span class=\"string\">&quot;echo&quot;</span>, <span class=\"string\">&quot;THIS&quot;</span>, <span class=\"string\">&quot;IS&quot;</span>, <span class=\"string\">&quot;ECHO&quot;</span>, <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">    exec(<span class=\"string\">&quot;echo&quot;</span>, argv);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;exec failed!\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;parent waiting\\n&quot;</span>);</span><br><span class=\"line\">    wait(&amp;status);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;the child exited with status %d\\n&quot;</span>, status);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"examples-6\"><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;kernel/types.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;user/user.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// list.c: list file names in the current directory</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dirent</span> &#123;</span></span><br><span class=\"line\">  ushort inum;</span><br><span class=\"line\">  <span class=\"type\">char</span> name[<span class=\"number\">14</span>];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span></span><br><span class=\"line\"><span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> fd;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dirent</span> <span class=\"title\">e</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  fd = open(<span class=\"string\">&quot;.&quot;</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(read(fd, &amp;e, <span class=\"keyword\">sizeof</span>(e)) == <span class=\"keyword\">sizeof</span>(e))&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(e.name[<span class=\"number\">0</span>] != <span class=\"string\">&#x27;\\0&#x27;</span>)&#123;</span><br><span class=\"line\">      <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n&quot;</span>, e.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"examples-7\"><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// open.c: create a file, write to it.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;kernel/types.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;user/user.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;kernel/fcntl.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span></span><br><span class=\"line\"><span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> fd = open(<span class=\"string\">&quot;out&quot;</span>, O_WRONLY | O_CREATE | O_TRUNC);</span><br><span class=\"line\">  write(fd, <span class=\"string\">&quot;ooo\\n&quot;</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"examples-8\"><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// pipe1.c: communication over a pipe</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;kernel/types.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;user/user.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span></span><br><span class=\"line\"><span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> fds[<span class=\"number\">2</span>];</span><br><span class=\"line\">  <span class=\"type\">char</span> buf[<span class=\"number\">100</span>];</span><br><span class=\"line\">  <span class=\"type\">int</span> n;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// create a pipe, with two FDs in fds[0], fds[1].</span></span><br><span class=\"line\">  pipe(fds);</span><br><span class=\"line\">  </span><br><span class=\"line\">  write(fds[<span class=\"number\">1</span>], <span class=\"string\">&quot;this is pipe1\\n&quot;</span>, <span class=\"number\">14</span>);</span><br><span class=\"line\">  n = read(fds[<span class=\"number\">0</span>], buf, <span class=\"keyword\">sizeof</span>(buf));</span><br><span class=\"line\"></span><br><span class=\"line\">  write(<span class=\"number\">1</span>, buf, n);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"examples-9\"><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;kernel/types.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;user/user.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// pipe2.c: communication between two processes</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span></span><br><span class=\"line\"><span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> n, pid;</span><br><span class=\"line\">  <span class=\"type\">int</span> fds[<span class=\"number\">2</span>];</span><br><span class=\"line\">  <span class=\"type\">char</span> buf[<span class=\"number\">100</span>];</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// create a pipe, with two FDs in fds[0], fds[1].</span></span><br><span class=\"line\">  pipe(fds);</span><br><span class=\"line\"></span><br><span class=\"line\">  pid = fork();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (pid == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    write(fds[<span class=\"number\">1</span>], <span class=\"string\">&quot;this is pipe2\\n&quot;</span>, <span class=\"number\">14</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    n = read(fds[<span class=\"number\">0</span>], buf, <span class=\"keyword\">sizeof</span>(buf));</span><br><span class=\"line\">    write(<span class=\"number\">1</span>, buf, n);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"examples-10\"><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;kernel/types.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;user/user.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;kernel/fcntl.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// redirect.c: run a command with output redirected</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span></span><br><span class=\"line\"><span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> pid;</span><br><span class=\"line\"></span><br><span class=\"line\">  pid = fork();</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(pid == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    close(<span class=\"number\">1</span>);</span><br><span class=\"line\">    open(<span class=\"string\">&quot;out&quot;</span>, O_WRONLY | O_CREATE | O_TRUNC);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">char</span> *argv[] = &#123; <span class=\"string\">&quot;echo&quot;</span>, <span class=\"string\">&quot;this&quot;</span>, <span class=\"string\">&quot;is&quot;</span>, <span class=\"string\">&quot;redirected&quot;</span>, <span class=\"string\">&quot;echo&quot;</span>, <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">    exec(<span class=\"string\">&quot;echo&quot;</span>, argv);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;exec failed!\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    wait((<span class=\"type\">int</span> *) <span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>\n<h1 id=\"lab-util-unix-utilities\"><a class=\"markdownIt-Anchor\" href=\"#lab-util-unix-utilities\">#</a> Lab util: Unix utilities</h1>\n<div class=\"tabs\" id=\"lab:xv6-and-unix-utilities\"><ul class=\"nav-tabs\"><li class=\"tab active\"><button type=\"button\" data-href=\"#lab:xv6-and-unix-utilities-1\">Boot xv6(easy)</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#lab:xv6-and-unix-utilities-2\">sleep(easy)</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#lab:xv6-and-unix-utilities-3\">pingpong(easy)</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#lab:xv6-and-unix-utilities-4\">primes(moderate)/(hard)</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#lab:xv6-and-unix-utilities-5\">find(moderate)</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#lab:xv6-and-unix-utilities-6\">xargs(moderate)</button></li><li class=\"tab\"><button type=\"button\" data-href=\"#lab:xv6-and-unix-utilities-7\">Optional challenge exercises</button></li></ul><div class=\"tab-contents\"><div class=\"tab-item-content active\" id=\"lab:xv6-and-unix-utilities-1\"><details class=\"folding-tag\" blue><summary> requirement </summary>\n              <div class='content'>\n              <div class=\"note success simple\"><p>You can do these labs on an Athena machine or on your own computer. If you use your own computer, have a look at the <a href=\"https://pdos.csail.mit.edu/6.1810/2022/tools.html\">lab tools page</a> for setup tips.</p><p>If you use Athena, you must use an x86 machine; that is,  <code>uname -a</code>  should mention  <code>i386 GNU/Linux</code>  or  <code>i686 GNU/Linux</code>  or x86_64 GNU/Linux. You can log into a public Athena host with</p><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh -X athena.dialup.mit.edu</span><br></pre></td></tr></table></figure><p>We have set up the appropriate compilers and simulators for you on Athena. To use them, run</p><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">add -f 6.828</span><br></pre></td></tr></table></figure><p>You must run this command every time you log in (or add it to your  <code>~/.environment</code>  file). If you get obscure errors while compiling or running  <code>qemu</code> , check that you added the course locker.<br>Fetch the git repository for the xv6 source for the lab:</p><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">git <span class=\"built_in\">clone</span> git://g.csail.mit.edu/xv6-labs-2022</span></span><br><span class=\"line\">Cloning into &#x27;xv6-labs-2022&#x27;...</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">cd</span> xv6-labs-2022</span></span><br></pre></td></tr></table></figure><p>The repo is setup so that git checkouts the  <code>util</code>  branch when cloning the repo.</p><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">git status</span></span><br><span class=\"line\">Onbranch util</span><br><span class=\"line\">Your branch is up to date with &#x27;origin/util&#x27;.</span><br><span class=\"line\"></span><br><span class=\"line\">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>The xv6-labs-2022 repository differs slightly from the book’s xv6-riscv; it mostly adds some files. If you are curious look at the git log:</p><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">git <span class=\"built_in\">log</span></span></span><br></pre></td></tr></table></figure><p>The files you will need for this and subsequent lab assignments are distributed using the Git version control system. For each of the labs you will checkout (git checkout util) a version of xv6 tailored for that lab. To learn more about Git, take a look at the Git user’s manual, or, you may find this CS-oriented overview of Git useful. Git allows you to keep track of the changes you make to the code. For example, if you are finished with one of the exercises, and want to checkpoint your progress, you can commit your changes by running:</p><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">git commit -am <span class=\"string\">&#x27;my solution for util lab exercise 1&#x27;</span></span></span><br><span class=\"line\">Create commit 60d2135: my solution for util lab exercise 1</span><br><span class=\"line\">    1 file changed, 1 insertions(+), 0 deletions(-)</span><br><span class=\"line\"><span class=\"meta prompt_\">$</span></span><br></pre></td></tr></table></figure><p>You can keep track of your changes by using the  <code>git diff</code>  command. Running  <code>git diff</code>  will display the changes to your code since your last commit, and  <code>git diff origin/util</code>  will display the changes relative to the initial util code. Here, origin/util is the name of the git branch with the initial code you downloaded for the class.<br>Build and run xv6:</p><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">make qemu</span></span><br></pre></td></tr></table></figure><p>If you type  <code>ls</code>  at the prompt, you should see output similar to the following:</p><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">ls</span></span></span><br></pre></td></tr></table></figure><p>These are the files that  <code>mkfs</code>  includess in the initial file system; most are programs you can run. You just ran one of them:ls.<br>xv6 has no  <code>ps</code>  command, but, if you type <kbd>Ctrl</kbd> - <kbd>p</kbd>, the kernel will print information about each process. If you try it now, you’ll see two lines: one for  <code>init</code> , and one for  <code>sh</code> .<br>To quit qemu type: <kbd>Ctrl</kbd>-<kbd>a</kbd> <kbd>x</kbd> (press <kbd>Ctrl</kbd> and <kbd>a</kbd> at the same time, followed by <kbd>x</kbd>).</p></div><div class=\"note blue icon-padding simple\"><i class=\"note-icon fas fa-bullhorn\"></i><h4 id=\"grading-and-hand-in-procedure\"><a class=\"markdownIt-Anchor\" href=\"#grading-and-hand-in-procedure\">#</a> Grading and hand-in procedure</h4><p>You can run  <code>make grade</code>  to test your solutions with the grading program. The TAs will use the same grading program to assign your lab submission a grade. Separately, we will also have check-off meetings for labs(see <a href=\"https://pdos.csail.mit.edu/6.1810/2022/general.html#grading\">Grading policy</a>).<br>The lab code comes with GNU Make rules to make submission easier. After committing your final changes to the lab, type  <code>make handin</code>  to subtime your lab. For detailed instructions on how to submit see <a href=\"https://pdos.csail.mit.edu/6.1810/2022/labs/util.html#submit\">below</a>.</p></div>\n              </div>\n            </details>\n<details class=\"folding-tag\" blue><summary> code </summary>\n              <div class='content'>\n              <p><span class='p center logo large'>关于实验</span></p><div class=\"note blue icon-padding simple\"><i class=\"note-icon fas fa-bullhorn\"></i><p>因为阿里云服务器挂载网站并且是 centos 操作系统，虚拟机又会导致我的电脑卡顿，因而我选择了在云服务器利用 docker 容器安装 Ubuntu 完成整个实验。(后续会写 docker 学习文章，一定不鸽，咕咕咕)</p></div><div class=\"note success simple\"><p>首先，自己配置好环境哈！<br>然后安装课程所需<a href=\"https://pdos.csail.mit.edu/6.1810/2022/tools.html\">软件</a><br>我的环境是 Ubuntu 20.04，因此运行命令</p><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu</span><br></pre></td></tr></table></figure><p>之后你可以按照上面的 note 中提供的 shell 命令去运行！<br>如果你不使用 Athena，请忽略前两条指令；请注意我在部分代码块中加入了预期的运行结果，你可以通过进行 <code>$</code>  区分。</p></div>\n              </div>\n            </details><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"lab:xv6-and-unix-utilities-2\"><details class=\"folding-tag\" blue><summary> requirement </summary>\n              <div class='content'>\n              <div class=\"note blue icon-padding simple\"><i class=\"note-icon fas fa-bullhorn\"></i><p>Implement the UNIX program  <code>sleep</code>  for xv6; your  <code>sleep</code>  should pause for a user-specified number of ticks. A tick is a notion of time defined dy the xv6 hernel, namely the time between two interrupts from the timer chip. Your solution should be in the file  <code>user/sleep.c</code> .</p></div><div class=\"note success simple\"><p>Some hints:</p><ul><li>Before you start coding, read Chapter 1 of the <a href=\"\">xv6 book</a>.</li><li>Look at some of the other programs in  <code>user/</code> (e.g.,  <code>user/echo.c</code> ,  <code>user/grep.c</code> ,and  <code>user/rm.c</code> ) to see how you can obtain the command-line arguments passed to a proggram.</li><li>If the user forgets to pass an argument, sleep should print an error message.</li><li>Use the system call  <code>sleep</code> .</li><li>See  <code>kernel/sysproc.c</code>  for the xv6 kernel code that implements the  <code>sleep</code>  system call (look for  <code>sys_sleep</code> ),  <code>user/user.h</code>  for the C definition of  <code>sleep</code>  callable from a user program, and  <code>user/usys.s</code>  for the assembler code that jumps from user code into the kernel for  <code>sleep</code> .</li><li><code>main</code>  should call  <code>exit(0)</code>  when it is done.</li><li>Add your  <code>sleep</code>  program to  <code>UPROGS</code>  in Makefile; once you’ve done that,  <code>make qemu</code>  will compile your program and you’ll be able to run it from the xv6 shell.</li><li>Look at Kernighan and Ritchie’s book <span class='p green'>The C programming language (second edition)</span>(K&amp;R) to learn about C.</li></ul><p>Run the program from the xv6 shell:</p><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">make qemu</span></span><br><span class=\"line\">...</span><br><span class=\"line\">init: starting sh</span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">sleep</span> 10</span></span><br><span class=\"line\">(nothing happens for a little while)</span><br><span class=\"line\"><span class=\"meta prompt_\">$</span></span><br></pre></td></tr></table></figure><p>Your solution is correct if your program pauses when run as shown above. Run  <code>make grade</code>  to see if you indeed pass the sleep tests.<br>Note that  <code>make grade</code>  runs all tests, including the ones for the assignments below. If you want to run the grade tests for one assignment, type:</p><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">./grade-lab-util <span class=\"built_in\">sleep</span></span></span><br></pre></td></tr></table></figure><p>This will run the grade tests that match “sleep”. Or, you can type:</p><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">make GRADEFLAGS=<span class=\"built_in\">sleep</span> grade</span></span><br></pre></td></tr></table></figure><p>which does the same.</p></div>\n              </div>\n            </details>\n<details class=\"folding-tag\" blue><summary> code </summary>\n              <div class='content'>\n              <figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;kernel/types.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;user/user.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> *argv[])</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(argc != <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">fprintf</span>(<span class=\"number\">2</span>, <span class=\"string\">&quot;must only 1 argument for sleep\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> sleeptime = atoi(argv[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;nothing happens for %d seconds\\n&quot;</span>, sleeptime);</span><br><span class=\"line\">    sleep(sleeptime);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n              </div>\n            </details><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"lab:xv6-and-unix-utilities-3\"><details class=\"folding-tag\" blue><summary> requirement </summary>\n              <div class='content'>\n              <div class=\"note blue icon-padding simple\"><i class=\"note-icon fas fa-bullhorn\"></i><p>Write a program that uses UNIX system calls to “ping-pong” abyte between two processes over a pair of pipes, one for each direction. The parent should send a byte to the child; the child should print “<pid>:received ping”, where <pid> is its process ID, write the byte on the pipe to the parent, and exit; the parent should read the byte from the child, print “<pid>:received pong”, and exit. Your solution should be in the file  <code>user/pingpong.c</code></p></div><div class=\"note success simple\"><p>Some hints:</p><ul><li>Use  <code>pipe</code>  to create a pipe.</li><li>Use  <code>fork</code>  to create a child.</li><li>Use  <code>read</code>  to from a pipe, and  <code>write</code>  to a pipe.</li><li>Use  <code>getpid</code>  to find the process ID of the calling process.</li><li>Add the program to `UPROGS’ in Makefile.</li><li>User programs on xv6 have a limited set of library functions available to them. You can see the list in  <code>user/user.h</code> ; the source (other than for system calls) is in  <code>user/ulib.c, user/printf.c,</code>  and  <code>user/umalloc.c</code> .</li></ul><p>Run the program from the xv6 shell and it should produce the following output:</p><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">make qemu</span></span><br><span class=\"line\">...</span><br><span class=\"line\">init: starting sh</span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">pingpong</span></span><br><span class=\"line\">4: received ping</span><br><span class=\"line\">3: received pong</span><br><span class=\"line\"><span class=\"meta prompt_\">$</span></span><br></pre></td></tr></table></figure><p>Your solution is correct if your program exchanges a byte between two processes and produces output as shown above.</p></div>\n              </div>\n            </details>\n<details class=\"folding-tag\" blue><summary> code </summary>\n              <div class='content'>\n              <div class=\"note success simple\"><p>首先，很明显，我们需要两条管道传递信息。<br>对于管道传参  <code>int pipefd[2]</code> ， <code>pipefd[0]</code>  为管道读端， <code>pipefd[1]</code>  为管道写端。<br>而且读取成功的情况下， <code>pipe</code>  函数会返回读取到的字节数。<br>记得使用 <code>fork</code>  创建子进程，以及使用 <code>read, write, close</code>  对管道进行操作。</p></div><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;kernel/types.h&quot;</span>                                 </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;user/user.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> fd1[<span class=\"number\">2</span>],fd2[<span class=\"number\">2</span>];</span><br><span class=\"line\">    <span class=\"type\">char</span> buffer[] = &#123;<span class=\"string\">&#x27;X&#x27;</span>&#125;;</span><br><span class=\"line\">    pipe(fd1);</span><br><span class=\"line\">    pipe(fd2);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(fork() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        close(fd1[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        close(fd2[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(read(fd1[<span class=\"number\">0</span>], buffer, <span class=\"keyword\">sizeof</span>(buffer)) != <span class=\"keyword\">sizeof</span>(buffer)) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;a--&gt;b read error!\\n&quot;</span>);</span><br><span class=\"line\">            <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d: received ping\\n&quot;</span>, getpid());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(write(fd2[<span class=\"number\">1</span>], buffer, <span class=\"keyword\">sizeof</span>(buffer)) != <span class=\"keyword\">sizeof</span>(buffer)) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;b--&gt;a write error!\\n&quot;</span>);</span><br><span class=\"line\">            <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        close(fd1[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        close(fd2[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(write(fd1[<span class=\"number\">1</span>], buffer, <span class=\"keyword\">sizeof</span>(buffer)) != <span class=\"keyword\">sizeof</span>(buffer)) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;a--&gt;b write error!\\n&quot;</span>);</span><br><span class=\"line\">            <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(read(fd2[<span class=\"number\">0</span>], buffer, <span class=\"keyword\">sizeof</span>(buffer)) != <span class=\"keyword\">sizeof</span>(buffer)) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;b--&gt;a read error!\\n&quot;</span>);</span><br><span class=\"line\">            <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d: received pong\\n&quot;</span>, getpid());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        wait(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n              </div>\n            </details><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"lab:xv6-and-unix-utilities-4\"><details class=\"folding-tag\" blue><summary> requirement </summary>\n              <div class='content'>\n              <div class=\"note blue icon-padding simple\"><i class=\"note-icon fas fa-bullhorn\"></i><p>Write a concurrent version of prime sieve using pipes. This idea is due to Doug Mcllroy, inventor of Unix pipes. The picture halfway down <a href=\"http://swtch.com/~rsc/thread/\">this page</a> and the surrounding text explain how to do it. Your solution should be in the file  <code>user/primes.c</code> .</p></div><div class=\"note success simple\"><p>Your goal is to use  <code>pipe</code>  and  <code>fork</code>  to set up the pipeline. The first process feeds the numbers 2 through 35 into the pipeline. For each prime number, you will arrange to create one process that reads from its left neighbor over a pipe and writes to its right neighbor over another pipe. Since xv6 has limited number of file descriptors and processes, the first process can stop at 35.<br>Some hints:</p><ul><li>Be careful to close file descriptors that a process doesn’t need, because otherwise your program will run xv6 out of resources before the first process reaches 35.</li><li>Once the first process reaches 35, it should wait until the entire pipeline terminates, including all children, grandchildren, &amp;c. Thus the main primes process should only exit after all the output has been printed, and after all the other primes processes have exited.</li><li>Hint:  <code>read</code>  returns zero when the write-side of a pipe is closed.</li><li>It’s simplest to directly write 32-bit (4-byte)  <code>int</code> s to the pipes, rather than using formatted  <code>ASCII I/O</code> .</li><li>You should create the processes in the pipeline only as they are needed.</li><li>Add the program to  <code>UPROGS</code>  in Makefile.</li></ul><p>Your solution is correct if it implements a pipe-based sieve and produces the following output:</p><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">make qemu</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">primes</span></span><br></pre></td></tr></table></figure></div>\n              </div>\n            </details>\n<details class=\"folding-tag\" blue><summary> code </summary>\n              <div class='content'>\n              <div class=\"note success simple\"><p>这个实验的关键是利用 <code>pipe</code>  和 <code>fork</code> ，详细思想请看上个 <code>note</code>  给出的链接。<br>主要思想就是保证管道头部的数字为素数并删除在管道中是该数字倍数的数，其余的数写入下一个管道，如此反复。</p></div><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;kernel/types.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;user/user.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">func</span><span class=\"params\">(<span class=\"type\">int</span>* input, <span class=\"type\">int</span> num)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(num == <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> p[<span class=\"number\">2</span>],i;</span><br><span class=\"line\">    <span class=\"type\">int</span> prime = *input;</span><br><span class=\"line\">    <span class=\"type\">int</span> temp;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;prime %d\\n&quot;</span>, input);</span><br><span class=\"line\">    pipe(p);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(fork() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; num; i++) &#123;</span><br><span class=\"line\">            temp = *(input+i);</span><br><span class=\"line\">            write(p[<span class=\"number\">1</span>], (<span class=\"type\">char</span>*)(&amp;temp), <span class=\"number\">4</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    close(p[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(fork() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> counter = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">char</span> buffer[<span class=\"number\">4</span>];</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(read(p[<span class=\"number\">0</span>], buffer, <span class=\"number\">4</span>) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            temp = *((<span class=\"type\">int</span>*)buffer);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(temp % prime != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                *input = temp;</span><br><span class=\"line\">                input += <span class=\"number\">1</span>;</span><br><span class=\"line\">                counter++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        func(input - counter, counter);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    wait(<span class=\"number\">0</span>);</span><br><span class=\"line\">    wait(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;   </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> input[<span class=\"number\">34</span>];</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>( ; i &lt; <span class=\"number\">34</span>; i++) &#123;</span><br><span class=\"line\">        input[i] = i + <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    func(input, <span class=\"number\">34</span>);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;   </span><br></pre></td></tr></table></figure>\n              </div>\n            </details><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"lab:xv6-and-unix-utilities-5\"><details class=\"folding-tag\" blue><summary> requirement </summary>\n              <div class='content'>\n              <div class=\"note blue icon-padding simple\"><i class=\"note-icon fas fa-bullhorn\"></i><p>Write a simple version of the UNIX find program: find all the files in a directory tree with a specific name. Your solution should be in the file  <code>user/find.c</code> .</p></div><div class=\"note success simple\"><p>Some hints:</p><ul><li>Look at  <code>user/ls.c</code>  to see how to read directories.</li><li>Use recursion to allow find to descend into sub-directories.</li><li>Don’t recurse into “.” and “…”.</li><li>Changes to the file system persist across runs of qemu; to get a clean file system run  <code>make clean</code>  and then  <code>make qemu</code> .</li><li>You’ll need to use C strings. Have a look at K&amp;R (the C book), for example Section 5.5.</li><li>Note that == does not compare strings like in Python. Use strcmp() instead.</li><li>Add the program to  <code>UPROGS</code>  in Makefile.</li></ul><p>Your solution is correct if produces the following output (when the file system contains the files  <code>b, a/b</code>  and  <code>a/aa/b</code> ):</p><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">make qemu</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">echo</span> &gt; b</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">mkdir</span> a</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">echo</span> &gt; a/b</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">mkdir</span> a/aa</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">echo</span> &gt; a/aa/b</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">find . b</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$</span></span><br></pre></td></tr></table></figure></div>\n              </div>\n            </details>\n<details class=\"folding-tag\" blue><summary> code </summary>\n              <div class='content'>\n              <div class=\"note success simple\"><p>根据提示，我们可以根据 <code>ls.c</code>  文件编写 <code>find.c</code>  文件。<br>find 和 ls 的异同</p><ul><li>find 需要找到指定目录中所有文件名为 filename 的文件，并打印路径 + 文件名</li><li>ls 打印出指定目录中的所有目录项</li><li>都需要输入 <code>path</code>  参数</li><li>都需要判断 <code>path</code>  参数所指向的文件类型</li><li>都需要遍历目录项并读取目录项的名字</li><li>find 还需要给定 <code>filename</code>  参数</li><li>find 需要递归遍历指定目录中的所有子目录</li></ul><p>因此，我们实现 find 需要在 ls 的基础上添加递归遍历子目录并查找指定文件名的操作，同时需要忽略掉 <code>.</code> 、 <code>..</code> ，防止重复递归。</p></div><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;kernel/types.h&quot;</span>                                 </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;kernel/stat.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;kernel/fs.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;user/user.h&quot;</span></span></span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"type\">char</span>* <span class=\"title function_\">fmtname</span><span class=\"params\">(<span class=\"type\">char</span> *path)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">char</span> buf[DIRSIZ + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"type\">char</span> *p;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(p = path + <span class=\"built_in\">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class=\"string\">&#x27;/&#x27;</span>; p--);            </span><br><span class=\"line\">    p++;    </span><br><span class=\"line\">            </span><br><span class=\"line\">    memmove(buf, p, <span class=\"built_in\">strlen</span>(p) + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> buf;</span><br><span class=\"line\">&#125;       </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">eq_print</span><span class=\"params\">(<span class=\"type\">char</span> *fileName, <span class=\"type\">char</span> *findName)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">strcmp</span>(fmtname(fileName), findName) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n&quot;</span>, fileName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;   </span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">find</span><span class=\"params\">(<span class=\"type\">char</span> *path, <span class=\"type\">char</span>* name)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> buf[<span class=\"number\">512</span>], *p;</span><br><span class=\"line\">    <span class=\"type\">int</span> fd;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dirent</span> <span class=\"title\">de</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">stat</span> <span class=\"title\">st</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>((fd = open(path, <span class=\"number\">0</span>)) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">fprintf</span>(<span class=\"number\">2</span>, <span class=\"string\">&quot;find: connot open %s\\n&quot;</span>, path);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(fstat(fd, &amp;st) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">fprintf</span>(<span class=\"number\">2</span>, <span class=\"string\">&quot;find: connot stat %s\\n&quot;</span>, path);</span><br><span class=\"line\">        close(fd);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(st.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> T_FILE:</span><br><span class=\"line\">        eq_print(path, name);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> T_DIR:</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">strlen</span>(path) + <span class=\"number\">1</span> + DIRSIZ +<span class=\"number\">1</span> &gt; <span class=\"keyword\">sizeof</span> buf) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;find: path too long\\n&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">strcpy</span>(buf, path);</span><br><span class=\"line\">        p = buf + <span class=\"built_in\">strlen</span>(buf);</span><br><span class=\"line\">        *p++ = <span class=\"string\">&#x27;/&#x27;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(read(fd, &amp;de, <span class=\"keyword\">sizeof</span>(de)) == <span class=\"keyword\">sizeof</span>(de)) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(de.inum == <span class=\"number\">0</span> || de.inum == <span class=\"number\">1</span> || <span class=\"built_in\">strcmp</span>(de.name, <span class=\"string\">&quot;.&quot;</span>) == <span class=\"number\">0</span> || <span class=\"built_in\">strcmp</span>(de.name, <span class=\"string\">&quot;..&quot;</span>) == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            memmove(p, de.name, <span class=\"built_in\">strlen</span>(de.name));</span><br><span class=\"line\">            p[<span class=\"built_in\">strlen</span>(de.name)] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            find(buf, name);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    close(fd);   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> *argv[])</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(argc != <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;please input: find &lt;path&gt; &lt;fileName&gt;\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    find(argv[<span class=\"number\">1</span>], argv[<span class=\"number\">2</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n              </div>\n            </details><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"lab:xv6-and-unix-utilities-6\"><details class=\"folding-tag\" blue><summary> requirement </summary>\n              <div class='content'>\n              <div class=\"note blue icon-padding simple\"><i class=\"note-icon fas fa-bullhorn\"></i><p>Write a simple version of the UNIX xargs program: its arguments describe a command to run, it reads lines from the standard input, and it runs the command for each line, appending the line to the command’s arguments. Your solution should be in the file  <code>user/xargs.c</code> .</p></div><div class=\"note success simple\"><p>The following example illustrates xarg’s behavior:</p><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">echo</span> hello too | xargs <span class=\"built_in\">echo</span> <span class=\"built_in\">bye</span></span></span><br><span class=\"line\">bye hello too</span><br><span class=\"line\"><span class=\"meta prompt_\">$</span></span><br></pre></td></tr></table></figure><p>Note that the command here is “echo bye” and the additional arguments are “hello too”, making the command “echo bye hello too”, which outputs “bye hello too”.<br>Please note that xargs on UNIX makes an optimization where it will feed more than argument to the command at a time.<br>We don’t expect you to make this optimization. To make xargs on UNIX behave the way we want it to for this lab, please run it with the -n option set to 1. For instance</p><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">(<span class=\"built_in\">echo</span> 1 : <span class=\"built_in\">echo</span> 2) | xargs -n 1 <span class=\"built_in\">echo</span></span></span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure><p>Some hints:</p><ul><li>Use  <code>fork</code>  and  <code>exec</code>  to invoke the command on each line of input. Use  <code>wait</code>  in the parent to wait for the child to complete the command.</li><li>To read individual lines of input, read a character at a time until a newline (’\\n’) appears.</li><li>lernel/param.h declars MAXARG, which may be useful if you need to declare an argv array.</li><li>Add the program to  <code>UPROGS</code>  in Makefile.</li><li>Changes to the file system persist across runs of qemu; to get a clean file system run make clean and then make qemu.</li></ul><p>xargs, find, and grep combine well:</p><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">find . b | xargs grep hello</span></span><br></pre></td></tr></table></figure><p>will run “grep hello” on each file named b in the directories below “.”.<br>To test your solution for xargs, run the shell script <a href=\"http://xargstest.sh\">xargstest.sh</a>. Your solution is correct if it produces the following output:</p><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">make qemu</span></span><br><span class=\"line\">...</span><br><span class=\"line\">init: starting sh</span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">sh &lt; xargstest.sh</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">$ $ $ $ $ hello</span></span><br><span class=\"line\">hello</span><br><span class=\"line\">hello</span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">$</span></span><br></pre></td></tr></table></figure><p>You may have to go back and fix bugs in your find program. The output has many $ because the xv6 shell doesn’t realize it is processing commands from a file instead of from the console, and prints a $ for each command in the file.</p></div>\n              </div>\n            </details>\n<details class=\"folding-tag\" blue><summary> code </summary>\n              <div class='content'>\n              <div class=\"note success simple\"><p><code>xargs</code>  命令是一种管道命令， <code>|</code>  即为管道，他会将管道前面的命令的输出作为后面命令的标准输入。</p></div><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;kernel/types.h&quot;</span>                                 </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;kernel/stat.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;user/user.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;kernel/param.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>* argv[])</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">char</span>* exec_argv[MAXARG], buf[<span class=\"number\">512</span>];</span><br><span class=\"line\">    <span class=\"type\">int</span> len = <span class=\"number\">0</span>, idx = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i =<span class=\"number\">1</span>; i &lt; argc; ++i)</span><br><span class=\"line\">        exec_argv[i - <span class=\"number\">1</span>] = argv[i];</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        idx = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>((len = read(<span class=\"number\">0</span>, buf + idx, <span class=\"keyword\">sizeof</span>(<span class=\"type\">char</span>))) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(buf[idx] == <span class=\"string\">&#x27;\\n&#x27;</span>) &#123;</span><br><span class=\"line\">                buf[idx] = <span class=\"string\">&#x27;\\0&#x27;</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ++idx;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(len == <span class=\"number\">0</span> &amp;&amp; idx == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        exec_argv[argc - <span class=\"number\">1</span>] = buf;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(fork() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            exec(exec_argv[<span class=\"number\">0</span>], exec_argv);</span><br><span class=\"line\">            <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            wait(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n              </div>\n            </details><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div><div class=\"tab-item-content\" id=\"lab:xv6-and-unix-utilities-7\"><details class=\"folding-tag\" blue><summary> requirement </summary>\n              <div class='content'>\n              <ul><li>Write an uptime program that prints the uptime in terms of ticks using the  <code>uptime</code>  system call.(easy)</li><li>Support regular expressions in name matching for  <code>find. grep.c</code>  has some primitive support for regular expressions.(easy)</li><li>The xv6 shell(user/sh.c) is just another user program and you can improve it. It is a minimal shell and lacks many features found in real shell. For example, modify the shell to not print a $ when processing shell commands from a file(moderate), modify the shell to support wait(easy), modify the shell to support lists of commands, separated by “;”(moderate), modify the shell to support sub-shells by implementing “(” and “)” (moderate), modify the shell to support tab completion(easy), modify the shell to keep a history of passed shell commands(moderate), or anything else you would like your shell to do.(If you are very ambitious, you may have to modify the kermel to support the kernel features you need; xv6 doesn’t support mach.)</li></ul>\n              </div>\n            </details><button type=\"button\" class=\"tab-to-top\" aria-label=\"scroll to top\"><i class=\"fas fa-arrow-up\"></i></button></div></div></div>",
            "tags": [
                "MIT 6.1810",
                "操作系统"
            ]
        }
    ]
}