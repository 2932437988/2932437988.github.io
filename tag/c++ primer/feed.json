{
    "version": "https://jsonfeed.org/version/1",
    "title": "潇十七 • All posts by \"c++ primer\" tag",
    "description": "可生活不是电影，我也少了点运气",
    "home_page_url": "https://x-17.top",
    "items": [
        {
            "id": "https://x-17.top/2022/10/15/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%89)/",
            "url": "https://x-17.top/2022/10/15/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%89)/",
            "title": "C++学习笔记(三)",
            "date_published": "2022-10-15T06:01:59.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p>接下来是本书第二章的剩余内容</p>\n</blockquote>\n<h1 id=\"1-const限定符\"><a class=\"markdownIt-Anchor\" href=\"#1-const限定符\">#</a> 1. const 限定符</h1>\n<p>如果我们想定义一种值不要被随便改变的变量，就可以用 const 对变量类型加以限定，并且一旦创建后它的值就不能在改变，所以，我们必须初始化这个 const 对象。<br>\n默认状态下，const 对象仅在文件中有效。我们默认在多个文件中出现了同名的 const 变量时，其实等同于在不同的文件中分别定义了独立的变量。<br>\n如果我们想让 const 对象只在一个文件中定义它同时在其他文件中声明并使用它，只要在声明及定义时都添加 extern 关键字就可以了。</p>\n<h1 id=\"2-const的引用\"><a class=\"markdownIt-Anchor\" href=\"#2-const的引用\">#</a> 2. const 的引用</h1>\n<p>还记得上一篇文章提到的引用吗，（忘了回去看看），我们可以把引用绑定到 const 对象上，就和其他的对象一样，我们称之为对常量的引用（reference to const）。与普通引用的区别是，对常量的引用不能被用作修改它所绑定的对象。</p>\n<blockquote>\n<p>常量引用是我们对于 const 引用的简称，虽然这简称挺形象，但务必记住这只是简称，毕竟常量引用严格而言是不存在的，因为引用不是一个对象，我们没法让引用本身恒定不变。事实上，由于 C++ 语言并不允许随意改变引用所绑定的对象，从这一定义上理解所有的引用又都算是常量。引用的对象是常量还是非常量可以决定其所能参与的操作，却无论如何都不会影响到引用和对象的绑定关系本身。</p>\n</blockquote>\n<p>前面说过，引用的类型必须与其所引用对象的类型一致，但有两个例外。第一种例外情况就是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。<br>\n我们讨论为何会发生这种例外。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">double</span> dval = <span class=\"number\">3.14</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> &amp;ri = dval;</span><br></pre></td></tr></table></figure>\n<p>如上的代码，编译器为了确保让 ri 绑定一个整数，把它变成了下面这样。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">double</span> dval = <span class=\"number\">3.14</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> temp = dval;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> &amp;ri = temp;</span><br></pre></td></tr></table></figure>\n<p>这种情况下，ri 绑定了一个临时量（temporary）对象。所谓临时量对象就是编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象，我们也将其称为临时量。<br>\n当然，如果 ri 不是常量，没有 const 限制，那么我们就允许通过 ri 对其所引用的对象进行赋值修改，但是我们实际绑定的只是一个临时量，没有人想要修改那个临时量，你无法通过 ri 修改原本的 dval 的值，因而这样做毫无意义，C++ 语言也自然把这种行为归为非法。<br>\n请记住，对 const 的引用可能引用一个并非 const 的对象，我们无法通过 const 引用改变所绑定的变量值，但是其他途径仍是能修改它的。</p>\n<h1 id=\"3-指针和const\"><a class=\"markdownIt-Anchor\" href=\"#3-指针和const\">#</a> 3. 指针和 const</h1>\n<p>与引用一样，也可以令指针指向常量或非常量，指向常量的指针（pointer to const）不能用于改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针。<br>\n同样，之前说过，指针的类型必须与其所指对象的类型一致，但是有两个例外。第一种例外情况就是允许令一个指向常量的指针指向一个非常量对象。<br>\n并且指向常量的指针也没有规定其所指的对象必须是一个常量。所谓指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变。</p>\n<blockquote>\n<p>也可以这么理解，常量引用和常量指针它们自认为指向了常量，所以不去改变所引用或所指对象的值。</p>\n</blockquote>\n<p>我们还需要记得，指针本质上是对象，因此我们允许把指针本身定为常量。常量指针（const pointer）必须初始化，而且一旦初始化完成，它的值就不能再改变了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">double</span> pi = <span class=\"number\">3.14</span>; <span class=\"comment\">// 常量</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">double</span> *cptr = &amp;pi; <span class=\"comment\">// 指向常量的指针</span></span><br><span class=\"line\"><span class=\"type\">int</span> errNumb = <span class=\"number\">0</span>; <span class=\"comment\">// 变量</span></span><br><span class=\"line\"><span class=\"type\">int</span> *<span class=\"type\">const</span> cuErr = &amp;errNumb; <span class=\"comment\">// 常量指针，或者说是常量的指针类型</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">double</span> *<span class=\"type\">const</span> pip = &amp;pi; <span class=\"comment\">// 指向常量的常量指针</span></span><br></pre></td></tr></table></figure>\n<p>根据上面的代码，你应该区分清楚它们的区别，尤其是指向常量的指针和是常量的指针类型。百度上对常量指针和指针常量的解读非常模糊混乱，看到了如下解读方法。</p>\n<blockquote>\n<p>从右往左读，首先是标识符，然后加上 <code>is a</code> ，之后遇到 <code>*</code>  就替换为 <code>point to</code> ，其余的关键字照抄，这样得到的一句英文的确可以较好地说明这个标识符亦或是变量的类型。</p>\n</blockquote>\n<h1 id=\"4-顶层const\"><a class=\"markdownIt-Anchor\" href=\"#4-顶层const\">#</a> 4. 顶层 const</h1>\n<p>就像上面所说的，由于指针本身既是对象，又可以指向对象，因此指针本身是否为常量以及指针所指向的对象是否为常量就是两个相互独立的问题。<br>\n用名词顶层 const（top-level const）表示指针本身是个常量。<br>\n用名词底层 const（low-level const）表示指针所指的对象是一个常量。<br>\n当然，顶层 const 可以表示任意对象是常量，更通俗地说就是，任意本身是常量的对象就是顶层 const。<br>\n而底层 const 只与指针和引用等复合类型的基本类型部分有关。<br>\n所以，指针类型可以既是顶层 const 又是底层 const，这是特殊于其他类型的。<br>\n当执行拷贝操作时，顶层 const 不受什么影响；而底层 const 要求拷入和拷出的对象必须具有相同的底层 const 资格，或者两个对象的数据类型能够转换。一般而言，非常量可以转换成常量，反之则不行。</p>\n<h1 id=\"5-constexpr和常量表达式\"><a class=\"markdownIt-Anchor\" href=\"#5-constexpr和常量表达式\">#</a> 5. constexpr 和常量表达式</h1>\n<p>常量表达式（const expression）是指值不会改变并且在编译过程就能得到计算结果的表达式。显然，字面值属于常量表达式，用常量表达式初始化的 const 对象也是常量表达式。一个对象（或表达式）是不是常量表达式由它的数据类型和初始值共同决定。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> max_files = <span class=\"number\">20</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> limite = max_files + <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> staff_size = <span class=\"number\">27</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> sz = <span class=\"built_in\">get_size</span>();</span><br></pre></td></tr></table></figure>\n<p>尽管 staff_size 的初始值是个字面值常量，但由于它的数据类型只是一个普通 int 而非 const int，所以它不属于常量表达式。另一方面，尽管 sz 本身是一个常量，但它的具体值直到运行时才能获取到，所以也不是常量表达式。</p>\n<p>为了更好地分辨一个初始值到底是不是常量表达式，C++11 规定，允许将变量声明为 constexpr 类型以便由编译器来验证变量的值是否是一个常量表达式。声明为 constexpr 的变量一定是一个常量，而且必须用常量表达式初始化。<br>\n并且，你可以用 constexpr 定义一个特殊的函数，它应该足够简单以使得编译时就可以计算其结果，这样就可以用 constexpr 函数去初始化 constexpr 变量。</p>\n<p>常量表达式的值需要在编译时就得到计算，因此对声明 constexpr 时用到的类型必须有所限制。因为这些类型比较简单，值也显而易见、容易得到，就把它们称为字面值类型（literal type）。<br>\n目前为止，算术类型、引用和指针都属于字面值类型。<br>\n尽管指针和引用都能定义成 constexpr，但他们的初始值却受到严格限制。一个 constexpr 指针的初始值必须是 nullptr 或者 0，或者是存储于某个固定地址中的对象。<br>\n函数体内定义的变量一般来说并非存放在固定地址中，因此 constexpr 指针不能指向这样的变量；当然，函数还允许定义一类有效范围超出函数本身的变量，这类变量和定义在函数体之外的变量一样也有固定地址，因此 constexpr 引用 / 指针可以绑定 / 指向这样的变量。</p>\n<p>请注意，在 constexpr 声明中如果定义了一个指针，限定符 constexpr 仅对指针有效，与指针所指的对象无关。</p>\n<h1 id=\"6-处理类型\"><a class=\"markdownIt-Anchor\" href=\"#6-处理类型\">#</a> 6. 处理类型</h1>\n<p>由于程序复杂性的提升，程序中用到的类型也越来越复杂。</p>\n<ul>\n<li>一些类型难于拼写，既难记又容易写错，还无法明确体现其真实目的和含义。</li>\n<li>搞不清到底需要什么类型，程序员不得不通过程序上下文寻求帮助。</li>\n</ul>\n<p>类型别名（type alias）因此而产生，它是一个名字，是某种类型的同义词。它让复杂的类型名字变得简单明了、易于理解和使用，还有助于程序员清楚地知道使用该类型的真实目的。可通过以下两种方法定义类型别名：</p>\n<ul>\n<li>关键字 typedef<br>\n 其中关键字 typedef 作为声明语句中的基本数据类型的一部分出现。含有 typedef 的声明语句定义的不再是变量而是类型别名。和以前的声明语句一样，这里的声明符也可以包含类型修饰，从而也能由基本数据类型构造出符合类型。</li>\n<li>别名声明（alias declaration）<br>\n这种方法用关键字 using 作为别名声明的开始，其后紧跟别名和等号，其作用是把等号左侧的名字规定成等号右侧类型的别名。<br>\n类型别名和类型的名字等价，只要是类型的名字能出现的地方，就能使用类型别名。</li>\n</ul>\n<h1 id=\"7-auto类型说明符\"><a class=\"markdownIt-Anchor\" href=\"#7-auto类型说明符\">#</a> 7. auto 类型说明符</h1>\n<p>为了解决在声明变量时得知表达式类型的问题，C++11 引入了 auto 类型说明符，它能让编译器代替我们去分析表达式所属的类型。和之前那些只对应一种特定类型的说明符不同，auto 让编译器通过初始值来推算变量的类型。显然，auto 定义的变量必须有初始值。<br>\n可以使用 auto 在一条语句中声明多个变量，但是该语句中所有变量的初始基本数据类型都必须一样。</p>\n<ul>\n<li>首先，使用引用实际是使用引用的对象，特别是当引用被用作初始值时，真正参与初始化的其实是引用对象的值。此时编译器以引用对象的类型作为 auto 的类型。</li>\n<li>其次，auto 一般会忽略掉顶层 const，同时底层 const 则会保留下来。</li>\n<li>如果希望推断出的 auto 类型是一个顶层 const，须明确指出。</li>\n<li>还可以将引用的类型设为 auto，并适用于原初始化规则。</li>\n<li>设置一个类型为 auto 的引用时，初始值中的顶层常量属性仍然保留。和往常一样，如果我们给初始值绑定一个引用，则此时的常量就不是顶层常量了。</li>\n<li>要在一条语句中定义多个变量，切记符号 &amp; 和 * 只从属于某个声明符，而非基本数据类型的一部分，因此初始值必须是同一种类型。</li>\n</ul>\n<h1 id=\"8-decltype类型识别符\"><a class=\"markdownIt-Anchor\" href=\"#8-decltype类型识别符\">#</a> 8. decltype 类型识别符</h1>\n<p>有时呢，我们希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。为了满足这一要求，C++11 引入了第二种类型说明符 decltype，它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。<br>\n如果 decltype 使用的表达式是一个变量，则 decltype 返回该变量的类型（包括顶层 const 和引用在内）。<br>\n需要指出的是，引用从来都作为其所指对象的同义词出现，只有用在 decltype 处是一个例外。<br>\n如下</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> i =<span class=\"number\">42</span>, *p = &amp;i, &amp;r = i;</span><br><span class=\"line\"><span class=\"keyword\">decltype</span>(r + <span class=\"number\">0</span>) b;</span><br><span class=\"line\"><span class=\"keyword\">decltype</span>(*p) c;</span><br></pre></td></tr></table></figure>\n<p>因为 r 是一个引用，很明显 decltype® 结果是引用类型，如果想要结果类型是 r 所引用的类型，可以把 r 作为表达式的一部分，如 r+0，我们就可以得到一个具体值而非引用。<br>\n如果表达式是解引用（即 * ）操作，则 decltype 将得到引用类型，就如上代码块最后一句代码结果类型就是 int&amp;，而非 int。<br>\n对于变量 v，decltype ((v)) 的结果永远是引用，而 decltype (v) 结果只有当 v 本身是引用时才是引用。</p>\n<h1 id=\"9-自定义数据结构\"><a class=\"markdownIt-Anchor\" href=\"#9-自定义数据结构\">#</a> 9. 自定义数据结构</h1>\n<p>这里我们使用 struct 定义一个类。<br>\n以关键字 struct 开始，紧跟着类名和类体（类体部分可以为空），类体由花括号包围形成了一个新的作用域，类内部定义的名字必须唯一，但是可以与类外定义的名字重复。类体右侧表示结束的花括号后必须写一个分号，因为类体后可以紧跟变量名以示对该类型对象的定义，所以分号必不可少。<br>\n不建议直接在类体后定义类型对象，这样无异于把两种不同实体的定义混在了一条语句中。<br>\n类体定义类的成员，我们的类只有数据成员（data member），类的数据成员定义了类的对象的具体内容，每个对象有一份自己的数据成员拷贝，修改一个对象的数据成员，不会影响其他对象。<br>\nC++11 规定，可以为数据成员提供一个类内初始值（in-class initializer）用于初始化数据成员，没有初始值的成员将被默认初始化。初始化规则和之前类似，但不能使用圆括号。<br>\n当然，之后会介绍的 class，也会说明现在为何使用 struct。</p>\n<h1 id=\"10-预处理器\"><a class=\"markdownIt-Anchor\" href=\"#10-预处理器\">#</a> 10. 预处理器</h1>\n<p>为了让我们编写的类能被多个文件使用，需要编写自己的头文件，但我们写的头文件可能会导致使用该头文件的文件多次重复引入同样的头文件，因此我们要对自制头文件做适当处理，使其遇到多次包含的情况也能安全和正常地工作。<br>\n这就要提到预处理器（preprocessor）技术了，它由 C 语言继承而来，预处理器是在编译之前执行的一段程序，可以部分的改变我们所写的程序。就如之前用到的一项预处理器功能 #include，当预处理器看到 #include 标记时就会用指定的头文件的内容代替 #include。<br>\nC++ 程序还会用到的一项预处理功能是头文件保护符（header guard），头文件保护符依赖于预处理变量。预处理变量有两种状态：已定义和未定义。#define 指令把一个名字设定为预处理变量，另外两个指令则分别检查某个指定的预处理变量是否已经定义：#ifdef 当且仅当变量已定义时为真，#ifndef 当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直到遇到 #endif 指令为止。</p>\n<blockquote>\n<p>预处理变量无视 C++ 语言中关于作用域的规则。</p>\n</blockquote>\n<p>整个程序中的预处理变量包括头文件保护符必须唯一，通常基于头文件中类的名字来构建保护符的名字，以确保其唯一性。为了避免与程序中其他实体发生名字冲突，一般把预处理变量的名字全部大写。</p>\n<blockquote>\n<p>头文件即使还没有被包含在任何其他头文件中，也应该设置保护符。这很简单，只要养成习惯就好了，不必在意你的程序是否需要。</p>\n</blockquote>\n<h1 id=\"11-总结\"><a class=\"markdownIt-Anchor\" href=\"#11-总结\">#</a> 11. 总结</h1>\n<p>按照惯例，下面仍然是本章术语表总结。</p>\n<ul>\n<li>地址（address）</li>\n<li>别名声明（alias declaration）</li>\n<li>算数类型（arithmetic type）</li>\n<li>数组（array）</li>\n<li>auto</li>\n<li>基本类型（base type）</li>\n<li>绑定（bind）</li>\n<li>字节（byte）</li>\n<li>类成员（class member）</li>\n<li>复合类型（compound type）</li>\n<li>const</li>\n<li>常量指针（const pointer）</li>\n<li>常量引用（const reference）</li>\n<li>常量表达式（const expression）</li>\n<li>constexpr</li>\n<li>转换（convertsion）</li>\n<li>数据成员（data member）</li>\n<li>声明（declaration）</li>\n<li>声明符（declarator）</li>\n<li>decltype</li>\n<li>默认初始化（default initialization）</li>\n<li>定义（definition）</li>\n<li>转义序列（escape sequence）</li>\n<li>全局作用域（global scope）</li>\n<li>头文件保护符（header guard）</li>\n<li>标识符（identifier）</li>\n<li>类内初始符（in-class initializer）</li>\n<li>在作用域内（in scope）</li>\n<li>被初始化（initialized）</li>\n<li>内层作用域（inner scope）</li>\n<li>整型（integral type）</li>\n<li>列表初始化（list initialization）</li>\n<li>字面值（literal）</li>\n<li>局部作用域（local scope）</li>\n<li>底层 const（low-level const）</li>\n<li>成员（member）</li>\n<li>不可打印字符（nonprintable character）</li>\n<li>空指针（null pointer）</li>\n<li>nullptr</li>\n<li>对象（object）</li>\n<li>外层作用域（outer scope）</li>\n<li>指针（pointer）</li>\n<li>指向常量的指针（pointer to const）</li>\n<li>预处理器（preprocessor）</li>\n<li>预处理变量（preprocessor variable）</li>\n<li>引用（reference）</li>\n<li>对常量的引用（reference to const）</li>\n<li>作用域（scope）</li>\n<li>全局（global）</li>\n<li>类（class）</li>\n<li>命名空间（namespace）</li>\n<li>块（block）</li>\n<li>分离式编译（separate compilation）</li>\n<li>带符号类型（signed）</li>\n<li>字符串（string）</li>\n<li>struct</li>\n<li>临时值（temporary）</li>\n<li>顶层 const（top-level const）</li>\n<li>类型别名（type alias）</li>\n<li>类型检查（type checking）</li>\n<li>类型说明符（type specifier）</li>\n<li>typedef</li>\n<li>未定义（undefined）</li>\n<li>未初始化（uninitialized）</li>\n<li>无符号类型（unsigned）</li>\n<li>变量（variable）</li>\n<li>void *</li>\n<li>void 类型</li>\n<li>字（word）</li>\n<li>&amp; 运算符（&amp; operator）</li>\n<li>* 运算符（  * operator）</li>\n<li>#define</li>\n<li>#endif</li>\n<li>#ifdef</li>\n<li>#ifndef</li>\n</ul>\n<h1 id=\"12-读后感\"><a class=\"markdownIt-Anchor\" href=\"#12-读后感\">#</a> 12. 读后感？</h1>\n<p>第二章的内容相对于第一章读起来已经感到有些拗口了，一些定义的概念也并不是特别清晰，尤其有些定义在百度上解释的五花八门，这种反而感觉英文上对于其定义的解释更为贴切。第二章变量和基本类型可以说是 C++ 编程的基础吧，更复杂的结构等等都是由基础演化而来，我的笔记也并不全面，书上会有更为详尽的示例，但由于时间和精力最优的选择就是只做这种纯文字且没什么排版的文章记录，我也更容易坚持下来，如果你想有更深的了解，还是建议去读一读这本书，当然也可以对照我的记录，我对其中部分难以理解的定义给出了自己的理解或是用自己的话语描述，如有错误，欢迎指正。</p>\n",
            "tags": [
                "C++",
                "C++ Primer"
            ]
        },
        {
            "id": "https://x-17.top/2022/10/14/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/",
            "url": "https://x-17.top/2022/10/14/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/",
            "title": "C++学习笔记(二)",
            "date_published": "2022-10-14T00:55:33.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p>今天是第二章的内容，祝你好运，也祝我。</p>\n</blockquote>\n<h1 id=\"1-编程语言的特征\"><a class=\"markdownIt-Anchor\" href=\"#1-编程语言的特征\">#</a> 1. 编程语言的特征</h1>\n<p>常用的编程语言通常具备一组公共的语法特征，仅在特征的细节上有所区别。<br>\n大多数编程语言通过两种方式进一步补充其基本特征：</p>\n<ul>\n<li>赋予程序员自定义数据类型的权利，从而实现对语言的扩展</li>\n<li>将一些有用的功能封装成库函数提供给程序员</li>\n</ul>\n<p>与大多数编程语言一样，C++ 的对象类型决定了能对该对象进行的操作，一条表达式是否合法依赖于其中参与运算的对象的类型。C++ 是一种静态数据类型语言，它的类型检查发生在编译时。因此编译器必须知道程序中每一个变量对应的数据类型。</p>\n<h1 id=\"2-基本内置类型\"><a class=\"markdownIt-Anchor\" href=\"#2-基本内置类型\">#</a> 2. 基本内置类型</h1>\n<p>C++ 定义了一套包括算数类型（arithmetic type）和空类型（void）在内的基本数据类型。</p>\n<ul>\n<li>算数类型\n<ul>\n<li>整型（intergral type，包括字符和布尔类型在内）</li>\n<li>浮点型</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>C++：算数类型</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>类型</td>\n<td>含义</td>\n<td>最小尺寸</td>\n</tr>\n<tr>\n<td>bool</td>\n<td>布尔类型</td>\n<td>未定义</td>\n</tr>\n<tr>\n<td>char</td>\n<td>字符</td>\n<td>8 位</td>\n</tr>\n<tr>\n<td>wchar_t</td>\n<td>宽字符</td>\n<td>16 位</td>\n</tr>\n<tr>\n<td>char16_t</td>\n<td>Unicode 字符</td>\n<td>16 位</td>\n</tr>\n<tr>\n<td>char32_t</td>\n<td>Unicode 字符</td>\n<td>32 位</td>\n</tr>\n<tr>\n<td>short</td>\n<td>短整型</td>\n<td>16 位</td>\n</tr>\n<tr>\n<td>int</td>\n<td>整型</td>\n<td>16 位</td>\n</tr>\n<tr>\n<td>long</td>\n<td>长整型</td>\n<td>32 位</td>\n</tr>\n<tr>\n<td>long long</td>\n<td>长整型</td>\n<td>64 位</td>\n</tr>\n<tr>\n<td>float</td>\n<td>单精度浮点数</td>\n<td>6 位有效数字</td>\n</tr>\n<tr>\n<td>double</td>\n<td>双精度浮点数</td>\n<td>10 位有效数字</td>\n</tr>\n<tr>\n<td>long double</td>\n<td>扩展精度浮点数</td>\n<td>10 位有效数字</td>\n</tr>\n</tbody>\n</table>\n<p>布尔类型（bool）的取值是真（true）或者假（false）。<br>\nUnicode 是用于表示所有自然语言中字符的标准。<br>\n数据类型 long long 是在 C++11 中新定义的。</p>\n<h1 id=\"3-内置类型的机器实现\"><a class=\"markdownIt-Anchor\" href=\"#3-内置类型的机器实现\">#</a> 3. 内置类型的机器实现</h1>\n<p>计算机以比特序列存储数据，每个比特非 0 即 1。<br>\n大多数计算机以 2 的整数次幂个比特作为块来处理内存，可寻址的最小内存块称为 &quot;字节（byte）&quot;，存储的基本单元称为 &quot;字（word）&quot;，它通常由几个字节组成。在 C++ 语言中，一个字节要至少能容纳机器基本字符集中的字符。大多数机器的字节由 8 比特构成，字则由 32 或 64 比特构成，也就是 4 或 8 字节。大多数计算机将内存中的每个字节与一个数字（被称为 &quot;地址（address）&quot;）关联起来。</p>\n<h1 id=\"4-符号\"><a class=\"markdownIt-Anchor\" href=\"#4-符号\">#</a> 4. 符号</h1>\n<p>除去布尔类型以及扩展的字符型，其他整型可划分为</p>\n<ul>\n<li>带符号的（signed） 正数、负数、0</li>\n<li>无符号的（unsigned） 仅能表示大于等于 0 的值</li>\n</ul>\n<p>上面表格中的 int、short、long 和 long long 都是带符号的，只要在它们前面加上 unsigned 就可以得到无符号类型，其中，unsigned int 可以缩写为 unsigned。</p>\n<p>与其他整型不同，字符型被分为三种：</p>\n<ul>\n<li>char 实际会根据编译器 1 表现为如下两种中的一种</li>\n<li>signed char 8 比特理论上可表示 [-127,127]，实际上可表示 [-128,127]</li>\n<li>unsigned char 8 比特可表示 [0,255]</li>\n</ul>\n<p>来尝试预测下面的代码运行结果</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// test1</span></span><br><span class=\"line\"><span class=\"type\">unsigned</span> u = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> i = <span class=\"number\">-42</span>;</span><br><span class=\"line\">std::cout &lt;&lt; i + i &lt;&lt; std::endl;</span><br><span class=\"line\">std::cout &lt;&lt; u + i &lt;&lt; std::endl;</span><br><span class=\"line\"><span class=\"comment\">// test2</span></span><br><span class=\"line\"><span class=\"type\">unsigned</span> u1 = <span class=\"number\">42</span>, u2 = <span class=\"number\">10</span>;</span><br><span class=\"line\">std::cout &lt;&lt; u1 - u2 &lt;&lt; std::endl;</span><br><span class=\"line\">std::cout &lt;&lt; u2 - u1 &lt;&lt; std::endl;</span><br><span class=\"line\"><span class=\"comment\">// test3</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">10</span>; i &gt;= <span class=\"number\">0</span>; --i)</span><br><span class=\"line\">    std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class=\"line\"><span class=\"comment\">// test4</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">unsigned</span> u = <span class=\"number\">10</span>; u &gt;= <span class=\"number\">0</span>; --u)</span><br><span class=\"line\">    std::cout &lt;&lt; u &lt;&lt; std::endl;</span><br><span class=\"line\"><span class=\"comment\">// test5</span></span><br><span class=\"line\"><span class=\"type\">unsigned</span> u = <span class=\"number\">11</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (u &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    --u;</span><br><span class=\"line\">    std::cout &lt;&lt; u &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果你尝试运行了上面的代码，你应该会明白，不要混用带符号类型和无符号类型，你可以结合上面的示例代码和下面第六条的内容分析原因。</p>\n<h1 id=\"5-类型选择\"><a class=\"markdownIt-Anchor\" href=\"#5-类型选择\">#</a> 5. 类型选择</h1>\n<ul>\n<li>明确知晓数值不可能为负时，选用无符号类型</li>\n<li>使用 int 执行整数运算，如果数值超过了 int 的表示范围，选用 long long</li>\n<li>算术表达式中尽量不要使用 char 或 bool，机器间差异会导致不可知的问题。</li>\n<li>执行浮点数运算选用 double，因为 float 精度常常不够并且计算代价并不比 double 更低，而 long double 的精度一般情况下没有必要并且运行消耗不容忽视。</li>\n</ul>\n<h1 id=\"6-类型转换\"><a class=\"markdownIt-Anchor\" href=\"#6-类型转换\">#</a> 6. 类型转换</h1>\n<p>从一种给定的类型转换（convert）为另一种相关类型，你可以尝试如下示例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">bool</span> b = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> i = b;</span><br><span class=\"line\">i = <span class=\"number\">3.14</span>;</span><br><span class=\"line\"><span class=\"type\">double</span> pi = i;</span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">char</span> c = <span class=\"number\">-1</span>;</span><br><span class=\"line\"><span class=\"type\">signed</span> <span class=\"type\">char</span> c2 = <span class=\"number\">256</span>;</span><br></pre></td></tr></table></figure>\n<p>下面给出转换规则：</p>\n<ul>\n<li>当我们把一个非布尔类型的算数值赋给布尔类型时，初始值为 0 则结果为 false，否则结果为 true。</li>\n<li>当我们把一个布尔值赋给非布尔类型时，初始值为 false 则结果为 0，初始值为 true 则结果为 1。</li>\n<li>当我们把一个浮点数赋给整数类型时，进行近似处理，结果值仅保留浮点数中小数点之前的部分。</li>\n<li>当我们把一个整数值赋给浮点类型时，小数部分记为 0，。如果该整数所占的空间超过了浮点类型的容量，精度可能有损失。</li>\n<li>当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。</li>\n<li>当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的（undefined）。此时程序可能继续工作、崩溃或是生成垃圾数据。</li>\n</ul>\n<h1 id=\"7-避免无法预知和依赖于实现环境的行为\"><a class=\"markdownIt-Anchor\" href=\"#7-避免无法预知和依赖于实现环境的行为\">#</a> 7. 避免无法预知和依赖于实现环境的行为</h1>\n<p>无法预知的行为源于编译器无须（有时无法）检测的错误。即使代码编译通过了，如果程序执行了一条未定义的表达式，仍有可能产生错误。但，某些情况 / 编译器下，含有无法预知行为的程序也能正确执行，但无法保证它在其他编译器，其他测试用例或再次运行仍能正常运行。所以，程序应避免依赖于实现环境的行为，即不可移植的（nonportable）程序，并且这类代码定位错误是很困难的。</p>\n<h1 id=\"8-字面值常量literal\"><a class=\"markdownIt-Anchor\" href=\"#8-字面值常量literal\">#</a> 8. 字面值常量（literal）</h1>\n<ul>\n<li>整型和浮点型字面值\n<ul>\n<li>整型字面值<br>\n如果一个字面值连与之关联的最大的数据类型都放不下，将产生错误。类型 short 没有对应的字面值。\n<ul>\n<li>十进制数<br>\n默认是有符号类型。正如我们所常见的，但严格来说它不会是负数，确切地说是对字面值取负值。</li>\n<li>八进制数<br>\n以 0 开头的整数</li>\n<li>十六进制数<br>\n以 0x 开头的整数</li>\n</ul>\n</li>\n<li>浮点型字面值<br>\n默认是 double 类型。\n<ul>\n<li>小数形式</li>\n<li>E/e 的指数形式</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>字符和字符串字面值\n<ul>\n<li>字符字面值<br>\n char 型字面值</li>\n<li>字符串字面值<br>\n由常量字符构成的数组（array），并且编译器会在每个字符串的结尾处添加一个空字符（’\\0’）用作字符串结束的标识符。因此，字符串字面值的实际长度要比它的内容多 1。</li>\n</ul>\n</li>\n<li>转义序列<br>\n主要为了两类程序员不能直接使用的字符服务\n<ul>\n<li>不可打印的字符</li>\n<li>C++ 语言中有特殊含义的字符</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>换行符</td>\n<td>\\n</td>\n<td>横向制表符</td>\n<td>\\t</td>\n<td>报警（响铃）符</td>\n<td>\\a</td>\n</tr>\n<tr>\n<td>纵向制表符</td>\n<td>\\v</td>\n<td>退格符</td>\n<td>\\b</td>\n<td>双引号</td>\n<td>\\&quot;</td>\n</tr>\n<tr>\n<td>反斜线</td>\n<td>\\\\</td>\n<td>问号</td>\n<td>\\?</td>\n<td>单引号</td>\n<td>\\’</td>\n</tr>\n<tr>\n<td>回车符</td>\n<td>\\r</td>\n<td>进纸符</td>\n<td>\\f</td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>指定字面值的类型</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th>指定字面值的类型</th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td></td>\n<td></td>\n<td>字符和字符串字面值</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>前缀</td>\n<td>含义</td>\n<td>类型</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>u</td>\n<td>Unicode 16 字符</td>\n<td>char16_t</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>U</td>\n<td>Unicode 32 字符</td>\n<td>char32_t</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>L</td>\n<td>宽字符</td>\n<td>wchar_t</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>u8</td>\n<td>UTF-8（仅用于字符串字面常量）</td>\n<td>char</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>整型字面值</td>\n<td></td>\n<td>浮点型字面值</td>\n<td></td>\n</tr>\n<tr>\n<td>后缀</td>\n<td>最小匹配类型</td>\n<td></td>\n<td>后缀</td>\n<td>类型</td>\n</tr>\n<tr>\n<td>u or U</td>\n<td>unsigned</td>\n<td></td>\n<td>f or F</td>\n<td>float</td>\n</tr>\n<tr>\n<td>l or L</td>\n<td>long</td>\n<td></td>\n<td>l or L</td>\n<td>long double</td>\n</tr>\n<tr>\n<td>ll or LL</td>\n<td>long long</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>布尔字面值和指针字面值\n<ul>\n<li>布尔字面值<br>\n true/false</li>\n<li>指针字面值<br>\n nullptr</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"9-变量与对象\"><a class=\"markdownIt-Anchor\" href=\"#9-变量与对象\">#</a> 9. 变量与对象</h1>\n<p>变量：提供一个具名的、可供程序操作的存储空间。<br>\n定义变量：首先是类型说明符（type specifier），随后紧跟着一个或多个变量名组成的列表。<br>\n对象（object）：通常指一块能存储数据并具有某种类型的内存空间。对此不同人有不同看法和理解。<br>\n当对象在创建时获得了一个特定的值，我们称这个对象被初始化了。<br>\n人们常常会忽略初始化与赋值之间的差异，实则这个问题很重要，初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除并以一个新值替代。</p>\n<h1 id=\"10-列表初始化list-initialization\"><a class=\"markdownIt-Anchor\" href=\"#10-列表初始化list-initialization\">#</a> 10. 列表初始化（list initialization）</h1>\n<p>如下，都可以做到将 units_sold 这个 int 变量初始化为 0。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> units_sold = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> units_sold = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> units_sold&#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">units_sold</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>当用于内置类型的变量时，这种初始化有一个重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">double</span> ld = <span class=\"number\">3.14159265358979</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> a&#123;ld&#125;, b = &#123;ld&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">c</span><span class=\"params\">(ld)</span>, d </span>= ld;</span><br></pre></td></tr></table></figure>\n<p>你可以判断一下上面代码块运行的结果，是否会报错，仔细思考，可以结合本文第六条内容。<br>\n虽然这类问题看起来无关紧要，毕竟我们不会故意用 long double 的值去初始化 int 变量，但毕竟，它可能在不经意间发生，不是吗？</p>\n<h1 id=\"11-默认初始化\"><a class=\"markdownIt-Anchor\" href=\"#11-默认初始化\">#</a> 11. 默认初始化</h1>\n<p>如果定义变量时没有指定初值，则变量被默认初始化（default initialized），此时变量被赋予了 &quot;默认值&quot;，默认值会由变量类型和定义变量的位置共同决定。<br>\n如果是内置类型的变量未被显式初始化，它的值由定义的位置决定。定义于任何函数体之外的变量被初始化为 0. 定义在函数体内部的内置类型变量将不被初始化（uninitialized）。一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或以其他方式访问此类值将引发错误。<br>\n每个类各自决定其初始化对象的方式。一些类要求每个对象都显式初始化，此时如果创造了一个该类的对象而未对其做明确的初始化操作，将引发错误。<br>\n未初始化的变量含有一个不确定的值，使用未初始化变量的值是一种错误的编程行为且很难调试。尽管大多数编译器能对一部分使用为初始化变量的行为提出警告，但严格而言，编译器并未被要求检查此类错误。<br>\n使用未初始化的变量将带来无法预计的后果，往往它会是对是错，添加无关代码导致我们误以为程序对了，但实际上代码仍是错误的。<br>\n建议初始化每一个内置类型的变量。虽然这不是必须的，但若是你无法确保不这么做时程序的安全，那这么做不失为一种最简单的方法。</p>\n<h1 id=\"12-变量声明和定义的关系\"><a class=\"markdownIt-Anchor\" href=\"#12-变量声明和定义的关系\">#</a> 12. 变量声明和定义的关系</h1>\n<p>为了允许把程序拆分成多个逻辑部分来编写，C++ 语言支持分离性编译（separate compilation）机制，该机制允许将程序分割为若干个文件，它们可以被独立编译。<br>\n为了支持分离性编译，C++ 语言将声明和定义区分开来。声明（declaration）使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而定义（definition）负责创建与名字关联的实体。<br>\n变量声明规定了变量的类型和名字，在这一点上定义与之相同。但是除此之外，定义还申请存储空间，也可能会为变量赋一个初始值。<br>\n如果想声明一个变量而非定义它，就在变量名前添加关键词 extern，并且不要显式的初始化变量。<br>\n任何包含了显示初始化的声明即成为定义。当我们给一个由 extern 关键词标记的变量赋一个初始值时，extern 的作用将被抵消，它也就不再是声明，而是定义。<br>\n在函数体内部，如果试图初始化一个由 extern 关键词标记的变量，将引发错误。<br>\n变量能且只能被定义一次，但可以被多次声明。<br>\n声明和定义区别很重要，如果要在多个文件中使用同一个变量，就必须将声明和定义分离。此时变量的定义必须且只能出现在一个文件中，而其他用到该变量的文件必须对其声明，却不能重复定义。</p>\n<h1 id=\"13-静态类型\"><a class=\"markdownIt-Anchor\" href=\"#13-静态类型\">#</a> 13. 静态类型</h1>\n<p>C++ 是一种静态类型（statically typed）语言，其含义是在编译阶段检查类型。其中，检查类型的过程称为类型检查（type checking）。<br>\n对象的类型决定了对象所能参与的运算，如果试图执行类型不支持的运算，编译器将报错并且不会生成可执行文件。<br>\n程序越复杂，静态类型检查越有助于发现问题。因此，我们在使用某个变量之前务必声明其类型。</p>\n<h1 id=\"14-标识符\"><a class=\"markdownIt-Anchor\" href=\"#14-标识符\">#</a> 14. 标识符</h1>\n<p>C++ 的标识符（identifier）由字母、数字和下划线组成，其中必须以字母或下划线开头。标识符的长度没有限制，但是对大小写字母敏感。<br>\n同时，C++ 也为语言本身以及标准库保留了一些名字，这些名字不能被用于标识符。<br>\n用户自定义的标识符中不能连续出现两个下划线（emmm，书里是画，很通俗易懂。。），也不能以下划线紧连大写字母开头，定义在函数体外的标识符不能以下划线开头。<br>\n下面是变量命名规范</p>\n<ul>\n<li>标识符要能体现实际含义</li>\n<li>变量名一般用小写字母</li>\n<li>用户自定义的类名一般以大写字母开头</li>\n<li>如果标识符由多个单词组成，则单词间应有明显区分</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th>C++ 关键字</th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>alignas</td>\n<td>continue</td>\n<td>friend</td>\n<td>register</td>\n<td>true</td>\n</tr>\n<tr>\n<td>alignof</td>\n<td>decltype</td>\n<td>goto</td>\n<td>reinterpret_cast</td>\n<td>try</td>\n</tr>\n<tr>\n<td>asm</td>\n<td>default</td>\n<td>if</td>\n<td>return</td>\n<td>typedef</td>\n</tr>\n<tr>\n<td>auto</td>\n<td>delete</td>\n<td>inline</td>\n<td>short</td>\n<td>typeid</td>\n</tr>\n<tr>\n<td>bool</td>\n<td>do</td>\n<td>int</td>\n<td>signed</td>\n<td>typename</td>\n</tr>\n<tr>\n<td>break</td>\n<td>double</td>\n<td>long</td>\n<td>sizeof</td>\n<td>union</td>\n</tr>\n<tr>\n<td>case</td>\n<td>dynamic_cast</td>\n<td>mutable</td>\n<td>static</td>\n<td>unsigned</td>\n</tr>\n<tr>\n<td>catch</td>\n<td>else</td>\n<td>namespace</td>\n<td>static_assert</td>\n<td>using</td>\n</tr>\n<tr>\n<td>char</td>\n<td>enum</td>\n<td>new</td>\n<td>static_cast</td>\n<td>virtual</td>\n</tr>\n<tr>\n<td>char16_t</td>\n<td>explicit</td>\n<td>noexcept</td>\n<td>struct</td>\n<td>void</td>\n</tr>\n<tr>\n<td>char32_t</td>\n<td>exprt</td>\n<td>nullptr</td>\n<td>switch</td>\n<td>volatile</td>\n</tr>\n<tr>\n<td>class</td>\n<td>extern</td>\n<td>operator</td>\n<td>template</td>\n<td>wchar_t</td>\n</tr>\n<tr>\n<td>const</td>\n<td>false</td>\n<td>private</td>\n<td>this</td>\n<td>while</td>\n</tr>\n<tr>\n<td>constexpr</td>\n<td>float</td>\n<td>protected</td>\n<td>thread_local</td>\n<td></td>\n</tr>\n<tr>\n<td>const_cast</td>\n<td>for</td>\n<td>public</td>\n<td>throw</td>\n<td></td>\n</tr>\n</tbody>\n<tbody>\n<tr>\n<td></td>\n<td>C++</td>\n<td>操作符</td>\n<td>替代名</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>and</td>\n<td>bitand</td>\n<td>compl</td>\n<td>not_eq</td>\n<td>or_eq</td>\n<td>xor_eq</td>\n</tr>\n<tr>\n<td>and_eq</td>\n<td>bitor</td>\n<td>not</td>\n<td>or</td>\n<td>xor</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"15-作用域scope\"><a class=\"markdownIt-Anchor\" href=\"#15-作用域scope\">#</a> 15. 作用域（scope）</h1>\n<p>作用域是程序的一部分，在其中名字有其特定的含义。C++ 语言中大多数作用域都以花括号分隔。<br>\n同一个名字在不同的作用域中可以指向不同的实体。名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结尾。<br>\nmain 函数定义于所有花括号之外，它和其他大多数定义在函数体之外的名字一样拥有全局作用域（global scope）。全局作用域内的名字在整个程序的范围内都可使用。<br>\n而在函数块（或循环等等其他类似的）内部定义的名字，从声明它到这个函数结束我们都可以访问它，但是出了函数所在的块就无法访问了，因此说它有块作用域（block scope）。<br>\n建议当你第一次使用变量时再定义它，这样有助于更容易找到变量的定义，并且我们更容易给它赋予一个更合理的初值。<br>\n作用域能彼此包含，被包含（或者说被嵌套）的作用域称为内层作用域（inner scope），包含着别的作用域的作用域称为外层作用域（outer scope）。<br>\n如果函数有可能用到某全局变量，则不宜再定义一个同名的局部变量。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> reused = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> unique = <span class=\"number\">0</span>;</span><br><span class=\"line\">    std::cout &lt;&lt; reused &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"type\">int</span> reused = <span class=\"number\">0</span>;</span><br><span class=\"line\">    std::cout &lt;&lt; reused &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std::endl;</span><br><span class=\"line\">    std::cout &lt;&lt; ::reused &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你可以通过上面的代码加深对作用域的理解。</p>\n<h1 id=\"16-复合类型\"><a class=\"markdownIt-Anchor\" href=\"#16-复合类型\">#</a> 16. 复合类型</h1>\n<p>复合类型（compound type）是指基于其他类型定义的类型。<br>\n下面将介绍引用与指针这两种。<br>\n这里更新下第 9 条中对于声明语句的定义：<br>\n一条声明语句由一个基本数据类型（base type）和紧随其后的一个声明符（declarator）列表组成。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型。<br>\n目前于我们而言，声明符就是变量名，但之后会有更加复杂的声明符，它基于基本数据类型得到更复杂的类型并把它指定给变量。</p>\n<h1 id=\"17-引用\"><a class=\"markdownIt-Anchor\" href=\"#17-引用\">#</a> 17. 引用</h1>\n<div class=\"note success simple\"><p>C++11 中新增了一种引用：所谓的右值引用（rvalue reference），后续会有更详细的介绍。这种引用主要用于内置类。严格来说，当我们使用术语引用（reference）时，指的其实是左值引用（lvalue reference）。</p>\n</div>\n<p>引用（reference）为对象起了另外一个名字，引用类型引用（refers to）另外一种类型。通过将声明符写成 &amp; d 的形式来定义引用类型，其中 d 是声明的变量名。<br>\n一般在初始化变量时，初始化会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初值绑定（bind）在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。<br>\n引用即别名，引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。<br>\n定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的。<br>\n因为引用本身不是一个对象，所以不能定义引用的引用。<br>\n注意，引用只能绑定在对象上，并且引用的类型必须要和它绑定的对象严格匹配。</p>\n<h1 id=\"18-指针\"><a class=\"markdownIt-Anchor\" href=\"#18-指针\">#</a> 18. 指针</h1>\n<p>指针（pointer）是指向（point to）另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。<br>\n指针和引用不同点：</p>\n<ul>\n<li>指针本身就是一个对象，允许对指针赋值和拷贝，而且指针在其生命周期内可以先后指向几个不同的对象。</li>\n<li>指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。</li>\n</ul>\n<p>指针通常难以理解，即使是有经验的程序员也常常因为调试指针引发的错误而备受折磨。<br>\n定义指针类型的方法将声明符写成 * d 的形式，其中 d 是变量名。如果在一条语句中定义了几个指针变量，那么每个变量前面都必须有符号 * 。<br>\n指针存放某个对象的地址，想要获取该地址，需要使用取地址符（操作符 &amp;）。<br>\n除了之后给定的两种特殊情况，其他所有指针的类型都要和它所指向的对象严格匹配。</p>\n<p>指针的值（地址）应是如下四种状态之一：</p>\n<ul>\n<li>指向一个对象</li>\n<li>指向紧邻对象所占空间的下一个位置</li>\n<li>空指针，即没有指向任何对象</li>\n<li>无效指针，即上述之外其他值…</li>\n</ul>\n<p>试图拷贝或以其他方式访问无效指针的值都将引发错误。编译器并不负责检查此类错误，这和使用未经初始化的变量是一样的。访问无效指针的后果无法预计，因此程序员必须清楚任意给定的指针是否有效。同样，访问未指向任何具体对象的指针也会引发不可知的后果。<br>\n如果指针指向了一个对象，则允许使用解引用符（操作符 * ）来访问该对象。对指针解引用会得出所指的对象，如果给解引用的结果赋值，实际上也就是给指针所指的对象赋值。<br>\n解引用操作仅适用于那些确实指向了某个对象的有效指针。<br>\n请注意，某些符号有多重含义，没错，刚刚学习的 * 和 &amp; 就是这样，我们完全可以将出现在不同场景下的它们看做不同的符号。<br>\n空指针（null pointer），不指向任何对象，给一个指针赋 nullptr/0/NULL 都可以使其成为空指针。注意，nullptr 是在 C++11 引入的。<br>\nnullptr 是一种特殊类型的字面值，它可以被转换成任意其他指针类型。<br>\nNULL 是预处理变量（preprocessor variable），这个变量在头文件 cstdlib 中定义，它的值就是 0。新标准下，现在的 C++ 程序最好使用 nullptr，同时尽量避免使用 NULL。<br>\n把 int 变量直接赋给指针是错误的操作，即使 int 变量的值恰好等于 0 也不行。<br>\n如同初始化变量一样，同样建议初始化全部的指针，因为指针本质上是访问内存空间，如果恰巧访问的内存空间地址原本有内容，我们又做出某些修改，那会引发很大的麻烦。如果定义时不知道指针改指向何处，那么可以把它初始化为 nullptr，这样就能让程序知道它没有指向任何具体的对象了。<br>\n最好的区分一条赋值语句到底是改变了指针的值还是指针所指向对象的值的方法就是记住赋值永远改变的是等号左侧的对象。<br>\n同理，当指针指向一个合法值，就能将它用于条件表达式中。<br>\nvoid * 指针是一种特殊的指针类型，可用于存放任意对象的地址。对于一个 void * 指针，我们只能：拿它和别的指针比较、作为函数的输入或输出、赋给另一个 void * 指针，不能：直接操作 void * 指针所指的对象。<br>\n简单地说，对于 void * 而言，内存空间仅仅是内存空间，它无法访问内存空间中所存的对象。（当然后面还是有办法获取 void * 所存地址的)</p>\n<h1 id=\"19-复合类型的声明\"><a class=\"markdownIt-Anchor\" href=\"#19-复合类型的声明\">#</a> 19. 复合类型的声明</h1>\n<p>其实类型修饰符只是声明符的一部分，它和基本数据类型毫无关系。<br>\n比如</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>* p;</span><br><span class=\"line\"><span class=\"type\">int</span>* p1, p2; <span class=\"comment\">// p1是指向int的指针，p2是int</span></span><br><span class=\"line\"><span class=\"type\">int</span> *p1, *p2; <span class=\"comment\">// p1和p2都是指向int的指针</span></span><br><span class=\"line\"><span class=\"type\">int</span>* p1;</span><br><span class=\"line\"><span class=\"type\">int</span>* p2;</span><br></pre></td></tr></table></figure>\n<p>这两种写法没有对错之分，但需要保证风格统一。<br>\n当然，之前说过，指针本身也是对象，所以，* * 指针的指针，* * * 指针的指针的指针，以此类推都是存在的。<br>\n而且根据引用的定义，*&amp; 指针的引用也是存在的。<br>\n要理解一个左值的类型，最简单的办法就是从右向左阅读得到它的定义。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> *&amp;r = p; <span class=\"comment\">// 从r开始向左，第一个符号是&amp;，第一个符号有最直接的影响，因此r是一个引用。其余部分则用来确定r引用的类型是什么，*说明r引用的是一个指针，最后通过int我们可知r引用的是一个int指针</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>今天的内容大概就到这里了，第二章还有一小部分内容，本章指针和引用深入可探讨的内容还是很多的，之后每天更得内容可能会少一点，会同步推一下项目以及 mit 6.1810 的。如有错误欢迎指正，如有疑问欢迎留言评论，我会尽快回复。</p>\n</blockquote>\n",
            "tags": [
                "C++",
                "C++ Primer"
            ]
        },
        {
            "id": "https://x-17.top/2022/10/13/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/",
            "url": "https://x-17.top/2022/10/13/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/",
            "title": "C++学习笔记(一)",
            "date_published": "2022-10-13T07:53:32.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p>本系列呢，目前是我个人学习 C++ Primer 这本书的学习纪录，整本书 19 章，顺利的话这个系列大概会持续 1 个月左右，尽量每天一章那个样子吧，可能记的没什么逻辑格式等等等等，毕竟，只是个笔记，太注重格式感觉本末倒置了，尽量持续更新吧，希望不鸽。</p>\n</blockquote>\n<h1 id=\"1-函数\"><a class=\"markdownIt-Anchor\" href=\"#1-函数\">#</a> 1. 函数</h1>\n<p>函数的定义包含四部分：返回类型（return type）、函数名（function name）、一个括号包围的形参列表（parameter list，允许为空）以及函数体（function body）。<br>\nmain 函数是比较特殊的，操作系统需要通过调用 main 来运行 C++ 程序，但它在定义上与其他函数是一样的。<br>\nmain 函数的返回类型必须为 int，即整数类型。int 类型是一种内置类型（built-in type），即语言自身定义的类型。<br>\n函数定义的最后一部分是函数体，它是一个以左花括号（curly brace）开始，以右花括号结束的语句块（block of statements）</p>\n<h1 id=\"2-类型\"><a class=\"markdownIt-Anchor\" href=\"#2-类型\">#</a> 2. 类型</h1>\n<p>类型是程序设计最基本的概念之一，在本书中我们会反复遇到它。一种类型不仅定义了数据元素的内容，还定义了这类数据上可以进行的运算。<br>\n程序所处理的数据都保存在变量中，而每个变量都有自己的类型。如果一个名为 v 的变量的类型为 T，我们通常说 “v 具有类型 T”，或等价的，“v 是一个 T 类型变量”。</p>\n<h1 id=\"3-标准输入输出\"><a class=\"markdownIt-Anchor\" href=\"#3-标准输入输出\">#</a> 3. 标准输入输出</h1>\n<p>首先呢，C++ 并未定义任何输入输出语句，而是包含标准库（standard library）提供 IO 机制，例如 iostream 库。<br>\niostream 库包含两个基础类型 istream 和 ostream，分别表示输入流和输出流。一个流就是一个字符序列，是从 IO 设备读出或写入 IO 设备的。术语 “流”（stream）想要表达的是，随着时间推移，字符是顺序生成或消耗的。<br>\n标准输入输出对象</p>\n<ul>\n<li>cin istream 类型 标准输入</li>\n<li>cout ostream 类型 标准输出</li>\n<li>cerr ostream 类型 输出警告和错误信息</li>\n<li>clog ostream 类型 输出程序运行时的一般性信息</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span> <span class=\"comment\">// 告诉编译器要使用iostream库，尖括号中的名字（iostream）是一个头文件</span></span></span><br><span class=\"line\">...</span><br><span class=\"line\">std::cin &gt;&gt; v1 &gt;&gt; v2; <span class=\"comment\">// 输入运算符（&gt;&gt;）</span></span><br><span class=\"line\">std::cout &lt;&lt; <span class=\"string\">&quot;Hello World&quot;</span> &lt;&lt; std::endl; <span class=\"comment\">// 输出运算符（&lt;&lt;） 字符串字面值常量/string literal（&quot;Hello World&quot;） 操纵符/manipulator（endl） </span></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>写入 endl 的效果是结束当前行，并将与设备关联的缓冲区（buffer）中的内容刷到设备中。缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入输出流中，而不是仅停留在内存中等待写入流。<br>\n而上面代码块中使用 <code>std::cin</code>  和 <code>std::cout</code>  而不是 <code>cin</code>  和 <code>cout</code> ，前缀 <code>std::</code>  指出 <code>cin</code>  和 <code>cout</code>  是定义在名为 <code>std</code>  的命名空间（namespace）中的。命名空间可以帮助我们避免不经意的名字定义冲突。标准库定义的所有名字都在命名空间 <code>std</code>  中。<br>\n通过命名空间使用标准库导致我们想使用来自命名空间 std 中的名字必须使用 <code>作用域运算符::</code>  指出我们想使用定义在命名空间 std 中的名字。当然，之后会给出更简单的方法。</p>\n<h1 id=\"4-注释\"><a class=\"markdownIt-Anchor\" href=\"#4-注释\">#</a> 4. 注释</h1>\n<p>C++ 中注释的种类</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 半/单行注释 </span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* 多行注释</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>请注意，不要嵌套多层多行注释，那会导致你的程序产生错误，请不要为难你的编译器。</p>\n<h1 id=\"5-控制流\"><a class=\"markdownIt-Anchor\" href=\"#5-控制流\">#</a> 5. 控制流</h1>\n<ul>\n<li>while</li>\n</ul>\n<p>反复执行一段代码，直到给定条件为假为止。<br>\n例如</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> sum = <span class=\"number\">0</span>, val = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 当val小于等于10时，运行大括号内部的代码</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (val &lt;= <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">        sum += val; <span class=\"comment\">//将 sum + val 赋给 sum</span></span><br><span class=\"line\">        ++val;      <span class=\"comment\">// 将 val 加 1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    std:cout &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先可以先想一想上面的代码块解决了什么问题。<br>\n其中，条件 /codition 对应的是 val &lt;= 10<br>\n 在代码块中我们用到了 <code>复合赋值运算符（+=）</code> ，即<br>\n sum += val =&gt; sum = sum + val<br>\n 还用到了 <code>前缀递增运算符（++）</code> ，即<br>\n ++val =&gt; val = val + 1</p>\n<ul>\n<li>for</li>\n</ul>\n<p>每个 for 语句都包含两部分：循环头和循环体。<br>\n循环头控制循环体的执行次数，它有三部分组成：一个初始化语句（init-statement）、一个循环条件（condition）以及一个表达式（expression）。</p>\n<ul>\n<li>读取数量不定的输入数据</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(std::cin &gt;&gt; value)</span><br></pre></td></tr></table></figure>\n<p>循环条件实际上检测的是 <code>std::cin</code> ，当我们使用一个 <code>istream</code>  对象作为条件时，其效果是检测流状态。如果流是有效的，即流未遇到错误，那么监测成功。当遇到文件结束符（end-of-file），或遇到一个无效输入时（例如读入的值不是一个整数），istream 对象的状态会变为无效。处于无效状态的 istream 对象会使条件变为假。</p>\n<div class=\"note success simple\"><ul>\n<li>\n<p>键盘输入文件结束符</p>\n<ul>\n<li>Windows<br>\n 先<kbd>Ctrl</kbd> + <kbd>Z</kbd><br>\n再<kbd>Enter</kbd> / <kbd>Return</kbd></li>\n<li>Mac OS X<br>\n<kbd>Ctrl</kbd> + <kbd>D</kbd></li>\n</ul>\n</li>\n<li>\n<p>再探编译<br>\n编译器无法保证一个程序是否按照其作者的意图工作，但它可以检查形式（form）上的错误。</p>\n<ul>\n<li>语法错误（syntax error）</li>\n<li>类型错误（type error）</li>\n<li>声明错误（declaration error)</li>\n</ul>\n<p>错误信息通常包含一个行号和一条简短描述，描述了编译器认为的我们所犯的错误。按照报告的顺序来逐个修正错误，是一种好习惯。因为一个单个错误常常会具有传递效应，导致编译器在其后报告比实际数量多得多的错误信息。另一个好习惯是在每修正一个错误后就立即重新编译代码，或者最多是修正了一小部分明显的错误后就重新编译。这就是所谓的 “编辑 - 编译 - 调试”（edit-compile-debug）周期。</p>\n</li>\n</ul>\n</div>\n<ul>\n<li>if</li>\n</ul>\n<p>当然，if 也能像上面 while 一样将 istream 对象作为条件，不同的是，if 会执行真的但不会循环。<br>\n在 if 条件中我们常会用到相等运算符（==）用于检测两个元素的值是否相同。要注意这里不要错用 <code>=</code> ，在 C++ 中 <code>=</code>  是赋值符号，而能单独用来进行判断元素间关系。</p>\n<h1 id=\"6-c程序的缩进和格式\"><a class=\"markdownIt-Anchor\" href=\"#6-c程序的缩进和格式\">#</a> 6. C++ 程序的缩进和格式</h1>\n<p>对于这个问题最正确的观点就是，不存在唯一的正确风格，但是保持一致性是非常重要的。不只是自己编写代码格式的统一，也是一个团队间代码风格的统一，缩进会使得复杂的程序有更好的可读性和易理解性，而一旦选择了一种风格，就要坚持使用。</p>\n<h1 id=\"7-类\"><a class=\"markdownIt-Anchor\" href=\"#7-类\">#</a> 7. 类</h1>\n<p>类机制是 C++ 最重要的特性之一。<br>\n一个类定义了一个类型以及与其关联的一组操作。<br>\nC++ 最初的一个设计焦点就是能定义使用上像内置类型一样自然的类类型。<br>\n类定义了行为，作者定义了类对象可以执行的所有动作。一般而言，类的作者决定了类类型对象上可以使用的所有操作。<br>\n对于类，我们需要为其定义一个头文件，我们可以通过这个头文件访问自定义的类。而我们引用自定义的类的头文件时，应该用双引号（&quot;&quot;）包围。<br>\n成员函数（member function）是定义为类的一部分的函数，也称之为方法（method）。<br>\n我们通常以一个类对象的名义来调用成员函数，以点运算符（.) 来表达我们需要某对象的某成员。点运算符只能用于类类型的对象，其左侧运算对象必须是一个类类型的对象，右侧运算对象必须是该类型的一个成员名，运算结果为右侧运算对象指定的成员。<br>\n当用点运算符访问一个成员函数时，我们使用一个调用运算符（()）来调用一个函数。调用运算符是一对圆括号，里面放置实参（argument）列表（可能为空）。</p>\n<h1 id=\"8-文件重定向\"><a class=\"markdownIt-Anchor\" href=\"#8-文件重定向\">#</a> 8. 文件重定向</h1>\n<p>未避免重复无意义的键盘输入测试，我们可以将标准输入和标准输出与命名文件关联起来，大多数操作系统支持这种文件重定向。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">addItems &lt;infile &gt;outfile</span></span><br></pre></td></tr></table></figure>\n<p>其中， <code>$</code>  是操作系统提示符， <code>addItems.exe</code>  是我们以编译好的可执行文件，而上述命令会将我们在 <code>infile</code>  文件中预先编辑好的数据读入，并将输出结果写入到 <code>outfile</code>  文件中。</p>\n<h1 id=\"9-总结\"><a class=\"markdownIt-Anchor\" href=\"#9-总结\">#</a> 9. 总结</h1>\n<p>下面会罗列一些本章节我们遇到的术语，你可以回顾一下，如果不理解你可以结合上文以及百度，或者留言我会尽力帮你理解它。如果文章中有任何错误，欢迎留言指正。</p>\n<ul>\n<li>参数（实参，argument）</li>\n<li>赋值（assignment）</li>\n<li>程序块（block）</li>\n<li>缓冲区（buffer）</li>\n<li>内置类型（built-in type）</li>\n<li>Cerr</li>\n<li>字符串字面值常量（character string literal）</li>\n<li>cin</li>\n<li>类（class）</li>\n<li>类类型（class type）</li>\n<li>clog</li>\n<li>注释（comment）</li>\n<li>条件（condition）</li>\n<li>cout</li>\n<li>花括号（curly brace）</li>\n<li>数据结构（data structure）</li>\n<li>编辑 - 编译 - 调试（edit-compile-debug）</li>\n<li>文件结束符（end-of-file）</li>\n<li>表达式（expression）</li>\n<li>for 语句（for statement）</li>\n<li>函数（function）</li>\n<li>函数体（function body）</li>\n<li>函数名（function name）</li>\n<li>头文件（header）</li>\n<li>if 语句（if statement）</li>\n<li>初始化（initialize）</li>\n<li>iostream</li>\n<li>istream</li>\n<li>库类型（library type）</li>\n<li>main</li>\n<li>操纵符（manipulator）</li>\n<li>成员函数（member function）</li>\n<li>方法（method）</li>\n<li>命名空间（namespace）</li>\n<li>ostream</li>\n<li>形参列表（parameter list）</li>\n<li>返回类型（return type）</li>\n<li>源文件（source file）</li>\n<li>标准错误（standard error）</li>\n<li>标准输入（standard input）</li>\n<li>标准库（standard library）</li>\n<li>标准输出（standard output）</li>\n<li>语句（statement）</li>\n<li>std</li>\n<li>字符串常量（string literal）</li>\n<li>未初始化的变量（uninitialized variable）</li>\n<li>变量（variable）</li>\n<li>while 语句（while statement）</li>\n<li>() 运算符（() operator）</li>\n<li>++ 运算符（++operator）</li>\n<li>+= 运算符（+=operator）</li>\n<li>. 运算符（.operator）</li>\n<li>:: 运算符（::operator）</li>\n<li>= 运算符（=operator）</li>\n<li>-- 运算符（--operator）</li>\n<li>&lt;&lt; 运算符（&lt;&lt; operator）</li>\n<li>&gt;&gt; 运算符（&gt;&gt;operator）</li>\n<li># include</li>\n<li>== 运算符（==operator）</li>\n<li>!= 运算符（!=operator）</li>\n<li>&lt;= 运算符（&lt;=operator）</li>\n<li>&lt; 运算符（&lt; operator）</li>\n<li>&gt;= 运算符（&gt;=operator）</li>\n<li>&gt; 运算符（&gt;operator）</li>\n</ul>\n<p>上面就是第一章全部内容了，后续可能读第二遍会添加新内容。</p>\n",
            "tags": [
                "C++",
                "C++ Primer"
            ]
        }
    ]
}