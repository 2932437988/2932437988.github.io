{
    "version": "https://jsonfeed.org/version/1",
    "title": "潇十七 • All posts by \"hard\" tag",
    "description": "可生活不是电影，我也少了点运气",
    "home_page_url": "https://x-17.top",
    "items": [
        {
            "id": "https://x-17.top/2022/12/14/LeetCode/1697-%E6%A3%80%E6%9F%A5%E8%BE%B9%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6%E7%9A%84%E8%B7%AF%E5%BE%84%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8/",
            "url": "https://x-17.top/2022/12/14/LeetCode/1697-%E6%A3%80%E6%9F%A5%E8%BE%B9%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6%E7%9A%84%E8%B7%AF%E5%BE%84%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8/",
            "title": "1697. 检查边长度限制的路径是否存在",
            "date_published": "2022-12-14T10:35:25.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"1697-检查边长度限制的路径是否存在\"><a class=\"markdownIt-Anchor\" href=\"#1697-检查边长度限制的路径是否存在\">#</a> <a href=\"https://leetcode.cn/problems/checking-existence-of-edge-length-limited-paths/description/\">1697. 检查边长度限制的路径是否存在</a></h1>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 并查集模板，包含路径压缩（参考 findset 函数）以及按秩合并（参考 sz 变量）</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">UF</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; fa;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; sz;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    <span class=\"type\">int</span> comp_cnt;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">UF</span>(<span class=\"type\">int</span> _n): <span class=\"built_in\">n</span>(_n), <span class=\"built_in\">comp_cnt</span>(_n), <span class=\"built_in\">fa</span>(_n), <span class=\"built_in\">sz</span>(_n, <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">iota</span>(fa.<span class=\"built_in\">begin</span>(), fa.<span class=\"built_in\">end</span>(), <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">findset</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fa[x] == x ? x : fa[x] = <span class=\"built_in\">findset</span>(fa[x]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">unite</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">        x = <span class=\"built_in\">findset</span>(x);</span><br><span class=\"line\">        y = <span class=\"built_in\">findset</span>(y);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x == y) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sz[x] &lt; sz[y]) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">swap</span>(x, y);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fa[y] = x;</span><br><span class=\"line\">        sz[x] += sz[y];</span><br><span class=\"line\">        --comp_cnt;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">connected</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">        x = <span class=\"built_in\">findset</span>(x);</span><br><span class=\"line\">        y = <span class=\"built_in\">findset</span>(y);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x == y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">bool</span>&gt; <span class=\"title\">distanceLimitedPathsExist</span><span class=\"params\">(<span class=\"type\">int</span> n, vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; edgeList, vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将 queries 按照边权限制从小到大排序</span></span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">qid</span><span class=\"params\">(queries.size())</span></span>;</span><br><span class=\"line\">        <span class=\"built_in\">iota</span>(qid.<span class=\"built_in\">begin</span>(), qid.<span class=\"built_in\">end</span>(), <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(qid.<span class=\"built_in\">begin</span>(), qid.<span class=\"built_in\">end</span>(), [&amp;](<span class=\"type\">int</span> i, <span class=\"type\">int</span> j) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> queries[i][<span class=\"number\">2</span>] &lt; queries[j][<span class=\"number\">2</span>];</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 将 edgeList 按照边权从小到大排序</span></span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(edgeList.<span class=\"built_in\">begin</span>(), edgeList.<span class=\"built_in\">end</span>(), [](<span class=\"type\">const</span> <span class=\"keyword\">auto</span>&amp; e1, <span class=\"type\">const</span> <span class=\"keyword\">auto</span>&amp; e2) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> e1[<span class=\"number\">2</span>] &lt; e2[<span class=\"number\">2</span>];</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 并查集</span></span><br><span class=\"line\">        <span class=\"function\">UF <span class=\"title\">uf</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">bool</span>&gt; <span class=\"title\">ans</span><span class=\"params\">(queries.size())</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> query: qid) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 往并查集中添加边直到边权关系 dis_i &lt; limit_j 不满足</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (i &lt; edgeList.<span class=\"built_in\">size</span>() &amp;&amp; edgeList[i][<span class=\"number\">2</span>] &lt; queries[query][<span class=\"number\">2</span>]) &#123;</span><br><span class=\"line\">                uf.<span class=\"built_in\">unite</span>(edgeList[i][<span class=\"number\">0</span>], edgeList[i][<span class=\"number\">1</span>]);</span><br><span class=\"line\">                ++i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 使用并查集判断连通性</span></span><br><span class=\"line\">            ans[query] = uf.<span class=\"built_in\">connected</span>(queries[query][<span class=\"number\">0</span>], queries[query][<span class=\"number\">1</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>m</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi><mo>+</mo><mi>q</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>q</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(mlogm+qlogq)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">q</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">q</span><span class=\"mclose\">)</span></span></span></span></li>\n<li>空间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi><mo>+</mo><mi>q</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n+logm+q)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">q</span><span class=\"mclose\">)</span></span></span></span></li>\n</ul>\n",
            "tags": [
                "每日一题",
                "Hard"
            ]
        },
        {
            "id": "https://x-17.top/2022/12/10/LeetCode/1691-%E5%A0%86%E5%8F%A0%E9%95%BF%E6%96%B9%E4%BD%93%E7%9A%84%E6%9C%80%E5%A4%A7%E9%AB%98%E5%BA%A6/",
            "url": "https://x-17.top/2022/12/10/LeetCode/1691-%E5%A0%86%E5%8F%A0%E9%95%BF%E6%96%B9%E4%BD%93%E7%9A%84%E6%9C%80%E5%A4%A7%E9%AB%98%E5%BA%A6/",
            "title": "1691. 堆叠长方体的最大高度",
            "date_published": "2022-12-10T07:18:37.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"1691-堆叠长方体的最大高度\"><a class=\"markdownIt-Anchor\" href=\"#1691-堆叠长方体的最大高度\">#</a> <a href=\"https://leetcode.cn/problems/maximum-height-by-stacking-cuboids/description/\">1691. 堆叠长方体的最大高度</a></h1>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maxHeight</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; cuboids)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = cuboids.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp; v : cuboids) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">sort</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(cuboids.<span class=\"built_in\">begin</span>(), cuboids.<span class=\"built_in\">end</span>(), [](<span class=\"type\">const</span> vector&lt;<span class=\"type\">int</span>&gt; &amp; a,<span class=\"type\">const</span> vector&lt;<span class=\"type\">int</span>&gt; &amp; b) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> a[<span class=\"number\">0</span>] + a[<span class=\"number\">1</span>] + a[<span class=\"number\">2</span>] &lt; b[<span class=\"number\">0</span>] + b[<span class=\"number\">1</span>] + b[<span class=\"number\">2</span>];</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            dp[i] = cuboids[i][<span class=\"number\">2</span>];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; i; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cuboids[i][<span class=\"number\">0</span>] &gt;= cuboids[j][<span class=\"number\">0</span>] &amp;&amp; </span><br><span class=\"line\">                    cuboids[i][<span class=\"number\">1</span>] &gt;= cuboids[j][<span class=\"number\">1</span>] &amp;&amp; </span><br><span class=\"line\">                    cuboids[i][<span class=\"number\">2</span>] &gt;= cuboids[j][<span class=\"number\">2</span>]) &#123;</span><br><span class=\"line\">                    dp[i] = <span class=\"built_in\">max</span>(dp[i], dp[j] + cuboids[i][<span class=\"number\">2</span>]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ans = <span class=\"built_in\">max</span>(ans, dp[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：$O (n^2)$</li>\n<li>空间复杂度：$O (n)$</li>\n</ul>\n",
            "tags": [
                "每日一题",
                "Hard"
            ]
        },
        {
            "id": "https://x-17.top/2022/12/05/LeetCode/1687-%E4%BB%8E%E4%BB%93%E5%BA%93%E5%88%B0%E7%A0%81%E5%A4%B4%E8%BF%90%E8%BE%93%E7%AE%B1%E5%AD%90/",
            "url": "https://x-17.top/2022/12/05/LeetCode/1687-%E4%BB%8E%E4%BB%93%E5%BA%93%E5%88%B0%E7%A0%81%E5%A4%B4%E8%BF%90%E8%BE%93%E7%AE%B1%E5%AD%90/",
            "title": "1687. 从仓库到码头运输箱子",
            "date_published": "2022-12-05T10:38:36.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"1687-从仓库到码头运输箱子\"><a class=\"markdownIt-Anchor\" href=\"#1687-从仓库到码头运输箱子\">#</a> <a href=\"https://leetcode.cn/problems/delivering-boxes-from-storage-to-ports/description/\">1687. 从仓库到码头运输箱子</a></h1>\n<p>你有一辆货运卡车，你需要用这一辆车把一些箱子从仓库运送到码头。这辆卡车每次运输有 箱子数目的限制 和 总重量的限制 。</p>\n<p>给你一个箱子数组 boxes 和三个整数 portsCount, maxBoxes 和 maxWeight ，其中 boxes [i] = [ports​​i​, weighti] 。</p>\n<ul>\n<li>ports​​i 表示第 i 个箱子需要送达的码头， weightsi 是第 i 个箱子的重量。</li>\n<li>portsCount 是码头的数目。</li>\n<li>maxBoxes 和 maxWeight 分别是卡车每趟运输箱子数目和重量的限制。</li>\n</ul>\n<p>箱子需要按照 数组顺序 运输，同时每次运输需要遵循以下步骤：</p>\n<ul>\n<li>卡车从 boxes 队列中按顺序取出若干个箱子，但不能违反 maxBoxes 和 maxWeight 限制。</li>\n<li>对于在卡车上的箱子，我们需要 按顺序 处理它们，卡车会通过 一趟行程 将最前面的箱子送到目的地码头并卸货。如果卡车已经在对应的码头，那么不需要 额外行程 ，箱子也会立马被卸货。</li>\n<li>卡车上所有箱子都被卸货后，卡车需要 一趟行程 回到仓库，从箱子队列里再取出一些箱子。</li>\n</ul>\n<p>卡车在将所有箱子运输并卸货后，最后必须回到仓库。</p>\n<p>请你返回将所有箱子送到相应码头的 最少行程 次数。</p>\n<p>示例 1：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：boxes = [[1,1],[2,1],[1,1]], portsCount = 2, maxBoxes = 3, maxWeight = 3</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：最优策略如下：</span><br><span class=\"line\"><span class=\"bullet\">-</span> 卡车将所有箱子装上车，到达码头 1 ，然后去码头 2 ，然后再回到码头 1 ，最后回到仓库，总共需要 4 趟行程。</span><br><span class=\"line\">所以总行程数为 4 。</span><br><span class=\"line\">注意到第一个和第三个箱子不能同时被卸货，因为箱子需要按顺序处理（也就是第二个箱子需要先被送到码头 2 ，然后才能处理第三个箱子）。</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：boxes = [[1,2],[3,3],[3,1],[3,1],[2,4]], portsCount = 3, maxBoxes = 3, maxWeight = 6</span><br><span class=\"line\">输出：6</span><br><span class=\"line\">解释：最优策略如下：</span><br><span class=\"line\"><span class=\"bullet\">-</span> 卡车首先运输第一个箱子，到达码头 1 ，然后回到仓库，总共 2 趟行程。</span><br><span class=\"line\"><span class=\"bullet\">-</span> 卡车运输第二、第三、第四个箱子，到达码头 3 ，然后回到仓库，总共 2 趟行程。</span><br><span class=\"line\"><span class=\"bullet\">-</span> 卡车运输第五个箱子，到达码头 3 ，回到仓库，总共 2 趟行程。</span><br><span class=\"line\">总行程数为 2 + 2 + 2 = 6 。</span><br></pre></td></tr></table></figure>\n<p>示例 3：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：boxes = [[1,4],[1,2],[2,1],[2,1],[3,2],[3,4]], portsCount = 3, maxBoxes = 6, maxWeight = 7</span><br><span class=\"line\">输出：6</span><br><span class=\"line\">解释：最优策略如下：</span><br><span class=\"line\"><span class=\"bullet\">-</span> 卡车运输第一和第二个箱子，到达码头 1 ，然后回到仓库，总共 2 趟行程。</span><br><span class=\"line\"><span class=\"bullet\">-</span> 卡车运输第三和第四个箱子，到达码头 2 ，然后回到仓库，总共 2 趟行程。</span><br><span class=\"line\"><span class=\"bullet\">-</span> 卡车运输第五和第六个箱子，到达码头 3 ，然后回到仓库，总共 2 趟行程。</span><br><span class=\"line\">总行程数为 2 + 2 + 2 = 6 。</span><br></pre></td></tr></table></figure>\n<p>示例 4：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：boxes = [[2,4],[2,5],[3,1],[3,2],[3,7],[3,1],[4,4],[1,3],[5,2]], portsCount = 5, maxBoxes = 5, maxWeight = 7</span><br><span class=\"line\">输出：14</span><br><span class=\"line\">解释：最优策略如下：</span><br><span class=\"line\"><span class=\"bullet\">-</span> 卡车运输第一个箱子，到达码头 2 ，然后回到仓库，总共 2 趟行程。</span><br><span class=\"line\"><span class=\"bullet\">-</span> 卡车运输第二个箱子，到达码头 2 ，然后回到仓库，总共 2 趟行程。</span><br><span class=\"line\"><span class=\"bullet\">-</span> 卡车运输第三和第四个箱子，到达码头 3 ，然后回到仓库，总共 2 趟行程。</span><br><span class=\"line\"><span class=\"bullet\">-</span> 卡车运输第五个箱子，到达码头 3 ，然后回到仓库，总共 2 趟行程。</span><br><span class=\"line\"><span class=\"bullet\">-</span> 卡车运输第六和第七个箱子，到达码头 3 ，然后去码头 4 ，然后回到仓库，总共 3 趟行程。</span><br><span class=\"line\"><span class=\"bullet\">-</span> 卡车运输第八和第九个箱子，到达码头 1 ，然后去码头 5 ，然后回到仓库，总共 3 趟行程。</span><br><span class=\"line\">总行程数为 2 + 2 + 2 + 2 + 3 + 3 = 14 。</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>1 &lt;= boxes.length &lt;= $10^5$</li>\n<li>1 &lt;= portsCount, maxBoxes, maxWeight &lt;= $10^5$</li>\n<li>1 &lt;= ports​​i &lt;= portsCount</li>\n<li>1 &lt;= weightsi &lt;= maxWeight</li>\n</ul>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">boxDelivering</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; boxes, <span class=\"type\">int</span> portsCount, <span class=\"type\">int</span> maxBoxes, <span class=\"type\">int</span> maxWeight)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = boxes.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">p</span><span class=\"params\">(n + <span class=\"number\">1</span>)</span>, <span class=\"title\">w</span><span class=\"params\">(n + <span class=\"number\">1</span>)</span>, <span class=\"title\">neg</span><span class=\"params\">(n + <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">long</span> <span class=\"type\">long</span>&gt; <span class=\"title\">W</span><span class=\"params\">(n + <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">            p[i] = boxes[i - <span class=\"number\">1</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">            w[i] = boxes[i - <span class=\"number\">1</span>][<span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                neg[i] = neg[i - <span class=\"number\">1</span>] + (p[i - <span class=\"number\">1</span>] != p[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            W[i] = W[i - <span class=\"number\">1</span>] + w[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        deque&lt;<span class=\"type\">int</span>&gt; opt = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">f</span><span class=\"params\">(n + <span class=\"number\">1</span>)</span>, <span class=\"title\">g</span><span class=\"params\">(n + <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (i - opt.<span class=\"built_in\">front</span>() &gt; maxBoxes || W[i] - W[opt.<span class=\"built_in\">front</span>()] &gt; maxWeight) &#123;</span><br><span class=\"line\">                opt.<span class=\"built_in\">pop_front</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            f[i] = g[opt.<span class=\"built_in\">front</span>()] + neg[i] + <span class=\"number\">2</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i != n) &#123;</span><br><span class=\"line\">                g[i] = f[i] - neg[i + <span class=\"number\">1</span>];</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (!opt.<span class=\"built_in\">empty</span>() &amp;&amp; g[i] &lt;= g[opt.<span class=\"built_in\">back</span>()]) &#123;</span><br><span class=\"line\">                    opt.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                opt.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> f[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：$O (n)$</li>\n<li>空间复杂度：$O (n)$</li>\n</ul>\n",
            "tags": [
                "每日一题",
                "Hard"
            ]
        },
        {
            "id": "https://x-17.top/2022/11/30/LeetCode/895-%E6%9C%80%E5%A4%A7%E9%A2%91%E7%8E%87%E6%A0%88/",
            "url": "https://x-17.top/2022/11/30/LeetCode/895-%E6%9C%80%E5%A4%A7%E9%A2%91%E7%8E%87%E6%A0%88/",
            "title": "895. 最大频率栈",
            "date_published": "2022-11-30T07:56:32.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"895-最大频率栈\"><a class=\"markdownIt-Anchor\" href=\"#895-最大频率栈\">#</a> <a href=\"https://leetcode.cn/problems/maximum-frequency-stack/description/\">895. 最大频率栈</a></h1>\n<p>设计一个类似堆栈的数据结构，将元素推入堆栈，并从堆栈中弹出出现频率最高的元素。</p>\n<p>实现 FreqStack 类:</p>\n<p>FreqStack () 构造一个空的堆栈。<br>\nvoid push (int val) 将一个整数 val 压入栈顶。<br>\nint pop () 删除并返回堆栈中出现频率最高的元素。<br>\n如果出现频率最高的元素不只一个，则移除并返回最接近栈顶的元素。</p>\n<p>示例 1：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\">[&quot;FreqStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;],</span><br><span class=\"line\">[[],[5],[7],[5],[7],[4],[5],[],[],[],[]]</span><br><span class=\"line\">输出：[null,null,null,null,null,null,null,5,7,5,4]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">FreqStack = new FreqStack();</span><br><span class=\"line\">freqStack.push (5);//堆栈为 [5]</span><br><span class=\"line\">freqStack.push (7);//堆栈是 [5,7]</span><br><span class=\"line\">freqStack.push (5);//堆栈是 [5,7,5]</span><br><span class=\"line\">freqStack.push (7);//堆栈是 [5,7,5,7]</span><br><span class=\"line\">freqStack.push (4);//堆栈是 [5,7,5,7,4]</span><br><span class=\"line\">freqStack.push (5);//堆栈是 [5,7,5,7,4,5]</span><br><span class=\"line\">freqStack.pop ();//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,5,7,4]。</span><br><span class=\"line\">freqStack.pop ();//返回 7 ，因为 5 和 7 出现频率最高，但7最接近顶部。堆栈变成 [5,7,5,4]。</span><br><span class=\"line\">freqStack.pop ();//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,4]。</span><br><span class=\"line\">freqStack.pop ();//返回 4 ，因为 4, 5 和 7 出现频率最高，但 4 是最接近顶部的。堆栈变成 [5,7]。</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>0 &lt;= val &lt;= $10^9$</li>\n<li>push 和 pop 的操作数不大于 $2 * 10^4$。</li>\n<li>输入保证在调用 pop 之前堆栈中至少有一个元素。</li>\n</ul>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">FreqStack</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">FreqStack</span>() &#123;</span><br><span class=\"line\">        maxFreq = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"type\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        freq[val]++;</span><br><span class=\"line\">        group[freq[val]].<span class=\"built_in\">push</span>(val);</span><br><span class=\"line\">        maxFreq = <span class=\"built_in\">max</span>(maxFreq, freq[val]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> val = group[maxFreq].<span class=\"built_in\">top</span>();</span><br><span class=\"line\">        freq[val]--;</span><br><span class=\"line\">        group[maxFreq].<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (group[maxFreq].<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">            maxFreq--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    unordered_map&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; freq;</span><br><span class=\"line\">    unordered_map&lt;<span class=\"type\">int</span>, stack&lt;<span class=\"type\">int</span>&gt;&gt; group;</span><br><span class=\"line\">    <span class=\"type\">int</span> maxFreq;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：$O (1)$</li>\n<li>空间复杂度：$O (n)$</li>\n</ul>\n",
            "tags": [
                "每日一题",
                "Hard"
            ]
        },
        {
            "id": "https://x-17.top/2022/11/26/LeetCode/882-%E7%BB%86%E5%88%86%E5%9B%BE%E4%B8%AD%E7%9A%84%E5%8F%AF%E5%88%B0%E8%BE%BE%E8%8A%82%E7%82%B9/",
            "url": "https://x-17.top/2022/11/26/LeetCode/882-%E7%BB%86%E5%88%86%E5%9B%BE%E4%B8%AD%E7%9A%84%E5%8F%AF%E5%88%B0%E8%BE%BE%E8%8A%82%E7%82%B9/",
            "title": "882. 细分图中的可到达节点",
            "date_published": "2022-11-26T05:14:44.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"882-细分图中的可到达节点\"><a class=\"markdownIt-Anchor\" href=\"#882-细分图中的可到达节点\">#</a> <a href=\"https://leetcode.cn/problems/reachable-nodes-in-subdivided-graph/description/\">882. 细分图中的可到达节点</a></h1>\n<p>给你一个无向图（原始图），图中有 n 个节点，编号从 0 到 n - 1 。你决定将图中的每条边 细分 为一条节点链，每条边之间的新节点数各不相同。</p>\n<p>图用由边组成的二维数组 edges 表示，其中 edges [i] = [ui, vi, cnti] 表示原始图中节点 ui 和 vi 之间存在一条边，cnti 是将边 细分 后的新节点总数。注意，cnti == 0 表示边不可细分。</p>\n<p>要 细分 边 [ui, vi] ，需要将其替换为 (cnti + 1) 条新边，和 cnti 个新节点。新节点为 x1, x2, …, xcnti ，新边为 [ui, x1], [x1, x2], [x2, x3], …, [xcnti+1, xcnti], [xcnti, vi] 。</p>\n<p>现在得到一个 新的细分图 ，请你计算从节点 0 出发，可以到达多少个节点？如果节点间距离是 maxMoves 或更少，则视为 可以到达 。</p>\n<p>给你原始图和 maxMoves ，返回 新的细分图中从节点 0 出发 可到达的节点数 。</p>\n<p>示例 1：<br>\n<img src=\"http://img.x-17.top/leetcode/origfinal.png\" alt=\"\"></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：edges = [[0,1,10],[0,2,1],[1,2,2]], maxMoves = 6, n = 3</span><br><span class=\"line\">输出：13</span><br><span class=\"line\">解释：边的细分情况如上图所示。</span><br><span class=\"line\">可以到达的节点已经用黄色标注出来。</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：edges = [[0,1,4],[1,2,6],[0,2,8],[1,3,1]], maxMoves = 10, n = 4</span><br><span class=\"line\">输出：23</span><br></pre></td></tr></table></figure>\n<p>示例 3：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：edges = [[1,2,4],[1,4,5],[1,3,1],[2,3,4],[3,4,5]], maxMoves = 17, n = 5</span><br><span class=\"line\">输出：1</span><br><span class=\"line\">解释：节点 0 与图的其余部分没有连通，所以只有节点 0 可以到达。</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>0 &lt;= edges.length &lt;= min(n * (n - 1) / 2, $10^4$)</li>\n<li>edges[i].length == 3</li>\n<li>0 &lt;= $u_i$ &lt; $v_i$ &lt; n</li>\n<li>图中 不存在平行边</li>\n<li>0 &lt;= cnti &lt;= $10^4$</li>\n<li>0 &lt;= maxMoves &lt;= $10^9$</li>\n<li>1 &lt;= n &lt;= 3000</li>\n</ul>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">encode</span><span class=\"params\">(<span class=\"type\">int</span> u, <span class=\"type\">int</span> v, <span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> u * n + v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">reachableNodes</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; edges, <span class=\"type\">int</span> maxMoves, <span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;vector&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;&gt;&gt; <span class=\"built_in\">adList</span>(n);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;edge : edges) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> u = edge[<span class=\"number\">0</span>], v = edge[<span class=\"number\">1</span>], nodes = edge[<span class=\"number\">2</span>];</span><br><span class=\"line\">            adList[u].<span class=\"built_in\">emplace_back</span>(v, nodes);</span><br><span class=\"line\">            adList[v].<span class=\"built_in\">emplace_back</span>(u, nodes);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        unordered_map&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; used;</span><br><span class=\"line\">        unordered_set&lt;<span class=\"type\">int</span>&gt; visited;</span><br><span class=\"line\">        <span class=\"type\">int</span> reachableNodes = <span class=\"number\">0</span>;</span><br><span class=\"line\">        priority_queue&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;, vector&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;&gt;, greater&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;&gt;&gt; pq;</span><br><span class=\"line\">        pq.<span class=\"built_in\">emplace</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!pq.<span class=\"built_in\">empty</span>() &amp;&amp; pq.<span class=\"built_in\">top</span>().first &lt;= maxMoves) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> [step, u] = pq.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">            pq.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (visited.<span class=\"built_in\">count</span>(u)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            visited.<span class=\"built_in\">emplace</span>(u);</span><br><span class=\"line\">            reachableNodes++;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> [v, nodes] : adList[u]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (nodes + step + <span class=\"number\">1</span> &lt;= maxMoves &amp;&amp; !visited.<span class=\"built_in\">count</span>(v)) &#123;</span><br><span class=\"line\">                    pq.<span class=\"built_in\">emplace</span>(nodes + step + <span class=\"number\">1</span>, v);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                used[<span class=\"built_in\">encode</span>(u, v, n)] = <span class=\"built_in\">min</span>(nodes, maxMoves - step);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;edge : edges) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> u = edge[<span class=\"number\">0</span>], v = edge[<span class=\"number\">1</span>], nodes = edge[<span class=\"number\">2</span>];</span><br><span class=\"line\">            reachableNodes += <span class=\"built_in\">min</span>(nodes, used[<span class=\"built_in\">encode</span>(u, v, n)] + used[<span class=\"built_in\">encode</span>(v, u, n)]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> reachableNodes;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：$O (E*logV)$</li>\n<li>空间复杂度：$O (V+E)$</li>\n</ul>\n",
            "tags": [
                "每日一题",
                "Hard"
            ]
        },
        {
            "id": "https://x-17.top/2022/11/22/LeetCode/878-%E7%AC%AC-N-%E4%B8%AA%E7%A5%9E%E5%A5%87%E6%95%B0%E5%AD%97/",
            "url": "https://x-17.top/2022/11/22/LeetCode/878-%E7%AC%AC-N-%E4%B8%AA%E7%A5%9E%E5%A5%87%E6%95%B0%E5%AD%97/",
            "title": "878. 第 N 个神奇数字",
            "date_published": "2022-11-22T12:20:25.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"878-第-n-个神奇数字\"><a class=\"markdownIt-Anchor\" href=\"#878-第-n-个神奇数字\">#</a> <a href=\"https://leetcode.cn/problems/nth-magical-number/description/\">878. 第 N 个神奇数字</a></h1>\n<p>一个正整数如果能被 a 或 b 整除，那么它是神奇的。</p>\n<p>给定三个整数 n , a , b ，返回第 n 个神奇的数字。因为答案可能很大，所以返回答案 对 $10^9 + 7$ 取模 后的值。</p>\n<p>示例 1：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：n = 1, a = 2, b = 3</span><br><span class=\"line\">输出：2</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：n = 4, a = 2, b = 3</span><br><span class=\"line\">输出：6</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>1 &lt;= n &lt;= $10^9$</li>\n<li>2 &lt;= a, b &lt;= 4 * $10^4$</li>\n</ul>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> MOD = <span class=\"number\">1e9</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">nthMagicalNumber</span><span class=\"params\">(<span class=\"type\">int</span> n, <span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"type\">long</span> l = <span class=\"built_in\">min</span>(a, b);</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"type\">long</span> r = (<span class=\"type\">long</span> <span class=\"type\">long</span>) n * <span class=\"built_in\">min</span>(a, b);</span><br><span class=\"line\">        <span class=\"type\">int</span> c = <span class=\"built_in\">lcm</span>(a, b);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l &lt;= r) &#123;</span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"type\">long</span> mid = (l + r) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"type\">long</span> cnt = mid / a + mid / b - mid / c;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cnt &gt;= n) &#123;</span><br><span class=\"line\">                r = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                l = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (r + <span class=\"number\">1</span>) % MOD;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：$O (log (n*max (a,b)))$</li>\n<li>空间复杂度：$O (1)$</li>\n</ul>\n",
            "tags": [
                "每日一题",
                "Hard"
            ]
        },
        {
            "id": "https://x-17.top/2022/11/18/LeetCode/891-%E5%AD%90%E5%BA%8F%E5%88%97%E5%AE%BD%E5%BA%A6%E4%B9%8B%E5%92%8C/",
            "url": "https://x-17.top/2022/11/18/LeetCode/891-%E5%AD%90%E5%BA%8F%E5%88%97%E5%AE%BD%E5%BA%A6%E4%B9%8B%E5%92%8C/",
            "title": "891. 子序列宽度之和",
            "date_published": "2022-11-18T03:58:33.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"891-子序列宽度之和\"><a class=\"markdownIt-Anchor\" href=\"#891-子序列宽度之和\">#</a> <a href=\"https://leetcode.cn/problems/sum-of-subsequence-widths/description/\">891. 子序列宽度之和</a></h1>\n<p>一个序列的 宽度 定义为该序列中最大元素和最小元素的差值。</p>\n<p>给你一个整数数组 nums ，返回 nums 的所有非空 子序列 的 宽度之和 。由于答案可能非常大，请返回对 109 + 7 取余 后的结果。</p>\n<p>子序列 定义为从一个数组里删除一些（或者不删除）元素，但不改变剩下元素的顺序得到的数组。例如，[3,6,2,7] 就是数组 [0,3,1,6,2,2,7] 的一个子序列。</p>\n<p>示例 1：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [2,1,3]</span><br><span class=\"line\">输出：6</span><br><span class=\"line\">解释：子序列为 [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3] 。</span><br><span class=\"line\">相应的宽度是 0, 0, 0, 1, 1, 2, 2 。</span><br><span class=\"line\">宽度之和是 6 。</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [2]</span><br><span class=\"line\">输出：0</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>1 &lt;= nums.length &lt;= $10^5$</li>\n<li>1 &lt;= nums[i] &lt;= $10^5$</li>\n</ul>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">sumSubseqWidths</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(nums.<span class=\"built_in\">begin</span>(), nums.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"type\">long</span> res = <span class=\"number\">0</span>, mod = <span class=\"number\">1e9</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"type\">long</span> x = nums[<span class=\"number\">0</span>], y = <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt; nums.<span class=\"built_in\">size</span>(); j++) &#123;</span><br><span class=\"line\">            res = (res + nums[j] * (y - <span class=\"number\">1</span>) - x) % mod;</span><br><span class=\"line\">            x = (x * <span class=\"number\">2</span> + nums[j]) % mod;</span><br><span class=\"line\">            y = y * <span class=\"number\">2</span> % mod;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (res + mod) % mod;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：$O (nlogn)$</li>\n<li>空间复杂度：$O (logn)$</li>\n</ul>\n",
            "tags": [
                "每日一题",
                "Hard"
            ]
        },
        {
            "id": "https://x-17.top/2022/11/14/LeetCode/805-%E6%95%B0%E7%BB%84%E7%9A%84%E5%9D%87%E5%80%BC%E5%88%86%E5%89%B2/",
            "url": "https://x-17.top/2022/11/14/LeetCode/805-%E6%95%B0%E7%BB%84%E7%9A%84%E5%9D%87%E5%80%BC%E5%88%86%E5%89%B2/",
            "title": "805. 数组的均值分割",
            "date_published": "2022-11-14T08:29:37.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"805-数组的均值分割\"><a class=\"markdownIt-Anchor\" href=\"#805-数组的均值分割\">#</a> <a href=\"https://leetcode.cn/problems/split-array-with-same-average/\">805. 数组的均值分割</a></h1>\n<p>给定你一个整数数组 nums</p>\n<p>我们要将 nums 数组中的每个元素移动到 A 数组 或者 B 数组中，使得 A 数组和 B 数组不为空，并且 average (A) == average (B) 。</p>\n<p>如果可以完成则返回 true ， 否则返回 false  。</p>\n<p>注意：对于数组 arr ,  average (arr) 是 arr 的所有元素的和除以 arr 长度。</p>\n<p>示例 1:</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: nums = [1,2,3,4,5,6,7,8]</span><br><span class=\"line\">输出: true</span><br><span class=\"line\">解释: 我们可以将数组分割为 [1,4,5,8] 和 [2,3,6,7], 他们的平均值都是4.5。</span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: nums = [3,1]</span><br><span class=\"line\">输出: false</span><br></pre></td></tr></table></figure>\n<p>提示:</p>\n<ul>\n<li>1 &lt;= nums.length &lt;= 30</li>\n<li>0 &lt;= nums[i] &lt;= $10^4$</li>\n</ul>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">splitArraySameAverage</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = nums.<span class=\"built_in\">size</span>(), m = n / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> sum = <span class=\"built_in\">accumulate</span>(nums.<span class=\"built_in\">begin</span>(), nums.<span class=\"built_in\">end</span>(), <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"type\">bool</span> isPossible = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= m; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sum * i % n == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                isPossible = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!isPossible) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        vector&lt;unordered_set&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">dp</span>(m + <span class=\"number\">1</span>);</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>].<span class=\"built_in\">insert</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> num: nums) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = m; i &gt;= <span class=\"number\">1</span>; i--) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> x: dp[i - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                    <span class=\"type\">int</span> curr = x + num;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (curr * n == sum * i) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    dp[i].<span class=\"built_in\">emplace</span>(curr);</span><br><span class=\"line\">                &#125; </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：$O (n^2*sum (nums))$</li>\n<li>空间复杂度：$O (n*sum (nums))$</li>\n</ul>\n",
            "tags": [
                "每日一题",
                "Hard"
            ]
        },
        {
            "id": "https://x-17.top/2022/11/10/LeetCode/864-%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E9%92%A5%E5%8C%99%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/",
            "url": "https://x-17.top/2022/11/10/LeetCode/864-%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E9%92%A5%E5%8C%99%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/",
            "title": "864. 获取所有钥匙的最短路径",
            "date_published": "2022-11-10T03:44:16.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"864-获取所有钥匙的最短路径\"><a class=\"markdownIt-Anchor\" href=\"#864-获取所有钥匙的最短路径\">#</a> <a href=\"https://leetcode.cn/problems/shortest-path-to-get-all-keys/description/\">864. 获取所有钥匙的最短路径</a></h1>\n<p>给定一个二维网格 grid ，其中：</p>\n<ul>\n<li>‘.’ 代表一个空房间</li>\n<li>‘#’ 代表一堵</li>\n<li>‘@’ 是起点</li>\n<li>小写字母代表钥匙</li>\n<li>大写字母代表锁</li>\n</ul>\n<p>我们从起点开始出发，一次移动是指向四个基本方向之一行走一个单位空间。我们不能在网格外面行走，也无法穿过一堵墙。如果途经一个钥匙，我们就把它捡起来。除非我们手里有对应的钥匙，否则无法通过锁。</p>\n<p>假设 k 为 钥匙 / 锁 的个数，且满足 1 &lt;= k &lt;= 6，字母表中的前 k 个字母在网格中都有自己对应的一个小写和一个大写字母。换言之，每个锁有唯一对应的钥匙，每个钥匙也有唯一对应的锁。另外，代表钥匙和锁的字母互为大小写并按字母顺序排列。</p>\n<p>返回获取所有钥匙所需要的移动的最少次数。如果无法获取所有钥匙，返回 -1 。</p>\n<p>示例 1：</p>\n<p><img src=\"http://img.x-17.top/leetcode/lc-keys2.jpg\" alt=\"\"></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：grid = [&quot;@.a.#&quot;,&quot;###.#&quot;,&quot;b.A.B&quot;]</span><br><span class=\"line\">输出：8</span><br><span class=\"line\">解释：目标是获得所有钥匙，而不是打开所有锁。</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<p><img src=\"http://img.x-17.top/leetcode/lc-key2.jpg\" alt=\"\"></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：grid = [&quot;@..aA&quot;,&quot;..B#.&quot;,&quot;....b&quot;]</span><br><span class=\"line\">输出：6</span><br></pre></td></tr></table></figure>\n<p>示例 3:<br>\n<img src=\"http://img.x-17.top/leetcode/lc-keys3.jpg\" alt=\"\"></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: grid = [&quot;@Aa&quot;]</span><br><span class=\"line\">输出: -1</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>m == grid.length</li>\n<li>n == grid[i].length</li>\n<li>1 &lt;= m, n &lt;= 30</li>\n<li>grid [i][j] 只含有 ‘.’, ‘#’, ‘@’, ‘a’-‘f’ 以及 ‘A’-‘F’</li>\n<li>钥匙的数目范围是 [1, 6]</li>\n<li>每个钥匙都对应一个 不同 的字母</li>\n<li>每个钥匙正好打开一个对应的锁</li>\n</ul>\n<h1 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h1>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">shortestPathAllKeys</span><span class=\"params\">(vector&lt;string&gt;&amp; grid)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> m = grid.<span class=\"built_in\">size</span>(), n = grid[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> sx = <span class=\"number\">0</span>, sy = <span class=\"number\">0</span>;</span><br><span class=\"line\">        unordered_map&lt;<span class=\"type\">char</span>, <span class=\"type\">int</span>&gt; key_to_idx;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; m; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; n; ++j) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (grid[i][j] == <span class=\"string\">&#x27;@&#x27;</span>) &#123;</span><br><span class=\"line\">                    sx = i;</span><br><span class=\"line\">                    sy = j;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">islower</span>(grid[i][j])) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!key_to_idx.<span class=\"built_in\">count</span>(grid[i][j])) &#123;</span><br><span class=\"line\">                        <span class=\"type\">int</span> idx = key_to_idx.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">                        key_to_idx[grid[i][j]] = idx;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        queue&lt;tuple&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;&gt; q;</span><br><span class=\"line\">        vector&lt;vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&gt; <span class=\"built_in\">dist</span>(m, vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;(n, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(<span class=\"number\">1</span> &lt;&lt; key_to_idx.<span class=\"built_in\">size</span>(), <span class=\"number\">-1</span>)));</span><br><span class=\"line\">        q.<span class=\"built_in\">emplace</span>(sx, sy, <span class=\"number\">0</span>);</span><br><span class=\"line\">        dist[sx][sy][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> [x, y, mask] = q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">            q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; ++i) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> nx = x + dirs[i][<span class=\"number\">0</span>];</span><br><span class=\"line\">                <span class=\"type\">int</span> ny = y + dirs[i][<span class=\"number\">1</span>];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (nx &gt;= <span class=\"number\">0</span> &amp;&amp; nx &lt; m &amp;&amp; ny &gt;= <span class=\"number\">0</span> &amp;&amp; ny &lt; n &amp;&amp; grid[nx][ny] != <span class=\"string\">&#x27;#&#x27;</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (grid[nx][ny] == <span class=\"string\">&#x27;.&#x27;</span> || grid[nx][ny] == <span class=\"string\">&#x27;@&#x27;</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (dist[nx][ny][mask] == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">                            dist[nx][ny][mask] = dist[x][y][mask] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                            q.<span class=\"built_in\">emplace</span>(nx, ny, mask);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">islower</span>(grid[nx][ny])) &#123;</span><br><span class=\"line\">                        <span class=\"type\">int</span> idx = key_to_idx[grid[nx][ny]];</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (dist[nx][ny][mask | (<span class=\"number\">1</span> &lt;&lt; idx)] == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">                            dist[nx][ny][mask | (<span class=\"number\">1</span> &lt;&lt; idx)] = dist[x][y][mask] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> ((mask | (<span class=\"number\">1</span> &lt;&lt; idx)) == (<span class=\"number\">1</span> &lt;&lt; key_to_idx.<span class=\"built_in\">size</span>()) - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">return</span> dist[nx][ny][mask | (<span class=\"number\">1</span> &lt;&lt; idx)];</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            q.<span class=\"built_in\">emplace</span>(nx, ny, mask | (<span class=\"number\">1</span> &lt;&lt; idx));</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"type\">int</span> idx = key_to_idx[<span class=\"built_in\">tolower</span>(grid[nx][ny])];</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> ((mask &amp; (<span class=\"number\">1</span> &lt;&lt; idx)) &amp;&amp; dist[nx][ny][mask] == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">                            dist[nx][ny][mask] = dist[x][y][mask] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                            q.<span class=\"built_in\">emplace</span>(nx, ny, mask);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"keyword\">constexpr</span> <span class=\"type\">int</span> dirs[<span class=\"number\">4</span>][<span class=\"number\">2</span>] = &#123;&#123;<span class=\"number\">-1</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">0</span>, <span class=\"number\">-1</span>&#125;, &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>&#125;&#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：$O (mn*2^k)$</li>\n<li>空间复杂度：$O (mn*2^k)$</li>\n</ul>\n",
            "tags": [
                "每日一题",
                "Hard"
            ]
        },
        {
            "id": "https://x-17.top/2022/11/05/LeetCode/1106-%E8%A7%A3%E6%9E%90%E5%B8%83%E5%B0%94%E8%A1%A8%E8%BE%BE%E5%BC%8F/",
            "url": "https://x-17.top/2022/11/05/LeetCode/1106-%E8%A7%A3%E6%9E%90%E5%B8%83%E5%B0%94%E8%A1%A8%E8%BE%BE%E5%BC%8F/",
            "title": "1106. 解析布尔表达式",
            "date_published": "2022-11-05T03:05:18.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"1106-解析布尔表达式\"><a class=\"markdownIt-Anchor\" href=\"#1106-解析布尔表达式\">#</a> <a href=\"https://leetcode.cn/problems/parsing-a-boolean-expression/description/\">1106. 解析布尔表达式</a></h1>\n<p>给你一个以字符串形式表述的 布尔表达式（boolean） expression，返回该式的运算结果。</p>\n<p>有效的表达式需遵循以下约定：</p>\n<ul>\n<li>“t”，运算结果为 True</li>\n<li>“f”，运算结果为 False</li>\n<li>“!(expr)”，运算过程为对内部表达式 expr 进行逻辑 非的运算（NOT）</li>\n<li>“&amp;(expr1,expr2,…)”，运算过程为对 2 个或以上内部表达式 expr1, expr2, … 进行逻辑 与的运算（AND）</li>\n<li>“|(expr1,expr2,…)”，运算过程为对 2 个或以上内部表达式 expr1, expr2, … 进行逻辑 或的运算（OR）</li>\n</ul>\n<p>示例 1：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：expression = &quot;!(f)&quot;</span><br><span class=\"line\">输出：true</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：expression = &quot;|(f,t)&quot;</span><br><span class=\"line\">输出：true</span><br></pre></td></tr></table></figure>\n<p>示例 3：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：expression = &quot;&amp;(t,f)&quot;</span><br><span class=\"line\">输出：false</span><br></pre></td></tr></table></figure>\n<p>示例 4：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：expression = &quot;|(&amp;(t,f,t),!(t))&quot;</span><br><span class=\"line\">输出：false</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>1 &lt;= expression.length &lt;= 20000</li>\n<li>expression [i] 由 {’(’, ‘)’, ‘&amp;’, ‘|’, ‘!’, ‘t’, ‘f’, ‘,’} 中的字符组成。</li>\n<li>expression 是以上述形式给出的有效表达式，表示一个布尔值。</li>\n</ul>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">parseBoolExpr</span><span class=\"params\">(string expression)</span> </span>&#123;</span><br><span class=\"line\">        stack&lt;<span class=\"type\">char</span>&gt; stk;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = expression.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">char</span> c = expression[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;,&#x27;</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (c != <span class=\"string\">&#x27;)&#x27;</span>) &#123;</span><br><span class=\"line\">                stk.<span class=\"built_in\">push</span>(c);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> t = <span class=\"number\">0</span>, f = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (stk.<span class=\"built_in\">top</span>() != <span class=\"string\">&#x27;(&#x27;</span>) &#123;</span><br><span class=\"line\">                    <span class=\"type\">char</span> val = stk.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">                    stk.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (val == <span class=\"string\">&#x27;t&#x27;</span>) &#123;</span><br><span class=\"line\">                        t++;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        f++;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                stk.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                <span class=\"type\">char</span> op = stk.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">                stk.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                <span class=\"keyword\">switch</span> (op) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"string\">&#x27;!&#x27;</span>:</span><br><span class=\"line\">                    stk.<span class=\"built_in\">push</span>(f == <span class=\"number\">1</span> ? <span class=\"string\">&#x27;t&#x27;</span> : <span class=\"string\">&#x27;f&#x27;</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"string\">&#x27;&amp;&#x27;</span>:</span><br><span class=\"line\">                    stk.<span class=\"built_in\">push</span>(f == <span class=\"number\">0</span> ? <span class=\"string\">&#x27;t&#x27;</span> : <span class=\"string\">&#x27;f&#x27;</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"string\">&#x27;|&#x27;</span>:</span><br><span class=\"line\">                    stk.<span class=\"built_in\">push</span>(t &gt; <span class=\"number\">0</span> ? <span class=\"string\">&#x27;t&#x27;</span> : <span class=\"string\">&#x27;f&#x27;</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> stk.<span class=\"built_in\">top</span>() == <span class=\"string\">&#x27;t&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：$O (n)$</li>\n<li>空间复杂度：$O (n)$</li>\n</ul>\n",
            "tags": [
                "每日一题",
                "Hard"
            ]
        },
        {
            "id": "https://x-17.top/2022/10/26/LeetCode/862-%E5%92%8C%E8%87%B3%E5%B0%91%E4%B8%BA-K-%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84/",
            "url": "https://x-17.top/2022/10/26/LeetCode/862-%E5%92%8C%E8%87%B3%E5%B0%91%E4%B8%BA-K-%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84/",
            "title": "862. 和至少为 K 的最短子数组",
            "date_published": "2022-10-26T04:04:54.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"862-和至少为-k-的最短子数组\"><a class=\"markdownIt-Anchor\" href=\"#862-和至少为-k-的最短子数组\">#</a> <a href=\"https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/\">862. 和至少为 K 的最短子数组</a></h1>\n<p>给你一个整数数组 nums 和一个整数 k ，找出 nums 中和至少为 k 的 最短非空子数组 ，并返回该子数组的长度。如果不存在这样的 子数组 ，返回 -1 。</p>\n<p>子数组 是数组中 连续 的一部分。</p>\n<p></p>\n<p>示例 1：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [1], k = 1</span><br><span class=\"line\">输出：1</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,2], k = 4</span><br><span class=\"line\">输出：-1</span><br></pre></td></tr></table></figure>\n<p>示例 3：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [2,-1,2], k = 3</span><br><span class=\"line\">输出：3</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>1 &lt;= nums.length &lt;= $10^5$</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>−</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">-10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"mord\">−</span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span> &lt;= nums[i] &lt;= $10^5$</li>\n<li>1 &lt;= k &lt;= $10^9$</li>\n</ul>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">shortestSubarray</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">long</span>&gt; <span class=\"title\">preSumArr</span><span class=\"params\">(n + <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            preSumArr[i + <span class=\"number\">1</span>] = preSumArr[i] + nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> res = n + <span class=\"number\">1</span>;</span><br><span class=\"line\">        deque&lt;<span class=\"type\">int</span>&gt; qu;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">long</span> curSum = preSumArr[i];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!qu.<span class=\"built_in\">empty</span>() &amp;&amp; curSum - preSumArr[qu.<span class=\"built_in\">front</span>()] &gt;= k) &#123;</span><br><span class=\"line\">                res = <span class=\"built_in\">min</span>(res, i - qu.<span class=\"built_in\">front</span>());</span><br><span class=\"line\">                qu.<span class=\"built_in\">pop_front</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!qu.<span class=\"built_in\">empty</span>() &amp;&amp; preSumArr[qu.<span class=\"built_in\">back</span>()] &gt;= curSum) &#123;</span><br><span class=\"line\">                qu.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            qu.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res &lt; n + <span class=\"number\">1</span> ? res : <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：$O (n)$</li>\n<li>空间复杂度：$O (n)$</li>\n</ul>\n",
            "tags": [
                "每日一题",
                "Hard"
            ]
        },
        {
            "id": "https://x-17.top/2022/10/22/LeetCode/1235-%E8%A7%84%E5%88%92%E5%85%BC%E8%81%8C%E5%B7%A5%E4%BD%9C/",
            "url": "https://x-17.top/2022/10/22/LeetCode/1235-%E8%A7%84%E5%88%92%E5%85%BC%E8%81%8C%E5%B7%A5%E4%BD%9C/",
            "title": "1235. 规划兼职工作",
            "date_published": "2022-10-22T00:35:21.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"1235-规划兼职工作\"><a class=\"markdownIt-Anchor\" href=\"#1235-规划兼职工作\">#</a> <a href=\"https://leetcode.cn/problems/maximum-profit-in-job-scheduling/\">1235. 规划兼职工作</a></h1>\n<p>你打算利用空闲时间来做兼职工作赚些零花钱。</p>\n<p>这里有 n 份兼职工作，每份工作预计从 startTime [i] 开始到 endTime [i] 结束，报酬为 profit [i]。</p>\n<p>给你一份兼职工作表，包含开始时间 startTime，结束时间 endTime 和预计报酬 profit 三个数组，请你计算并返回可以获得的最大报酬。</p>\n<p>注意，时间上出现重叠的 2 份工作不能同时进行。</p>\n<p>如果你选择的工作在时间 X 结束，那么你可以立刻进行在时间 X 开始的下一份工作。</p>\n<p></p>\n<p>示例 1：</p>\n<p><img src=\"http://img.x-17.top/leetcode/sample1_1584.png\" alt=\"\"></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70]</span><br><span class=\"line\">输出：120</span><br><span class=\"line\">解释：</span><br><span class=\"line\">我们选出第 1 份和第 4 份工作， </span><br><span class=\"line\">时间范围是 [1-3]+[3-6]，共获得报酬 120 = 50 + 70。</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<p><img src=\"http://img.x-17.top/leetcode/sample22_1584.png\" alt=\"\"></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60]</span><br><span class=\"line\">输出：150</span><br><span class=\"line\">解释：</span><br><span class=\"line\">我们选择第 1，4，5 份工作。 </span><br><span class=\"line\">共获得报酬 150 = 20 + 70 + 60。</span><br></pre></td></tr></table></figure>\n<p>示例 3：</p>\n<p><img src=\"http://img.x-17.top/leetcode/sample3_1584.png\" alt=\"\"></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4]</span><br><span class=\"line\">输出：6</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>1 &lt;= startTime.length == endTime.length == profit.length &lt;= $5 * 10^4$</li>\n<li>1 &lt;= startTime[i] &lt; endTime[i] &lt;= $10^9$</li>\n<li>1 &lt;= profit[i] &lt;= $10^4$</li>\n</ul>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">jobScheduling</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt; &amp;startTime, vector&lt;<span class=\"type\">int</span>&gt; &amp;endTime, vector&lt;<span class=\"type\">int</span>&gt; &amp;profit)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = startTime.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">jobs</span>(n);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            jobs[i] = &#123;startTime[i], endTime[i], profit[i]&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(jobs.<span class=\"built_in\">begin</span>(), jobs.<span class=\"built_in\">end</span>(), [](<span class=\"type\">const</span> vector&lt;<span class=\"type\">int</span>&gt; &amp;job1, <span class=\"type\">const</span> vector&lt;<span class=\"type\">int</span>&gt; &amp;job2) -&gt; <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> job1[<span class=\"number\">1</span>] &lt; job2[<span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(n + <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> k = <span class=\"built_in\">upper_bound</span>(jobs.<span class=\"built_in\">begin</span>(), jobs.<span class=\"built_in\">begin</span>() + i - <span class=\"number\">1</span>, jobs[i - <span class=\"number\">1</span>][<span class=\"number\">0</span>], [&amp;](<span class=\"type\">int</span> st, <span class=\"type\">const</span> vector&lt;<span class=\"type\">int</span>&gt; &amp;job) -&gt; <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> st &lt; job[<span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;) - jobs.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">            dp[i] = <span class=\"built_in\">max</span>(dp[i - <span class=\"number\">1</span>], dp[k] + jobs[i - <span class=\"number\">1</span>][<span class=\"number\">2</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：$O (nlogn)$</li>\n<li>空间复杂度：$O (n)$</li>\n</ul>\n",
            "tags": [
                "每日一题",
                "Hard"
            ]
        },
        {
            "id": "https://x-17.top/2022/10/18/LeetCode/902-%E6%9C%80%E5%A4%A7%E4%B8%BA-N-%E7%9A%84%E6%95%B0%E5%AD%97%E7%BB%84%E5%90%88/",
            "url": "https://x-17.top/2022/10/18/LeetCode/902-%E6%9C%80%E5%A4%A7%E4%B8%BA-N-%E7%9A%84%E6%95%B0%E5%AD%97%E7%BB%84%E5%90%88/",
            "title": "902. 最大为 N 的数字组合",
            "date_published": "2022-10-17T23:58:48.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"902-最大为-n-的数字组合\"><a class=\"markdownIt-Anchor\" href=\"#902-最大为-n-的数字组合\">#</a> <a href=\"https://leetcode.cn/problems/numbers-at-most-n-given-digit-set/\">902. 最大为 N 的数字组合</a></h1>\n<p>给定一个按 非递减顺序 排列的数字数组 digits 。你可以用任意次数 digits [i] 来写的数字。例如，如果 digits = [‘1’,‘3’,‘5’]，我们可以写数字，如 ‘13’, ‘551’, 和 ‘1351315’。</p>\n<p>返回 可以生成的小于或等于给定整数 n 的正整数的个数 。</p>\n<p>示例 1：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：digits = [&quot;1&quot;,&quot;3&quot;,&quot;5&quot;,&quot;7&quot;], n = 100</span><br><span class=\"line\">输出：20</span><br><span class=\"line\">解释：</span><br><span class=\"line\">可写出的 20 个数字是：</span><br><span class=\"line\">1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：digits = [&quot;1&quot;,&quot;4&quot;,&quot;9&quot;], n = 1000000000</span><br><span class=\"line\">输出：29523</span><br><span class=\"line\">解释：</span><br><span class=\"line\">我们可以写 3 个一位数字，9 个两位数字，27 个三位数字，</span><br><span class=\"line\">81 个四位数字，243 个五位数字，729 个六位数字，</span><br><span class=\"line\">2187 个七位数字，6561 个八位数字和 19683 个九位数字。</span><br><span class=\"line\">总共，可以使用D中的数字写出 29523 个整数。</span><br></pre></td></tr></table></figure>\n<p>示例 3:</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：digits = [&quot;7&quot;], n = 8</span><br><span class=\"line\">输出：1</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>1 &lt;= digits.length &lt;= 9</li>\n<li>digits[i].length == 1</li>\n<li>digits [i] 是从 ‘1’ 到 ‘9’ 的数</li>\n<li>digits 中的所有值都 不同</li>\n<li>digits 按 非递减顺序 排列</li>\n<li>1 &lt;= n &lt;= $10^9$</li>\n</ul>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<p>数位 DP</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">atMostNGivenDigitSet</span><span class=\"params\">(vector&lt;string&gt;&amp; digits, <span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        string s = <span class=\"built_in\">to_string</span>(n);</span><br><span class=\"line\">        <span class=\"type\">int</span> m = digits.<span class=\"built_in\">size</span>(), k = s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">dp</span>(k + <span class=\"number\">1</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(<span class=\"number\">2</span>));</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= k; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; m; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (digits[j][<span class=\"number\">0</span>] == s[i - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                    dp[i][<span class=\"number\">1</span>] = dp[i - <span class=\"number\">1</span>][<span class=\"number\">1</span>];</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (digits[j][<span class=\"number\">0</span>] &lt; s[i - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                    dp[i][<span class=\"number\">0</span>] += dp[i - <span class=\"number\">1</span>][<span class=\"number\">1</span>];</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                dp[i][<span class=\"number\">0</span>] += m + dp[i - <span class=\"number\">1</span>][<span class=\"number\">0</span>] * m;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[k][<span class=\"number\">0</span>] + dp[k][<span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度：$O (klogn)$</li>\n<li>空间复杂度：$O (logn)$</li>\n</ul>\n",
            "tags": [
                "每日一题",
                "Hard"
            ]
        },
        {
            "id": "https://x-17.top/2022/10/14/LeetCode/940-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97-II/",
            "url": "https://x-17.top/2022/10/14/LeetCode/940-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97-II/",
            "title": "940. 不同的子序列 II",
            "date_published": "2022-10-14T00:30:40.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"940-不同的子序列-ii\"><a class=\"markdownIt-Anchor\" href=\"#940-不同的子序列-ii\">#</a> <a href=\"https://leetcode.cn/problems/distinct-subsequences-ii/\">940. 不同的子序列 II</a></h1>\n<p>给定一个字符串 s，计算 s 的 不同非空子序列 的个数。因为结果可能很大，所以返回答案需要对 $10^9 + 7$ 取余 。</p>\n<p>字符串的 子序列 是经由原字符串删除一些（也可能不删除）字符但不改变剩余字符相对位置的一个新字符串。</p>\n<ul>\n<li>例如，“ace” 是 “abcde” 的一个子序列，但 “aec” 不是。</li>\n</ul>\n<p>示例 1：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;abc&quot;</span><br><span class=\"line\">输出：7</span><br><span class=\"line\">解释：7 个不同的子序列分别是 &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;ab&quot;, &quot;ac&quot;, &quot;bc&quot;, 以及 &quot;abc&quot;。</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;aba&quot;</span><br><span class=\"line\">输出：6</span><br><span class=\"line\">解释：6 个不同的子序列分别是 &quot;a&quot;, &quot;b&quot;, &quot;ab&quot;, &quot;ba&quot;, &quot;aa&quot; 以及 &quot;aba&quot;。</span><br></pre></td></tr></table></figure>\n<p>示例 3：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;aaa&quot;</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：3 个不同的子序列分别是 &quot;a&quot;, &quot;aa&quot; 以及 &quot;aaa&quot;。</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>1 &lt;= s.length &lt;= 2000</li>\n<li>s 仅由小写英文字母组成</li>\n</ul>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<p>这题用到了动态规划，我们可以用一个长度为 26 的数组存储每一个字母位于末位时含有的不重复子序列个数，最初我们将其初始化为 0，对于第 i 位的字母，以它为最后一位的子序列数就是其前缀的不重复子序列数量 + 1 个，而这其中重复的子序列个数，就是我们存储的这个字母前一次为子序列最后一位时不重复子序列的个数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">distinctSubseqII</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">g</span><span class=\"params\">(<span class=\"number\">26</span>,<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;s.<span class=\"built_in\">length</span>();i++)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> m=s[i]-<span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> n=g[m];</span><br><span class=\"line\">            g[m]=ans+<span class=\"number\">1</span>;</span><br><span class=\"line\">            ans=((ans+g[m]-n)%(<span class=\"type\">int</span>)(<span class=\"number\">1e9</span>+<span class=\"number\">7</span>)+(<span class=\"type\">int</span>)(<span class=\"number\">1e9</span>+<span class=\"number\">7</span>))%(<span class=\"type\">int</span>)(<span class=\"number\">1e9</span>+<span class=\"number\">7</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度：$O (n+|\\sum|)$</li>\n<li>空间复杂度：$O (|\\sum|)$</li>\n</ul>\n",
            "tags": [
                "每日一题",
                "Hard"
            ]
        },
        {
            "id": "https://x-17.top/2022/10/10/LeetCode/801-%E4%BD%BF%E5%BA%8F%E5%88%97%E9%80%92%E5%A2%9E%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BA%A4%E6%8D%A2%E6%AC%A1%E6%95%B0/",
            "url": "https://x-17.top/2022/10/10/LeetCode/801-%E4%BD%BF%E5%BA%8F%E5%88%97%E9%80%92%E5%A2%9E%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BA%A4%E6%8D%A2%E6%AC%A1%E6%95%B0/",
            "title": "801. 使序列递增的最小交换次数",
            "date_published": "2022-10-09T23:34:41.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"801-使序列递增的最小交换次数\"><a class=\"markdownIt-Anchor\" href=\"#801-使序列递增的最小交换次数\">#</a> <a href=\"https://leetcode.cn/problems/minimum-swaps-to-make-sequences-increasing/\">801. 使序列递增的最小交换次数</a></h1>\n<p>我们有两个长度相等且不为空的整型数组 nums1 和 nums2 。在一次操作中，我们可以交换 nums1 [i] 和 nums2 [i] 的元素。</p>\n<ul>\n<li>例如，如果 nums1 = [1,2,3,8] ， nums2 =[5,6,7,4] ，你可以交换 i = 3 处的元素，得到 nums1 =[1,2,3,4] 和 nums2 =[5,6,7,8] 。<br>\n返回 使 nums1 和 nums2 严格递增 所需操作的最小次数 。</li>\n</ul>\n<p>数组 arr 严格递增 且  arr [0] &lt; arr [1] &lt; arr [2] &lt; … &lt; arr [arr.length - 1] 。</p>\n<p>注意：</p>\n<ul>\n<li>用例保证可以实现操作。</li>\n</ul>\n<p>示例 1:</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: nums1 = [1,3,5,4], nums2 = [1,2,3,7]</span><br><span class=\"line\">输出: 1</span><br><span class=\"line\">解释: </span><br><span class=\"line\">交换 A[3] 和 B[3] 后，两个数组如下:</span><br><span class=\"line\">A = [1, 3, 5, 7] ， B = [1, 2, 3, 4]</span><br><span class=\"line\">两个数组均为严格递增的。</span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: nums1 = [0,3,5,8,9], nums2 = [2,1,4,6,9]</span><br><span class=\"line\">输出: 1</span><br></pre></td></tr></table></figure>\n<p>提示:</p>\n<ul>\n<li>$2 &lt;= nums1.length &lt;= 10^5$</li>\n<li>$nums2.length == nums1.length$</li>\n<li>$0 &lt;= nums1[i], nums2[i] &lt;= 2 * 10^5$</li>\n</ul>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<p>首先，在位置 i 会出现不需要交换，需要交换和不能交换三种情况，即如下两式其中一个成立或者同时成立</p>\n<ol>\n<li>$nums_1 [i] &gt; nums_1 [i-1] 且 nums_2 [i] &gt; nums_2 [i-1] $</li>\n<li>$nums_1 [i] &gt; nums_2 [i-1] 且 nums_2 [i] &gt; nums_1 [i-1] $</li>\n</ol>\n<p>因此，<br>\n用 <code>dp[i][0]</code>  表示到第 i 位满足要求且第 i 位不进行交换；<br>\n用 <code>dp[i][1]</code>  表示到第 i 位满足要求且第 i 位进行交换；<br>\n当满足式 1 而不满足式 2 时，有</p>\n$\n\\begin{cases}\ndp[i][0] = dp[i-1][0]\\\\\ndp[i][1] = dp[i-1][1] + 1\n\\end{cases}\n$\n<p>当满足式 2 而不满足式 1 时，有</p>\n$\n\\begin{cases}\ndp[i][0] = dp[i-1][1]\\\\\ndp[i][1] = dp[i-1][0] + 1\n\\end{cases}\n$\n<p>当两式同时满足时，有</p>\n$\n\\begin{cases}\ndp[i][0] = min\\{dp[i-1][0],dp[i-1][1]\\}\\\\\ndp[i][1] = min\\{dp[i-1][1],dp[i-1][0]\\} + 1\n\\end{cases}\n$\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">minSwap</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums1, vector&lt;<span class=\"type\">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = nums1.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> a = <span class=\"number\">0</span>, b = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> at = a, bt = b;</span><br><span class=\"line\">            a = b = n;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums1[i] &gt; nums1[i - <span class=\"number\">1</span>] &amp;&amp; nums2[i] &gt; nums2[i - <span class=\"number\">1</span>])  &#123;</span><br><span class=\"line\">                a = <span class=\"built_in\">min</span>(a, at);</span><br><span class=\"line\">                b = <span class=\"built_in\">min</span>(b, bt + <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums1[i] &gt; nums2[i - <span class=\"number\">1</span>] &amp;&amp; nums2[i] &gt; nums1[i - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                a = <span class=\"built_in\">min</span>(a, bt);</span><br><span class=\"line\">                b = <span class=\"built_in\">min</span>(b, at + <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">min</span>(a, b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：$O (n)$</li>\n<li>空间复杂度：$O (1)$</li>\n</ul>\n",
            "tags": [
                "每日一题",
                "Hard"
            ]
        },
        {
            "id": "https://x-17.top/2022/10/06/LeetCode/927-%E4%B8%89%E7%AD%89%E5%88%86/",
            "url": "https://x-17.top/2022/10/06/LeetCode/927-%E4%B8%89%E7%AD%89%E5%88%86/",
            "title": "927. 三等分",
            "date_published": "2022-10-06T05:23:56.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"927-三等分\"><a class=\"markdownIt-Anchor\" href=\"#927-三等分\">#</a> <a href=\"https://leetcode.cn/problems/three-equal-parts/\">927. 三等分</a></h1>\n<blockquote>\n<p>给定一个由 0 和 1 组成的数组 arr ，将数组分成  3 个非空的部分 ，使得所有这些部分表示相同的二进制值。</p>\n<p>如果可以做到，请返回任何 [i, j]，其中 i+1 &lt; j，这样一来：</p>\n<ul>\n<li>\n<p>arr [0], arr [1], …, arr [i] 为第一部分；</p>\n</li>\n<li>\n<p>arr [i + 1], arr [i + 2], …, arr [j - 1] 为第二部分；</p>\n</li>\n<li>\n<p>arr [j], arr [j + 1], …, arr [arr.length - 1] 为第三部分。</p>\n</li>\n<li>\n<p>这三个部分所表示的二进制值相等。</p>\n</li>\n<li>\n<p>如果无法做到，就返回 [-1, -1]。</p>\n</li>\n</ul>\n<p>注意，在考虑每个部分所表示的二进制时，应当将其看作一个整体。例如，[1,1,0] 表示十进制中的 6，而不会是 3。此外，前导零也是被允许的，所以 [0,1,1] 和 [1,1] 表示相同的值。</p>\n<p></p>\n<p>示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：arr = [1,0,1,0,1]</span><br><span class=\"line\">输出：[0,3]</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：arr = [1,1,0,1,1]</span><br><span class=\"line\">输出：[-1,-1]</span><br></pre></td></tr></table></figure>\n<p>示例 3:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：arr = [1,1,0,0,1]</span><br><span class=\"line\">输出：[0,2]</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>\n<p>3 &lt;= arr.length &lt;= 3 * 104</p>\n</li>\n<li>\n<p>arr [i] 是 0 或 1</p>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">threeEqualParts</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> sum = <span class=\"built_in\">accumulate</span>(arr.<span class=\"built_in\">begin</span>(), arr.<span class=\"built_in\">end</span>(), <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sum % <span class=\"number\">3</span> != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123;<span class=\"number\">-1</span>, <span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sum == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123;<span class=\"number\">0</span>, <span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> partial = sum / <span class=\"number\">3</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> first = <span class=\"number\">0</span>, second = <span class=\"number\">0</span>, third = <span class=\"number\">0</span>, cur = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; arr.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[i] == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cur == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    first = i;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cur == partial) &#123;</span><br><span class=\"line\">                    second = i;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cur == <span class=\"number\">2</span> * partial) &#123;</span><br><span class=\"line\">                    third = i;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                cur++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> len = (<span class=\"type\">int</span>)arr.<span class=\"built_in\">size</span>() - third;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (first + len &lt;= second &amp;&amp; second + len &lt;= third) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (third + i &lt; arr.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (arr[first + i] != arr[second + i] || arr[first + i] != arr[third + i]) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> &#123;<span class=\"number\">-1</span>, <span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123;first + len - <span class=\"number\">1</span>, second + len&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;<span class=\"number\">-1</span>, <span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></li>\n<li>空间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></li>\n</ul>\n",
            "tags": [
                "Hard",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/09/26/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%98-17-19-%E6%B6%88%E5%A4%B1%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/",
            "url": "https://x-17.top/2022/09/26/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%98-17-19-%E6%B6%88%E5%A4%B1%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/",
            "title": "面试题 17.19. 消失的两个数字",
            "date_published": "2022-09-25T23:31:31.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/missing-two-lcci/\">https://leetcode.cn/problems/missing-two-lcci/</a> 给定一个数组，包含从 1 到 N 所有的整数，但其中缺了两个数字。你能在 O (N) 时间内只用 O (1) 的空间找到它们吗？ 以任意顺序返回这两个数字均可。 示例 1:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: [1]</span><br><span class=\"line\">输出: [2,3]</span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: [2,3]</span><br><span class=\"line\">输出: [1,4]</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>nums.length &lt;= 30000</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    vector missingTwo(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class=\"line\">        long n = nums.size() + 2;</span><br><span class=\"line\">        int a = -accumulate(nums.cbegin(), nums.cend(), -(1 + n) * n / 2);</span><br><span class=\"line\">        int b = -inner_product(nums.cbegin(), nums.cend(), nums.cbegin(), -(1 + n) * n / 2 * (2 * n + 1) / 3);</span><br><span class=\"line\">        int tmp = sqrt(2 * b - a * a);</span><br><span class=\"line\">        return &#123; (a + tmp) / 2, (a - tmp) / 2 &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度 \\(O (n)\\)</li>\n<li>空间复杂度 \\(O (1)\\)</li>\n</ul>\n",
            "tags": [
                "Hard",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/09/21/LeetCode/854-%E7%9B%B8%E4%BC%BC%E5%BA%A6%E4%B8%BA-k-%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/",
            "url": "https://x-17.top/2022/09/21/LeetCode/854-%E7%9B%B8%E4%BC%BC%E5%BA%A6%E4%B8%BA-k-%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/",
            "title": "854. 相似度为 K 的字符串",
            "date_published": "2022-09-21T01:05:22.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/k-similar-strings/\">https://leetcode.cn/problems/k-similar-strings/</a> 对于某些非负整数 k ，如果交换 s1 中两个字母的位置恰好 k 次，能够使结果字符串等于 s2 ，则认为字符串 s1 和 s2 的 相似度为 k 。 给你两个字母异位词 s1 和 s2 ，返回 s1 和 s2 的相似度 k 的最小值。 示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：s1 = &quot;ab&quot;, s2 = &quot;ba&quot;</span><br><span class=\"line\">输出：1</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：s1 = &quot;abc&quot;, s2 = &quot;bca&quot;</span><br><span class=\"line\">输出：2</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>1 &lt;= s1.length &lt;= 20</li>\n<li>s2.length == s1.length</li>\n<li>s1 和 s2  只包含集合 {‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’} 中的小写字母</li>\n<li>s2 是 s1 的一个字母异位词</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int kSimilarity(string s1, string s2) &#123;</span><br><span class=\"line\">        int n = s1.size();</span><br><span class=\"line\">        queue&lt;pair&lt;string, int&gt;&gt; qu;</span><br><span class=\"line\">        unordered_set&lt;string&gt; visit;</span><br><span class=\"line\">        qu.emplace(s1, 0);</span><br><span class=\"line\">        visit.emplace(s1);</span><br><span class=\"line\">        for (int step = 0;; step++) &#123;</span><br><span class=\"line\">            int sz = qu.size();</span><br><span class=\"line\">            for (int i = 0; i &lt; sz; i++) &#123;</span><br><span class=\"line\">                auto [cur, pos] = qu.front();</span><br><span class=\"line\">                qu.pop();</span><br><span class=\"line\">                if (cur == s2) &#123;</span><br><span class=\"line\">                    return step;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                while (pos &lt; n &amp;&amp; cur[pos] == s2[pos]) &#123;</span><br><span class=\"line\">                    pos++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                for (int j = pos + 1; j &lt; n; j++) &#123;</span><br><span class=\"line\">                    if (cur[j] != s2[j] &amp;&amp; cur[j] == s2[pos]) &#123; // 剪枝，只在 cur[j] != s2[j] 时去交换</span><br><span class=\"line\">                        swap(cur[pos], cur[j]);</span><br><span class=\"line\">                        if (!visit.count(cur)) &#123;</span><br><span class=\"line\">                            visit.emplace(cur);</span><br><span class=\"line\">                            qu.emplace(cur, pos + 1);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        swap(cur[pos], cur[j]);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>",
            "tags": [
                "Hard",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/09/18/LeetCode/827-%E6%9C%80%E5%A4%A7%E4%BA%BA%E5%B7%A5%E5%B2%9B/",
            "url": "https://x-17.top/2022/09/18/LeetCode/827-%E6%9C%80%E5%A4%A7%E4%BA%BA%E5%B7%A5%E5%B2%9B/",
            "title": "827. 最大人工岛",
            "date_published": "2022-09-18T00:29:56.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/making-a-large-island/\">https://leetcode.cn/problems/making-a-large-island/</a> 给你一个大小为 n x n 二进制矩阵 grid 。最多 只能将一格 0 变成 1 。 返回执行此操作后，grid 中最大的岛屿面积是多少？ 岛屿 由一组上、下、左、右四个方向相连的 1 形成。 示例 1:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: grid = [[1, 0], [0, 1]]</span><br><span class=\"line\">输出: 3</span><br><span class=\"line\">解释: 将一格0变成1，最终连通两个小岛得到面积为 3 的岛屿。</span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: grid = [[1, 1], [1, 0]]</span><br><span class=\"line\">输出: 4</span><br><span class=\"line\">解释: 将一格0变成1，岛屿的面积扩大为 4。</span><br></pre></td></tr></table></figure>\n<p>示例 3:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: grid = [[1, 1], [1, 1]]</span><br><span class=\"line\">输出: 4</span><br><span class=\"line\">解释: 没有0可以让我们变成1，面积依然为 4。</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>n == grid.length</li>\n<li>n == grid[i].length</li>\n<li>1 &lt;= n &lt;= 500</li>\n<li>grid [i][j] 为 0 或 1</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const vector&lt;int&gt; d = &#123;0, -1, 0, 1, 0&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    bool valid(int n, int x, int y) &#123;</span><br><span class=\"line\">        return x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    int dfs(const vector&lt;vector&lt;int&gt;&gt; &amp;grid, int x, int y, vector&lt;vector&lt;int&gt;&gt; &amp;tag, int t) &#123;</span><br><span class=\"line\">        int n = grid.size(), res = 1;</span><br><span class=\"line\">        tag[x][y] = t;</span><br><span class=\"line\">        for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class=\"line\">            int x1 = x + d[i], y1 = y + d[i + 1];</span><br><span class=\"line\">            if (valid(n, x1, y1) &amp;&amp; grid[x1][y1] == 1 &amp;&amp; tag[x1][y1] == 0) &#123;</span><br><span class=\"line\">                res += dfs(grid, x1, y1, tag, t);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    int largestIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class=\"line\">        int n = grid.size(), res = 0;</span><br><span class=\"line\">        vector&lt;vector&lt;int&gt;&gt; tag(n, vector&lt;int&gt;(n));</span><br><span class=\"line\">        unordered_map&lt;int, int&gt; area;</span><br><span class=\"line\">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class=\"line\">            for (int j = 0; j &lt; n; j++) &#123;</span><br><span class=\"line\">                if (grid[i][j] == 1 &amp;&amp; tag[i][j] == 0) &#123;</span><br><span class=\"line\">                    int t = i * n + j + 1;</span><br><span class=\"line\">                    area[t] = dfs(grid, i, j, tag, t);</span><br><span class=\"line\">                    res = max(res, area[t]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class=\"line\">            for (int j = 0; j &lt; n; j++) &#123;</span><br><span class=\"line\">                if (grid[i][j] == 0) &#123;</span><br><span class=\"line\">                    int z = 1;</span><br><span class=\"line\">                    unordered_set&lt;int&gt; connected;</span><br><span class=\"line\">                    for (int k = 0; k &lt; 4; k++) &#123; int x = i + d[k], y = j + d[k + 1]; if (!valid(n, x, y)  tag[x][y] == 0  connected.count(tag[x][y]) &gt; 0) &#123;</span><br><span class=\"line\">                            continue;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        z += area[tag[x][y]];</span><br><span class=\"line\">                        connected.insert(tag[x][y]);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    res = max(res, z);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度 \\(O (n^2)\\)</li>\n<li>空间复杂度 \\(O (n^2)\\)</li>\n</ul>\n",
            "tags": [
                "Hard",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/09/16/LeetCode/850-%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF-ii/",
            "url": "https://x-17.top/2022/09/16/LeetCode/850-%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF-ii/",
            "title": "850. 矩形面积 II",
            "date_published": "2022-09-16T02:04:12.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/rectangle-area-ii/\">https://leetcode.cn/problems/rectangle-area-ii/</a> 我们给出了一个（轴对齐的）二维矩形列表 rectangles 。 对于 rectangle [i] = [x1, y1, x2, y2]，其中（x1，y1）是矩形 i 左下角的坐标， (xi1, yi1) 是该矩形 左下角 的坐标， (xi2, yi2) 是该矩形 右上角 的坐标。 计算平面中所有 rectangles 所覆盖的 总面积 。任何被两个或多个矩形覆盖的区域应只计算 一次 。 返回 总面积 。因为答案可能太大，返回 \\(10^9 + 7\\) 的 模 。 示例 1： <img src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/06/rectangle_area_ii_pic.png\" alt=\"\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：rectangles = [[0,0,2,2],[1,0,2,3],[1,0,3,1]]</span><br><span class=\"line\">输出：6</span><br><span class=\"line\">解释：如图所示，三个矩形覆盖了总面积为6的区域。</span><br><span class=\"line\">从(1,1)到(2,2)，绿色矩形和红色矩形重叠。</span><br><span class=\"line\">从(1,0)到(2,3)，三个矩形都重叠。</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：rectangles = [[0,0,1000000000,1000000000]]</span><br><span class=\"line\">输出：49</span><br></pre></td></tr></table></figure>\n<p>解释：答案是 \\(10^{18} 对 (10^9 + 7) \\) 取模的结果， 即 49 。 提示：</p>\n<ul>\n<li>1 &lt;= rectangles.length &lt;= 200</li>\n<li>rectanges[i].length = 4</li>\n<li>\\(0 &lt;= x_{i1}, y_{i1}, x_{i2}, y_{i2} &lt;= 10^9\\)</li>\n<li>矩形叠加覆盖后的总面积不会超越 \\(2^{63}  - 1 \\)，这意味着可以用一个 64 位有符号整数来保存面积结果。</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int rectangleArea(vector&lt;vector&lt;int&gt;&gt;&amp; rectangles) &#123;</span><br><span class=\"line\">        int n = rectangles.size();</span><br><span class=\"line\">        vector&lt;int&gt; hbound;</span><br><span class=\"line\">        for (const auto&amp; rect: rectangles) &#123;</span><br><span class=\"line\">            // 下边界</span><br><span class=\"line\">            hbound.push_back(rect[1]);</span><br><span class=\"line\">            // 上边界</span><br><span class=\"line\">            hbound.push_back(rect[3]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sort(hbound.begin(), hbound.end());</span><br><span class=\"line\">        hbound.erase(unique(hbound.begin(), hbound.end()), hbound.end());</span><br><span class=\"line\">        int m = hbound.size();</span><br><span class=\"line\">        // 「思路与算法部分」的 length 数组并不需要显式地存储下来</span><br><span class=\"line\">        // length[i] 可以通过 hbound[i+1] - hbound[i] 得到</span><br><span class=\"line\">        vector&lt;int&gt; seg(m - 1);</span><br><span class=\"line\"></span><br><span class=\"line\">        vector&lt;tuple&lt;int, int, int&gt;&gt; sweep;</span><br><span class=\"line\">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            // 左边界</span><br><span class=\"line\">            sweep.emplace_back(rectangles[i][0], i, 1);</span><br><span class=\"line\">            // 右边界</span><br><span class=\"line\">            sweep.emplace_back(rectangles[i][2], i, -1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sort(sweep.begin(), sweep.end());</span><br><span class=\"line\"></span><br><span class=\"line\">        long long ans = 0;</span><br><span class=\"line\">        for (int i = 0; i &lt; sweep.size(); ++i) &#123;</span><br><span class=\"line\">            int j = i;</span><br><span class=\"line\">            while (j + 1 &lt; sweep.size() &amp;&amp; get&lt;0&gt;(sweep[i]) == get&lt;0&gt;(sweep[j + 1])) &#123;</span><br><span class=\"line\">                ++j;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (j + 1 == sweep.size()) &#123;</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            // 一次性地处理掉一批横坐标相同的左右边界</span><br><span class=\"line\">            for (int k = i; k &lt;= j; ++k) &#123;</span><br><span class=\"line\">                auto&amp;&amp; [_, idx, diff] = sweep[k];</span><br><span class=\"line\">                int left = rectangles[idx][1], right = rectangles[idx][3];</span><br><span class=\"line\">                for (int x = 0; x &lt; m - 1; ++x) &#123;</span><br><span class=\"line\">                    if (left &lt;= hbound[x] &amp;&amp; hbound[x + 1] &lt;= right) &#123;</span><br><span class=\"line\">                        seg[x] += diff;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            int cover = 0;</span><br><span class=\"line\">            for (int k = 0; k &lt; m - 1; ++k) &#123; if (seg[k] &gt; 0) &#123;</span><br><span class=\"line\">                    cover += (hbound[k + 1] - hbound[k]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ans += static_cast&lt;long long&gt;(cover) * (get&lt;0&gt;(sweep[j + 1]) - get&lt;0&gt;(sweep[j]));</span><br><span class=\"line\">            i = j;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ans % static_cast&lt;int&gt;(1e9 + 7);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度 \\(O (n^2)\\)</li>\n<li>空间复杂度 \\(O (n)\\)</li>\n</ul>\n",
            "tags": [
                "Hard",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/09/11/LeetCode/857-%E9%9B%87%E4%BD%A3-k-%E5%90%8D%E5%B7%A5%E4%BA%BA%E7%9A%84%E6%9C%80%E4%BD%8E%E6%88%90%E6%9C%AC/",
            "url": "https://x-17.top/2022/09/11/LeetCode/857-%E9%9B%87%E4%BD%A3-k-%E5%90%8D%E5%B7%A5%E4%BA%BA%E7%9A%84%E6%9C%80%E4%BD%8E%E6%88%90%E6%9C%AC/",
            "title": "857. 雇佣 K 名工人的最低成本",
            "date_published": "2022-09-11T10:19:46.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/minimum-cost-to-hire-k-workers/\">https://leetcode.cn/problems/minimum-cost-to-hire-k-workers/</a> 有 n 名工人。 给定两个数组 quality 和 wage ，其中，quality [i] 表示第 i 名工人的工作质量，其最低期望工资为 wage [i] 。 现在我们想雇佣 k 名工人组成一个工资组。在雇佣 一组 k 名工人时，我们必须按照下述规则向他们支付工资： 对工资组中的每名工人，应当按其工作质量与同组其他工人的工作质量的比例来支付工资。 工资组中的每名工人至少应当得到他们的最低期望工资。 给定整数 k ，返回 组成满足上述条件的付费群体所需的最小金额 。在实际答案的 10-5 以内的答案将被接受。。 示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入： quality = [10,20,5], wage = [70,50,30], k = 2</span><br><span class=\"line\">输出： 105.00000</span><br><span class=\"line\">解释： 我们向 0 号工人支付 70，向 2 号工人支付 35。</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入： quality = [3,1,10,10,1], wage = [4,8,2,2,7], k = 3</span><br><span class=\"line\">输出： 30.66667</span><br><span class=\"line\">解释： 我们向 0 号工人支付 4，向 2 号和 3 号分别支付 13.33333。</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>n == quality.length == wage.length</li>\n<li>\\(1 &lt;= k &lt;= n &lt;= 10^4\\)</li>\n<li>\\(1 &lt;= quality[i], wage[i] &lt;= 10^4\\)</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    double mincostToHireWorkers(vector&lt;int&gt;&amp; quality, vector&lt;int&gt;&amp; wage, int k) &#123;</span><br><span class=\"line\">        int n = quality.size();</span><br><span class=\"line\">        vector&lt;int&gt; h(n, 0);</span><br><span class=\"line\">        iota(h.begin(), h.end(), 0);</span><br><span class=\"line\">        sort(h.begin(), h.end(), [&amp;](int&amp; a, int&amp; b) &#123;</span><br><span class=\"line\">            return quality[a] * wage[b] &gt; quality[b] * wage[a];</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        double res = 1e9;</span><br><span class=\"line\">        double totalq = 0.0;</span><br><span class=\"line\">        priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; q;</span><br><span class=\"line\">        for (int i = 0; i &lt; k - 1; i++) &#123;</span><br><span class=\"line\">            totalq += quality[h[i]];</span><br><span class=\"line\">            q.push(quality[h[i]]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        for (int i = k - 1; i &lt; n; i++) &#123;</span><br><span class=\"line\">            int idx = h[i];</span><br><span class=\"line\">            totalq += quality[idx];</span><br><span class=\"line\">            q.push(quality[idx]);</span><br><span class=\"line\">            double totalc = ((double) wage[idx] / quality[idx]) * totalq;</span><br><span class=\"line\">            res = min(res, totalc);</span><br><span class=\"line\">            totalq -= q.top();</span><br><span class=\"line\">            q.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度 \\(O (nlogn)\\)</li>\n<li>空间复杂度 \\(O (n)\\)</li>\n</ul>\n",
            "tags": [
                "Hard",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/09/06/LeetCode/828-%E7%BB%9F%E8%AE%A1%E5%AD%90%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6/",
            "url": "https://x-17.top/2022/09/06/LeetCode/828-%E7%BB%9F%E8%AE%A1%E5%AD%90%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6/",
            "title": "828. 统计子串中的唯一字符",
            "date_published": "2022-09-06T07:47:08.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/\">https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/</a> 我们定义了一个函数 countUniqueChars (s) 来统计字符串 s 中的唯一字符，并返回唯一字符的个数。 例如：s = “LEETCODE” ，则其中 “L”, “T”,“C”,“O”,“D” 都是唯一字符，因为它们只出现一次，所以 countUniqueChars (s) = 5 。 本题将会给你一个字符串 s ，我们需要返回 countUniqueChars (t) 的总和，其中 t 是 s 的子字符串。输入用例保证返回值为 32 位整数。 注意，某些子字符串可能是重复的，但你统计时也必须算上这些重复的子字符串（也就是说，你必须统计 s 的所有子字符串中的唯一字符）。 示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: s = &quot;ABC&quot;</span><br><span class=\"line\">输出: 10</span><br><span class=\"line\">解释: 所有可能的子串为：&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;AB&quot;,&quot;BC&quot; 和 &quot;ABC&quot;。</span><br><span class=\"line\">其中，每一个子串都由独特字符构成。</span><br><span class=\"line\">所以其长度总和为：1 + 1 + 1 + 2 + 2 + 3 = 10</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: s = &quot;ABA&quot;</span><br><span class=\"line\">输出: 8</span><br><span class=\"line\">解释: 除了 countUniqueChars(&quot;ABA&quot;) = 1 之外，其余与示例 1 相同。</span><br></pre></td></tr></table></figure>\n<p>示例 3：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;LEETCODE&quot;</span><br><span class=\"line\">输出：92</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>1 &lt;= s.length &lt;= 10^5</li>\n<li>s 只包含大写英文字符</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<p>题意是求出给定字符串的全部子串中唯一字符的个数，因此只需要计算每个字符能在多少个子串中成为唯一字符，即一个字符分别在第 i,j,k 位出现的话，就应该有 \\((j-i)*(k-j)\\) 个字符串中位于 j 位的该字符是唯一字符。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int uniqueLetterString(string s) &#123;</span><br><span class=\"line\">        map&lt;char,vector&lt;int&gt;&gt; a;</span><br><span class=\"line\">        for(int i=0;i&lt;s.length();i++)&#123;</span><br><span class=\"line\">            a[s[i]].push_back(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        int ans=0;</span><br><span class=\"line\">        for(auto it=a.begin();it!=a.end();it++)&#123;</span><br><span class=\"line\">            vector&lt;int&gt; b;</span><br><span class=\"line\">            b.push_back(-1);</span><br><span class=\"line\">            for(int i=0;i&lt;it-&gt;second.size();i++)&#123;</span><br><span class=\"line\">                b.push_back(it-&gt;second[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            b.push_back(s.length());</span><br><span class=\"line\">            for(int i=1;i&lt;b.size()-1;i++)&#123;</span><br><span class=\"line\">                ans+=(b[i]-b[i-1])*(b[i+1]-b[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度 \\(O (n)\\)</li>\n<li>空间复杂度 \\(O (n)\\)</li>\n</ul>\n",
            "tags": [
                "Hard",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/08/28/LeetCode/793-%E9%98%B6%E4%B9%98%E5%87%BD%E6%95%B0%E5%90%8E-k-%E4%B8%AA%E9%9B%B6/",
            "url": "https://x-17.top/2022/08/28/LeetCode/793-%E9%98%B6%E4%B9%98%E5%87%BD%E6%95%B0%E5%90%8E-k-%E4%B8%AA%E9%9B%B6/",
            "title": "793. 阶乘函数后 K 个零",
            "date_published": "2022-08-28T13:46:52.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/preimage-size-of-factorial-zeroes-function/\">https://leetcode.cn/problems/preimage-size-of-factorial-zeroes-function/</a>f (x) 是 x! 末尾是 0 的数量。回想一下 x! = 1 * 2 * 3 * … * x，且 0! = 1 。 例如， f (3) = 0 ，因为 3! = 6 的末尾没有 0 ；而 f (11) = 2 ，因为 11!= 39916800 末端有 2 个 0 。 给定 k，找出返回能满足 f (x) = k 的非负整数 x 的数量。 示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：k = 0</span><br><span class=\"line\">输出：5</span><br><span class=\"line\">解释：0!, 1!, 2!, 3!, 和 4! 均符合 k = 0 的条件。</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：k = 5</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：没有匹配到这样的 x!，符合 k = 5 的条件。</span><br></pre></td></tr></table></figure>\n<p>示例 3:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: k = 3</span><br><span class=\"line\">输出: 5</span><br></pre></td></tr></table></figure>\n<p>提示:</p>\n<ul>\n<li>\\(0 &lt;= k &lt;= 10^9\\)</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<p>根据题意，只有因子 2 和 5 相乘能得到以 0 为结尾的数。 又因为 2 出现次数远大于 5，因此只需求 5 为因子出现的次数（25 及类似的要记多次），也可分析出所求其实只有 0 和 5 两种结果。（官方代码）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int zeta(long x) &#123;</span><br><span class=\"line\">        int res = 0;</span><br><span class=\"line\">        while (x) &#123;</span><br><span class=\"line\">            res += x / 5;</span><br><span class=\"line\">            x /= 5;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    long long help(int k) &#123;</span><br><span class=\"line\">        long long r = 5LL * k;</span><br><span class=\"line\">        long long l = 0;</span><br><span class=\"line\">        while (l &lt;= r) &#123;</span><br><span class=\"line\">            long long mid = (l + r) / 2;</span><br><span class=\"line\">            if (zeta(mid) &lt; k) &#123;</span><br><span class=\"line\">                l = mid + 1;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                r = mid - 1;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return r + 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    int preimageSizeFZF(int k) &#123;</span><br><span class=\"line\">        return help(k + 1) - help(k);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度：\\(O (log^2k)\\)</li>\n<li>空间复杂度：\\(O (1)\\)</li>\n</ul>\n",
            "tags": [
                "Hard",
                "leetcode每日一题"
            ]
        },
        {
            "id": "https://x-17.top/2022/08/23/LeetCode/782-%E5%8F%98%E4%B8%BA%E6%A3%8B%E7%9B%98/",
            "url": "https://x-17.top/2022/08/23/LeetCode/782-%E5%8F%98%E4%B8%BA%E6%A3%8B%E7%9B%98/",
            "title": "782.变为棋盘",
            "date_published": "2022-08-23T11:14:21.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/transform-to-chessboard/\">https://leetcode.cn/problems/transform-to-chessboard/</a></p>\n<p>一个 n x n 的二维网络 board 仅由 0 和 1 组成 。每次移动，你能任意交换两列或是两行的位置。<br>\n返回 将这个矩阵变为  “棋盘”  所需的最小移动次数 。如果不存在可行的变换，输出 -1。<br>\n“棋盘” 是指任意一格的上下左右四个方向的值均与本身不同的矩阵。<br>\n示例 1:<br>\n<img src=\"https://x-17.top/wp-content/uploads/2022/08/chessboard1-grid.jpg\" alt=\"\"><br>\n 输入: board = [[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]]<br>\n 输出: 2<br>\n 解释：一种可行的变换方式如下，从左到右：<br>\n第一次移动交换了第一列和第二列。<br>\n第二次移动交换了第二行和第三行。<br>\n示例 2:<br>\n<img src=\"https://x-17.top/wp-content/uploads/2022/08/chessboard2-grid.jpg\" alt=\"\"><br>\n 输入: board = [[0, 1], [1, 0]]<br>\n 输出: 0<br>\n 解释：注意左上角的格值为 0 时也是合法的棋盘，也是合法的棋盘.<br>\n 示例 3:<br>\n<img src=\"https://x-17.top/wp-content/uploads/2022/08/chessboard3-grid.jpg\" alt=\"\"><br>\n 输入: board = [[1, 0], [1, 0]]<br>\n 输出: -1<br>\n 解释：任意的变换都不能使这个输入变为合法的棋盘。<br>\n <br>\n提示：<br>\nn == board.length<br>\nn == board[i].length<br>\n2 &lt;= n &lt;= 30<br>\nboard [i][j] 将只包含 0 或 1</p>\n</blockquote>\n<h2 id=\"官方解法\"><a class=\"markdownIt-Anchor\" href=\"#官方解法\">#</a> 官方解法：</h2>\n<p>方法一：分维度计算</p>\n<p>首先需要思考的是对矩阵做一次交换之后，矩阵的变换状态。比如我们以交换列为代表，在对任意两列进行交换之后，可以看到列交换是不会改变任意相邻两行之间的元素异同对应关系，比如相邻两行的两个元素_board_[i][j],<em>board</em> [i+1][j] 原本就相同，任意列交换之后这个两个元素对应的关系保持不变，如果这两个元素本来就不同，经过列交换之后也仍然不同，因此可以推出矩阵一定只能包含有两种不同的行，要么与第一行的元素相同，要么每一行的元素刚好与第一行的元素 “相反”。如果矩阵可以转换为合法的 “棋盘”，假设第 1 行的元素为 [0,1,1,1,0]，则其他行的元素要么为 [0,1,1,1,0]，要么为 [1,0,0,0,1]。最终的棋盘一定只有两种不同的行，要么以 0 开始的 [0,1,0,1,⋯]，要么以 11 开始的 [1,0,1,0,⋯]，因此我们可以推出棋盘也一定可以通过列变换将所有的行变为只有以上两种状态的行，否则无法得到最终合法的 “棋盘”。同时我们可以观察到，先换行再换列跟先换列再换行结果是一样的，因为我们可以先将所有的行调整到正确的位置，再将所有的列调整到正确的位置。行与列之间的变换实际是相互独立的，二者互不影响，列变换不会影响相邻两行的异同关系，行变换不会不会影响相邻两列的异同关系。</p>\n<p>由于最终只有两种不同的行，要达成最终的 “棋盘” 实际上等价于将矩阵的行表示成 0,1 相互交替的状态，如果一个行无法变为 0,1 交替的状态，则我们认为矩阵不存在可行的变换。假设矩阵的某行用 [0,1] 表示之后得到数组为 [0,1,1,1,0,0]，那么只需求出这个数组变成 [0,1,0,1,0,1] 或者 [1,0,1,0,1,0] 的最少交换次数即可。同理，对于矩阵的列也是如此，这就将二维问题变成了两个一维问题。我们实际只需要分别将矩阵的第一行变为最终状态和第一列变为最终状态，最终的矩阵一定为合法 “棋盘”。</p>\n<p>首先我们需要检测矩阵的合法性，即该矩阵是否可以变为合法的 “棋盘”。我们依次检测矩阵的每一行是否是否可以变为 0,1 交替，即变为 [0,1,0,1,⋯],[1,0,1,0,⋯] 两种可能的行；然后依次检测矩阵的每一列是否可以变为 0,10,1 交替，即变为 [0,1,0,1,⋯],[1,0,1,0,⋯] 两种可能的列。设行的数目为 n，检测矩阵的行与列时需要进行如下检测：</p>\n<p>检测每一行和每一列的状态是否合法：由于列变换不改变相邻两行元素的对应关系，因此我们可以知道矩阵的行要么与第 11 行相同，要么与第 11 行 “相反”。设第一行的状态为 <em>rowMask</em>，与之相反对应的状态为 <em>reverseRowMask</em>，我们检测每一行是否属于这两个合法的状态 <em>rowMask,reverseRowMask</em>，如果不合法直接返回，对于列也采用同样的检测方法。由于题目中的行与列的值均为 0 或者 1，且行数和列数最大为 30，我们利用压缩位图来表示每一行或者每一列的状态，可以用一个 32 位整数来表示每一行，其中整数每位上的数字对应着每列上的数字。</p>\n<p>检测每一行和每一列中含有的数字是否合法：检测每一行或者每一列若要变为 0,1 交替的状态，如果 n 为偶数，则每一行中 1 的数目与 0 的数目相等；如果 n 为奇数，则每一行中 1 的数目与 0 的数目相差的绝对值一定为 1。此时我们只需要检测第一行中含有的数字 0,1 的个数是否合法，对于列我们也采用同样的检测方法。由于我们用一个 32 位整数来表示每一行或者每一列，我们只需要要快速计算出整数的二进制位上含有的 1 的数目即可。</p>\n<p>检测不同状态的行数和列数是否合法：我们设矩阵中与第一行相同的行的数量为 <em>count</em>。根据我们之前的推论可知，需要满足两种不同的行交替分情况讨论：如果 n 为偶数，由于必须要满足两种不同的行交替，每种行的数目只能占到总行数的一半，此时一定有 _count_×2=n；如果 n 为奇数，由于必须要满足两种不同的行交替，则另一种行的数量只能为 <em>n−count</em>，由于必须满足交替不同，则二者之间的差值的绝对值一定为 11，因此此时一定满足 ∣2×_count_−n∣=1，满足以上条件才是合法的行数。我们采用同样的方法对矩阵的列数进行检测。</p>\n<p>其次我们求出将矩阵变为棋盘的最少交换次数。分为两种情况讨论:</p>\n<p>如果 n 为偶数，则此时最终的合法棋盘有两种可能，即第一行的元素的第一个元素 <em>board</em> [0][0]=0 或者 <em>board</em> [0][0]=1。我们可以选择将第 1 行变为以 0 开头，此时只需将偶数位上的 0 全部替换为 1 即可；也可以选择将第 1 行变为以 1 开头，此时只需将奇数位上的 0 全部替换为 1 即可。我们可以用位图来快速计算出偶数位或者奇数位上 1 的个数，可以与特定的数进行布尔代数运算即可快速消除奇数位或者偶数位上的 1。</p>\n<p>如果 n 为奇数，则此时最终的合法棋盘只有一种可能，如果第一行中 0 的数目大于 1 的数目，此时第一行只能变为以 0 为开头交替的序列，此时我们只需要将偶数位上的 0 全部变为 1；如果第一行中 0 的数目小于 1 的数目，此时第一行只能交换变为以 1 为开头交替的序列，此时我们只需要将奇数位上的 0 全部变为 1。可以用位图来快速计算出偶数位或者奇数位上 1 的个数，可以与特定的数进行布尔代数运算即可快速消除奇数位或者偶数位上的 1。</p>\n<p>由于我们采用 32 位整数表示每一行或者每一列，在快速计算偶数位或者上的 1 的数目时可以采用位运算掩码。比如 32 位整数 x，我们只保留 x 偶数位上的 1，此时我们需要去掉奇数位上的 1，此时只需将 x 与掩码：</p>\n<p>\\((1010 1010 1010 1010 1010 1010 1010 1010)_2=0xAAAAAAAA\\)</p>\n<p>相与即可；我们只保留 xx 奇数位上的 11，此时我们需要去掉偶数位上的 11，此时只需将 xx 与掩码：</p>\n<p>\\((0101 0101 0101 0101 0101 0101 0101 0101)_2=0x55555555\\)</p>\n<p>相与即可。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int getMoves(int mask, int count, int n) &#123;</span><br><span class=\"line\">        int ones = __builtin_popcount(mask);</span><br><span class=\"line\">        if (n &amp; 1) &#123;</span><br><span class=\"line\">            /* 如果 n 为奇数，则每一行中 1 与 0 的数目相差为 1，且满足相邻行交替 */</span><br><span class=\"line\">            if (abs(n - 2 * ones) != 1  abs(n - 2 * count) != 1 ) &#123;</span><br><span class=\"line\">                return -1;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (ones == (n &gt;&gt; 1)) &#123;</span><br><span class=\"line\">                /* 偶数位变为 1 的最小交换次数 */</span><br><span class=\"line\">                return n / 2 - __builtin_popcount(mask &amp; 0xAAAAAAAA);</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                /* 奇数位变为 1 的最小交换次数 */</span><br><span class=\"line\">                return (n + 1) / 2 - __builtin_popcount(mask &amp; 0x55555555);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; else &#123; </span><br><span class=\"line\">            /* 如果 n 为偶数，则每一行中 1 与 0 的数目相等，且满足相邻行交替 */</span><br><span class=\"line\">            if (ones != (n &gt;&gt; 1)  count != (n &gt;&gt; 1)) &#123;</span><br><span class=\"line\">                return -1;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            /* 偶数位变为 1 的最小交换次数 */</span><br><span class=\"line\">            int count0 = n / 2 - __builtin_popcount(mask &amp; 0xAAAAAAAA);</span><br><span class=\"line\">            /* 奇数位变为 1 的最小交换次数 */</span><br><span class=\"line\">            int count1 = n / 2 - __builtin_popcount(mask &amp; 0x55555555);  </span><br><span class=\"line\">            return min(count0, count1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    int movesToChessboard(vector&lt;vector&lt;int&gt;&gt;&amp; board) &#123;</span><br><span class=\"line\">        int n = board.size();</span><br><span class=\"line\">        int rowMask = 0, colMask = 0;        </span><br><span class=\"line\"></span><br><span class=\"line\">        /* 检查棋盘的第一行与第一列 */</span><br><span class=\"line\">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class=\"line\">            rowMask = (board[0][i] &lt;&lt; i);</span><br><span class=\"line\">            colMask = (board[i][0] &lt;&lt; i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        int reverseRowMask = ((1 &lt;&lt; n) - 1) ^ rowMask;</span><br><span class=\"line\">        int reverseColMask = ((1 &lt;&lt; n) - 1) ^ colMask;</span><br><span class=\"line\">        int rowCnt = 0, colCnt = 0;</span><br><span class=\"line\">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class=\"line\">            int currRowMask = 0;</span><br><span class=\"line\">            int currColMask = 0;</span><br><span class=\"line\">            for (int j = 0; j &lt; n; j++) &#123;</span><br><span class=\"line\">                currRowMask = (board[i][j] &lt;&lt; j);</span><br><span class=\"line\">                currColMask = (board[j][i] &lt;&lt; j);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            /* 检测每一行的状态是否合法 */</span><br><span class=\"line\">            if (currRowMask != rowMask &amp;&amp; currRowMask != reverseRowMask) &#123;</span><br><span class=\"line\">                return -1;</span><br><span class=\"line\">            &#125; else if (currRowMask == rowMask) &#123;</span><br><span class=\"line\">                /* 记录与第一行相同的行数 */</span><br><span class=\"line\">                rowCnt++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            /* 检测每一列的状态是否合法 */</span><br><span class=\"line\">            if (currColMask != colMask &amp;&amp; currColMask != reverseColMask) &#123;</span><br><span class=\"line\">                return -1;</span><br><span class=\"line\">            &#125; else if (currColMask == colMask) &#123;</span><br><span class=\"line\">                /* 记录与第一列相同的列数 */</span><br><span class=\"line\">                colCnt++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        int rowMoves = getMoves(rowMask, rowCnt, n);</span><br><span class=\"line\">        int colMoves = getMoves(colMask, colCnt, n);</span><br><span class=\"line\">        return (rowMoves == -1  colMoves == -1) ? -1 : (rowMoves + colMoves); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>",
            "tags": [
                "Hard",
                "leetcode每日一题"
            ]
        }
    ]
}