{
    "version": "https://jsonfeed.org/version/1",
    "title": "潇十七 • All posts by \"medium\" tag",
    "description": "可生活不是电影，我也少了点运气",
    "home_page_url": "https://x-17.top",
    "items": [
        {
            "id": "https://x-17.top/2022/12/28/LeetCode/1750-%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%A4%E7%AB%AF%E7%9B%B8%E5%90%8C%E5%AD%97%E7%AC%A6%E5%90%8E%E7%9A%84%E6%9C%80%E7%9F%AD%E9%95%BF%E5%BA%A6/",
            "url": "https://x-17.top/2022/12/28/LeetCode/1750-%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%A4%E7%AB%AF%E7%9B%B8%E5%90%8C%E5%AD%97%E7%AC%A6%E5%90%8E%E7%9A%84%E6%9C%80%E7%9F%AD%E9%95%BF%E5%BA%A6/",
            "title": "1750. 删除字符串两端相同字符后的最短长度",
            "date_published": "2022-12-28T09:12:46.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"1750-删除字符串两端相同字符后的最短长度\"><a class=\"markdownIt-Anchor\" href=\"#1750-删除字符串两端相同字符后的最短长度\">#</a> <a href=\"https://leetcode.cn/problems/minimum-length-of-string-after-deleting-similar-ends/description/\">1750. 删除字符串两端相同字符后的最短长度</a></h1>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">minimumLength</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> left = <span class=\"number\">0</span>, right = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right &amp;&amp; s[left] == s[right]) &#123;</span><br><span class=\"line\">            <span class=\"type\">char</span> c = s[left];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (left &lt;= right &amp;&amp; s[left] == c) &#123;</span><br><span class=\"line\">                left++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (left &lt;= right &amp;&amp; s[right] == c) &#123;</span><br><span class=\"line\">                right--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> right - left + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>",
            "tags": [
                "每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/12/26/LeetCode/1759-%E7%BB%9F%E8%AE%A1%E5%90%8C%E6%9E%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%95%B0%E7%9B%AE/",
            "url": "https://x-17.top/2022/12/26/LeetCode/1759-%E7%BB%9F%E8%AE%A1%E5%90%8C%E6%9E%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%95%B0%E7%9B%AE/",
            "title": "1759. 统计同构子字符串的数目",
            "date_published": "2022-12-26T08:59:06.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"1759-统计同构子字符串的数目\"><a class=\"markdownIt-Anchor\" href=\"#1759-统计同构子字符串的数目\">#</a> <a href=\"https://leetcode.cn/problems/count-number-of-homogenous-substrings/description/\">1759. 统计同构子字符串的数目</a></h1>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">countHomogenous</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"type\">long</span> MOD = <span class=\"number\">1e9</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"type\">long</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; s.<span class=\"built_in\">length</span>(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s[i] != s[left]) &#123;</span><br><span class=\"line\">                ans += (i - left) * (i - left + <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">                ans %= MOD;</span><br><span class=\"line\">                left = i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans += (s.<span class=\"built_in\">length</span>() - left) * (s.<span class=\"built_in\">length</span>() + <span class=\"number\">1</span> - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans % MOD;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>",
            "tags": [
                "每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/12/24/LeetCode/1754-%E6%9E%84%E9%80%A0%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%A4%A7%E7%9A%84%E5%90%88%E5%B9%B6%E5%AD%97%E7%AC%A6%E4%B8%B2/",
            "url": "https://x-17.top/2022/12/24/LeetCode/1754-%E6%9E%84%E9%80%A0%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%A4%A7%E7%9A%84%E5%90%88%E5%B9%B6%E5%AD%97%E7%AC%A6%E4%B8%B2/",
            "title": "1754. 构造字典序最大的合并字符串",
            "date_published": "2022-12-24T12:07:51.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"1754-构造字典序最大的合并字符串\"><a class=\"markdownIt-Anchor\" href=\"#1754-构造字典序最大的合并字符串\">#</a> <a href=\"https://leetcode.cn/problems/largest-merge-of-two-strings/description/\">1754. 构造字典序最大的合并字符串</a></h1>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">largestMerge</span><span class=\"params\">(string word1, string word2)</span> </span>&#123;</span><br><span class=\"line\">        string merge;</span><br><span class=\"line\">        <span class=\"type\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; word1.<span class=\"built_in\">size</span>() || j &lt; word2.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &lt; word1.<span class=\"built_in\">size</span>() &amp;&amp; word1.<span class=\"built_in\">substr</span>(i) &gt; word2.<span class=\"built_in\">substr</span>(j)) &#123;</span><br><span class=\"line\">                merge.<span class=\"built_in\">push_back</span>(word1[i++]);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                merge.<span class=\"built_in\">push_back</span>(word2[j++]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> merge;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>",
            "tags": [
                "每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/12/21/LeetCode/1753-%E7%A7%BB%E9%99%A4%E7%9F%B3%E5%AD%90%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86/",
            "url": "https://x-17.top/2022/12/21/LeetCode/1753-%E7%A7%BB%E9%99%A4%E7%9F%B3%E5%AD%90%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86/",
            "title": "1753. 移除石子的最大得分",
            "date_published": "2022-12-21T10:28:50.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"1753-移除石子的最大得分\"><a class=\"markdownIt-Anchor\" href=\"#1753-移除石子的最大得分\">#</a> <a href=\"https://leetcode.cn/problems/maximum-score-from-removing-stones/description/\">1753. 移除石子的最大得分</a></h1>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maximumScore</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b, <span class=\"type\">int</span> c)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> sum = a + b + c;</span><br><span class=\"line\">        <span class=\"type\">int</span> maxVal = <span class=\"built_in\">max</span>(&#123;a, b, c&#125;);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sum - maxVal &lt; maxVal) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> sum - maxVal;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> sum / <span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：$O (1)$</li>\n<li>空间复杂度：$O (1)$</li>\n</ul>\n",
            "tags": [
                "每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/12/20/LeetCode/1760-%E8%A2%8B%E5%AD%90%E9%87%8C%E6%9C%80%E5%B0%91%E6%95%B0%E7%9B%AE%E7%9A%84%E7%90%83/",
            "url": "https://x-17.top/2022/12/20/LeetCode/1760-%E8%A2%8B%E5%AD%90%E9%87%8C%E6%9C%80%E5%B0%91%E6%95%B0%E7%9B%AE%E7%9A%84%E7%90%83/",
            "title": "1760. 袋子里最少数目的球",
            "date_published": "2022-12-20T10:20:52.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"1760-袋子里最少数目的球\"><a class=\"markdownIt-Anchor\" href=\"#1760-袋子里最少数目的球\">#</a> <a href=\"https://leetcode.cn/problems/minimum-limit-of-balls-in-a-bag/description/\">1760. 袋子里最少数目的球</a></h1>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">minimumSize</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> maxOperations)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> left = <span class=\"number\">1</span>, right = *<span class=\"built_in\">max_element</span>(nums.<span class=\"built_in\">begin</span>(), nums.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt;= right) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> y = (left + right) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"type\">long</span> ops = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> x: nums) &#123;</span><br><span class=\"line\">                ops += (x - <span class=\"number\">1</span>) / y;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ops &lt;= maxOperations) &#123;</span><br><span class=\"line\">                ans = y;</span><br><span class=\"line\">                right = y - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                left = y + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：$O (nlogC)$</li>\n<li>空间复杂度：$O (1)$</li>\n</ul>\n",
            "tags": [
                "每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/12/17/LeetCode/1764-%E9%80%9A%E8%BF%87%E8%BF%9E%E6%8E%A5%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E5%BE%97%E5%88%B0%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84/",
            "url": "https://x-17.top/2022/12/17/LeetCode/1764-%E9%80%9A%E8%BF%87%E8%BF%9E%E6%8E%A5%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E5%BE%97%E5%88%B0%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84/",
            "title": "1764. 通过连接另一个数组的子数组得到一个数组",
            "date_published": "2022-12-17T10:23:17.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"1764-通过连接另一个数组的子数组得到一个数组\"><a class=\"markdownIt-Anchor\" href=\"#1764-通过连接另一个数组的子数组得到一个数组\">#</a> <a href=\"https://leetcode.cn/problems/form-array-by-concatenating-subarrays-of-another-array/description/\">1764. 通过连接另一个数组的子数组得到一个数组</a></h1>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">canChoose</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; groups, vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> p = <span class=\"number\">0</span>, q= <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i] == groups[p][q]) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"type\">int</span> j = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (; j &lt; groups[p].<span class=\"built_in\">size</span>(); j++) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (i + j &gt;= nums.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">                        flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (nums[i + j] != groups[p][q + j]) &#123;</span><br><span class=\"line\">                        flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (flag) &#123;</span><br><span class=\"line\">                    i += j - <span class=\"number\">1</span>;</span><br><span class=\"line\">                    p++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p == groups.<span class=\"built_in\">size</span>()) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：$O (n)$</li>\n<li>空间复杂度：$O (1)$</li>\n</ul>\n",
            "tags": [
                "每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/12/16/LeetCode/1785-%E6%9E%84%E6%88%90%E7%89%B9%E5%AE%9A%E5%92%8C%E9%9C%80%E8%A6%81%E6%B7%BB%E5%8A%A0%E7%9A%84%E6%9C%80%E5%B0%91%E5%85%83%E7%B4%A0/",
            "url": "https://x-17.top/2022/12/16/LeetCode/1785-%E6%9E%84%E6%88%90%E7%89%B9%E5%AE%9A%E5%92%8C%E9%9C%80%E8%A6%81%E6%B7%BB%E5%8A%A0%E7%9A%84%E6%9C%80%E5%B0%91%E5%85%83%E7%B4%A0/",
            "title": "1785. 构成特定和需要添加的最少元素",
            "date_published": "2022-12-16T13:02:14.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"1785-构成特定和需要添加的最少元素\"><a class=\"markdownIt-Anchor\" href=\"#1785-构成特定和需要添加的最少元素\">#</a> <a href=\"https://leetcode.cn/problems/minimum-elements-to-add-to-form-a-given-sum/description/\">1785. 构成特定和需要添加的最少元素</a></h1>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">minElements</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> limit, <span class=\"type\">int</span> goal)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"type\">long</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> num : nums) sum += num;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"type\">long</span> del = <span class=\"built_in\">abs</span>(sum - goal);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> del%limit?del/limit + <span class=\"number\">1</span>:del/limit;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：$O (n)$</li>\n<li>空间复杂度：$O (1)$</li>\n</ul>\n",
            "tags": [
                "每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/12/09/LeetCode/1780-%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%97%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A1%A8%E7%A4%BA%E6%88%90%E4%B8%89%E7%9A%84%E5%B9%82%E7%9A%84%E5%92%8C/",
            "url": "https://x-17.top/2022/12/09/LeetCode/1780-%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%97%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A1%A8%E7%A4%BA%E6%88%90%E4%B8%89%E7%9A%84%E5%B9%82%E7%9A%84%E5%92%8C/",
            "title": "1780. 判断一个数字是否可以表示成三的幂的和",
            "date_published": "2022-12-09T09:16:32.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"1780-判断一个数字是否可以表示成三的幂的和\"><a class=\"markdownIt-Anchor\" href=\"#1780-判断一个数字是否可以表示成三的幂的和\">#</a> <a href=\"https://leetcode.cn/problems/check-if-number-is-a-sum-of-powers-of-three/description/\">1780. 判断一个数字是否可以表示成三的幂的和</a></h1>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">checkPowersOfThree</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> flag = <span class=\"number\">16</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (n) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = flag - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"built_in\">pow</span>(<span class=\"number\">3</span>, i) &lt;= n) &#123;</span><br><span class=\"line\">                    n -= <span class=\"built_in\">pow</span>(<span class=\"number\">3</span>, i);</span><br><span class=\"line\">                    flag = i;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (flag == <span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n == <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度：$O (n)$</li>\n<li>空间复杂度：$O (1)$</li>\n</ul>\n",
            "tags": [
                "每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/12/07/LeetCode/1775-%E9%80%9A%E8%BF%87%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C%E7%9B%B8%E7%AD%89/",
            "url": "https://x-17.top/2022/12/07/LeetCode/1775-%E9%80%9A%E8%BF%87%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C%E7%9B%B8%E7%AD%89/",
            "title": "1775. 通过最少操作次数使数组的和相等",
            "date_published": "2022-12-07T09:23:13.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"1775-通过最少操作次数使数组的和相等\"><a class=\"markdownIt-Anchor\" href=\"#1775-通过最少操作次数使数组的和相等\">#</a> <a href=\"https://leetcode.cn/problems/equal-sum-arrays-with-minimum-number-of-operations/description/\">1775. 通过最少操作次数使数组的和相等</a></h1>\n<p>给你两个长度可能不等的整数数组 nums1 和 nums2 。两个数组中的所有值都在 1 到 6 之间（包含 1 和 6）。</p>\n<p>每次操作中，你可以选择 任意 数组中的任意一个整数，将它变成 1 到 6 之间 任意 的值（包含 1 和 6）。</p>\n<p>请你返回使 nums1 中所有数的和与 nums2 中所有数的和相等的最少操作次数。如果无法使两个数组的和相等，请返回 -1 。</p>\n<p>示例 1：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums1 = [1,2,3,4,5,6], nums2 = [1,1,2,2,2,2]</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：你可以通过 3 次操作使 nums1 中所有数的和与 nums2 中所有数的和相等。以下数组下标都从 0 开始。</span><br><span class=\"line\"><span class=\"bullet\">-</span> 将 nums2[0] 变为 6 。 nums1 = [1,2,3,4,5,6], nums2 = [6,1,2,2,2,2] 。</span><br><span class=\"line\"><span class=\"bullet\">-</span> 将 nums1[5] 变为 1 。 nums1 = [1,2,3,4,5,1], nums2 = [6,1,2,2,2,2] 。</span><br><span class=\"line\"><span class=\"bullet\">-</span> 将 nums1[2] 变为 2 。 nums1 = [1,2,2,4,5,1], nums2 = [6,1,2,2,2,2] 。</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums1 = [1,1,1,1,1,1,1], nums2 = [6]</span><br><span class=\"line\">输出：-1</span><br><span class=\"line\">解释：没有办法减少 nums1 的和或者增加 nums2 的和使二者相等。</span><br></pre></td></tr></table></figure>\n<p>示例 3：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums1 = [6,6], nums2 = [1]</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：你可以通过 3 次操作使 nums1 中所有数的和与 nums2 中所有数的和相等。以下数组下标都从 0 开始。</span><br><span class=\"line\"><span class=\"bullet\">-</span> 将 nums1[0] 变为 2 。 nums1 = [2,6], nums2 = [1] 。</span><br><span class=\"line\"><span class=\"bullet\">-</span> 将 nums1[1] 变为 2 。 nums1 = [2,2], nums2 = [1] 。</span><br><span class=\"line\"><span class=\"bullet\">-</span> 将 nums2[0] 变为 4 。 nums1 = [2,2], nums2 = [4] 。</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>1 &lt;= nums1.length, nums2.length &lt;= $10^5$</li>\n<li>1 &lt;= nums1[i], nums2[i] &lt;= 6</li>\n</ul>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">help</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; h1, vector&lt;<span class=\"type\">int</span>&gt;&amp; h2, <span class=\"type\">int</span> diff)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">h</span><span class=\"params\">(<span class=\"number\">7</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"number\">7</span>; ++i) &#123;</span><br><span class=\"line\">            h[<span class=\"number\">6</span> - i] += h1[i];</span><br><span class=\"line\">            h[i - <span class=\"number\">1</span>] += h2[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">5</span>; i &amp;&amp; diff &gt; <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> t = <span class=\"built_in\">min</span>((diff + i - <span class=\"number\">1</span>) / i, h[i]);</span><br><span class=\"line\">            res += t;</span><br><span class=\"line\">            diff -= t * i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">minOperations</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums1, vector&lt;<span class=\"type\">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = nums1.<span class=\"built_in\">size</span>(), m = nums2.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"number\">6</span> * n &lt; m || <span class=\"number\">6</span> * m &lt; n) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">cnt1</span><span class=\"params\">(<span class=\"number\">7</span>, <span class=\"number\">0</span>)</span>, <span class=\"title\">cnt2</span><span class=\"params\">(<span class=\"number\">7</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> diff = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; i : nums1) &#123;</span><br><span class=\"line\">            ++cnt1[i];</span><br><span class=\"line\">            diff += i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; i : nums2) &#123;</span><br><span class=\"line\">            ++cnt2[i];</span><br><span class=\"line\">            diff -= i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!diff) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (diff &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">help</span>(cnt2, cnt1, diff);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">help</span>(cnt1, cnt2, -diff);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：$O (n+m)$</li>\n<li>空间复杂度：$O©$</li>\n</ul>\n",
            "tags": [
                "每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/12/04/LeetCode/1774-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9B%AE%E6%A0%87%E4%BB%B7%E6%A0%BC%E7%9A%84%E7%94%9C%E7%82%B9%E6%88%90%E6%9C%AC/",
            "url": "https://x-17.top/2022/12/04/LeetCode/1774-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9B%AE%E6%A0%87%E4%BB%B7%E6%A0%BC%E7%9A%84%E7%94%9C%E7%82%B9%E6%88%90%E6%9C%AC/",
            "title": "1774. 最接近目标价格的甜点成本",
            "date_published": "2022-12-04T09:10:22.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"1774-最接近目标价格的甜点成本\"><a class=\"markdownIt-Anchor\" href=\"#1774-最接近目标价格的甜点成本\">#</a> <a href=\"https://leetcode.cn/problems/closest-dessert-cost/description/\">1774. 最接近目标价格的甜点成本</a></h1>\n<p>你打算做甜点，现在需要购买配料。目前共有 n 种冰激凌基料和 m 种配料可供选购。而制作甜点需要遵循以下几条规则：</p>\n<ul>\n<li>必须选择 一种 冰激凌基料。</li>\n<li>可以添加 一种或多种 配料，也可以不添加任何配料。</li>\n<li>每种类型的配料 最多两份 。</li>\n</ul>\n<p>给你以下三个输入：</p>\n<ul>\n<li>baseCosts ，一个长度为 n 的整数数组，其中每个 baseCosts [i] 表示第 i 种冰激凌基料的价格。</li>\n<li>toppingCosts，一个长度为 m 的整数数组，其中每个 toppingCosts [i] 表示 一份 第 i 种冰激凌配料的价格。</li>\n<li>target ，一个整数，表示你制作甜点的目标价格。<br>\n你希望自己做的甜点总成本尽可能接近目标价格 target 。</li>\n</ul>\n<p>返回最接近 target 的甜点成本。如果有多种方案，返回 成本相对较低 的一种。</p>\n<p>示例 1：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：baseCosts = [1,7], toppingCosts = [3,4], target = 10</span><br><span class=\"line\">输出：10</span><br><span class=\"line\">解释：考虑下面的方案组合（所有下标均从 0 开始）：</span><br><span class=\"line\"><span class=\"bullet\">-</span> 选择 1 号基料：成本 7</span><br><span class=\"line\"><span class=\"bullet\">-</span> 选择 1 份 0 号配料：成本 1 x 3 = 3</span><br><span class=\"line\"><span class=\"bullet\">-</span> 选择 0 份 1 号配料：成本 0 x 4 = 0</span><br><span class=\"line\">总成本：7 + 3 + 0 = 10 。</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：baseCosts = [2,3], toppingCosts = [4,5,100], target = 18</span><br><span class=\"line\">输出：17</span><br><span class=\"line\">解释：考虑下面的方案组合（所有下标均从 0 开始）：</span><br><span class=\"line\"><span class=\"bullet\">-</span> 选择 1 号基料：成本 3</span><br><span class=\"line\"><span class=\"bullet\">-</span> 选择 1 份 0 号配料：成本 1 x 4 = 4</span><br><span class=\"line\"><span class=\"bullet\">-</span> 选择 2 份 1 号配料：成本 2 x 5 = 10</span><br><span class=\"line\"><span class=\"bullet\">-</span> 选择 0 份 2 号配料：成本 0 x 100 = 0</span><br><span class=\"line\">总成本：3 + 4 + 10 + 0 = 17 。不存在总成本为 18 的甜点制作方案。</span><br></pre></td></tr></table></figure>\n<p>示例 3：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：baseCosts = [3,10], toppingCosts = [2,5], target = 9</span><br><span class=\"line\">输出：8</span><br><span class=\"line\">解释：可以制作总成本为 8 和 10 的甜点。返回 8 ，因为这是成本更低的方案。</span><br></pre></td></tr></table></figure>\n<p>示例 4：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：baseCosts = [10], toppingCosts = [1], target = 1</span><br><span class=\"line\">输出：10</span><br><span class=\"line\">解释：注意，你可以选择不添加任何配料，但你必须选择一种基料。</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>n == baseCosts.length</li>\n<li>m == toppingCosts.length</li>\n<li>1 &lt;= n, m &lt;= 10</li>\n<li>1 &lt;= baseCosts[i], toppingCosts[i] &lt;= $10^4$</li>\n<li>1 &lt;= target &lt;= $10^4$</li>\n</ul>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">closestCost</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; baseCosts, vector&lt;<span class=\"type\">int</span>&gt;&amp; toppingCosts, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> x = *<span class=\"built_in\">min_element</span>(baseCosts.<span class=\"built_in\">begin</span>(), baseCosts.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x &gt;= target) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">bool</span>&gt; <span class=\"title\">can</span><span class=\"params\">(target + <span class=\"number\">1</span>, <span class=\"literal\">false</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">2</span> * target - x;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; b : baseCosts) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (b &lt;= target) &#123;</span><br><span class=\"line\">                can[b] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                res = <span class=\"built_in\">min</span>(res, b);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; t : toppingCosts) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> count = <span class=\"number\">0</span>; count &lt; <span class=\"number\">2</span>; ++count) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = target; i; --i) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (can[i] &amp;&amp; i + t &gt; target) &#123;</span><br><span class=\"line\">                        res = <span class=\"built_in\">min</span>(res, i + t);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (i - t &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        can[i] = can[i] | can[i - t];</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= res - target; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (can[target - i]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> target - i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：$O (target*m)$</li>\n<li>空间复杂度：$O (target)$</li>\n</ul>\n",
            "tags": [
                "每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/12/02/LeetCode/1769-%E7%A7%BB%E5%8A%A8%E6%89%80%E6%9C%89%E7%90%83%E5%88%B0%E6%AF%8F%E4%B8%AA%E7%9B%92%E5%AD%90%E6%89%80%E9%9C%80%E7%9A%84%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%95%B0/",
            "url": "https://x-17.top/2022/12/02/LeetCode/1769-%E7%A7%BB%E5%8A%A8%E6%89%80%E6%9C%89%E7%90%83%E5%88%B0%E6%AF%8F%E4%B8%AA%E7%9B%92%E5%AD%90%E6%89%80%E9%9C%80%E7%9A%84%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%95%B0/",
            "title": "1769. 移动所有球到每个盒子所需的最小操作数",
            "date_published": "2022-12-02T10:29:45.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"1769-移动所有球到每个盒子所需的最小操作数\"><a class=\"markdownIt-Anchor\" href=\"#1769-移动所有球到每个盒子所需的最小操作数\">#</a> <a href=\"https://leetcode.cn/problems/minimum-number-of-operations-to-move-all-balls-to-each-box/description/\">1769. 移动所有球到每个盒子所需的最小操作数</a></h1>\n<p>有 n 个盒子。给你一个长度为 n 的二进制字符串 boxes ，其中 boxes [i] 的值为 ‘0’ 表示第 i 个盒子是 空 的，而 boxes [i] 的值为 ‘1’ 表示盒子里有 一个 小球。</p>\n<p>在一步操作中，你可以将 一个 小球从某个盒子移动到一个与之相邻的盒子中。第 i 个盒子和第 j 个盒子相邻需满足 abs (i - j) == 1 。注意，操作执行后，某些盒子中可能会存在不止一个小球。</p>\n<p>返回一个长度为 n 的数组 answer ，其中 answer [i] 是将所有小球移动到第 i 个盒子所需的 最小 操作数。</p>\n<p>每个 answer [i] 都需要根据盒子的 初始状态 进行计算。</p>\n<p>示例 1：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：boxes = &quot;110&quot;</span><br><span class=\"line\">输出：[1,1,3]</span><br><span class=\"line\">解释：每个盒子对应的最小操作数如下：</span><br><span class=\"line\">1) 第 1 个盒子：将一个小球从第 2 个盒子移动到第 1 个盒子，需要 1 步操作。</span><br><span class=\"line\">2) 第 2 个盒子：将一个小球从第 1 个盒子移动到第 2 个盒子，需要 1 步操作。</span><br><span class=\"line\">3) 第 3 个盒子：将一个小球从第 1 个盒子移动到第 3 个盒子，需要 2 步操作。将一个小球从第 2 个盒子移动到第 3 个盒子，需要 1 步操作。共计 3 步操作。</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：boxes = &quot;001011&quot;</span><br><span class=\"line\">输出：[11,8,5,4,3,4]</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>n == boxes.length</li>\n<li>1 &lt;= n &lt;= 2000</li>\n<li>boxes [i] 为 ‘0’ 或 ‘1’</li>\n</ul>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">minOperations</span><span class=\"params\">(string boxes)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> left = boxes[<span class=\"number\">0</span>] - <span class=\"string\">&#x27;0&#x27;</span>, right = <span class=\"number\">0</span>, operations = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = boxes.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (boxes[i] == <span class=\"string\">&#x27;1&#x27;</span>) &#123;</span><br><span class=\"line\">                right++;</span><br><span class=\"line\">                operations += i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">res</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">        res[<span class=\"number\">0</span>] = operations;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            operations += left - right;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (boxes[i] == <span class=\"string\">&#x27;1&#x27;</span>) &#123;</span><br><span class=\"line\">                left++;</span><br><span class=\"line\">                right--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res[i] = operations;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：$O (n)$</li>\n<li>空间复杂度：$O (1)$</li>\n</ul>\n",
            "tags": [
                "每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/11/28/LeetCode/813-%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E5%80%BC%E5%92%8C%E7%9A%84%E5%88%86%E7%BB%84/",
            "url": "https://x-17.top/2022/11/28/LeetCode/813-%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E5%80%BC%E5%92%8C%E7%9A%84%E5%88%86%E7%BB%84/",
            "title": "813. 最大平均值和的分组",
            "date_published": "2022-11-28T07:32:03.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"813-最大平均值和的分组\"><a class=\"markdownIt-Anchor\" href=\"#813-最大平均值和的分组\">#</a> <a href=\"https://leetcode.cn/problems/largest-sum-of-averages/description/\">813. 最大平均值和的分组</a></h1>\n<p>给定数组 nums 和一个整数 k 。我们将给定的数组 nums 分成 最多 k 个相邻的非空子数组 。 分数 由每个子数组内的平均值的总和构成。</p>\n<p>注意我们必须使用 nums 数组中的每一个数进行分组，并且分数不一定需要是整数。</p>\n<p>返回我们所能得到的最大 分数 是多少。答案误差在 10-6 内被视为是正确的。</p>\n<p>示例 1:</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: nums = [9,1,2,3,9], k = 3</span><br><span class=\"line\">输出: 20.00000</span><br><span class=\"line\">解释: </span><br><span class=\"line\">nums 的最优分组是[9], [1, 2, 3], [9]. 得到的分数是 9 + (1 + 2 + 3) / 3 + 9 = 20. </span><br><span class=\"line\">我们也可以把 nums 分成[9, 1], [2], [3, 9]. </span><br><span class=\"line\">这样的分组得到的分数为 5 + 2 + 6 = 13, 但不是最大值.</span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: nums = [1,2,3,4,5,6,7], k = 4</span><br><span class=\"line\">输出: 20.50000</span><br></pre></td></tr></table></figure>\n<p>提示:</p>\n<ul>\n<li>1 &lt;= nums.length &lt;= 100</li>\n<li>1 &lt;= nums[i] &lt;= $10^4$</li>\n<li>1 &lt;= k &lt;= nums.length</li>\n</ul>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">largestSumOfAverages</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">double</span>&gt; <span class=\"title\">prefix</span><span class=\"params\">(n + <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            prefix[i + <span class=\"number\">1</span>] = prefix[i] + nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">double</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(n + <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            dp[i] = prefix[i] / i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">2</span>; j &lt;= k; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = n; i &gt;= j; i--) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> x = j - <span class=\"number\">1</span>; x &lt; i; x++) &#123;</span><br><span class=\"line\">                    dp[i] = <span class=\"built_in\">max</span>(dp[i], dp[x] + (prefix[i] - prefix[x]) / (i - x));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：$O (k*n^2)$</li>\n<li>空间复杂度：$O (k*n)$</li>\n</ul>\n",
            "tags": [
                "每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/11/25/LeetCode/809-%E6%83%85%E6%84%9F%E4%B8%B0%E5%AF%8C%E7%9A%84%E6%96%87%E5%AD%97/",
            "url": "https://x-17.top/2022/11/25/LeetCode/809-%E6%83%85%E6%84%9F%E4%B8%B0%E5%AF%8C%E7%9A%84%E6%96%87%E5%AD%97/",
            "title": "809. 情感丰富的文字",
            "date_published": "2022-11-25T05:24:06.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"809-情感丰富的文字\"><a class=\"markdownIt-Anchor\" href=\"#809-情感丰富的文字\">#</a> <a href=\"https://leetcode.cn/problems/expressive-words/description/\">809. 情感丰富的文字</a></h1>\n<p>有时候人们会用重复写一些字母来表示额外的感受，比如 “hello” -&gt; “heeellooo”, “hi” -&gt; “hiii”。我们将相邻字母都相同的一串字符定义为相同字母组，例如：“h”, “eee”, “ll”, “ooo”。</p>\n<p>对于一个给定的字符串 S ，如果另一个单词能够通过将一些字母组扩张从而使其和 S 相同，我们将这个单词定义为可扩张的（stretchy）。扩张操作定义如下：选择一个字母组（包含字母 c ），然后往其中添加相同的字母 c 使其长度达到 3 或以上。</p>\n<p>例如，以 “hello” 为例，我们可以对字母组 “o” 扩张得到 “hellooo”，但是无法以同样的方法得到 “helloo” 因为字母组 “oo” 长度小于 3。此外，我们可以进行另一种扩张 “ll” -&gt; “lllll” 以获得 “helllllooo”。如果 s = “helllllooo”，那么查询词 “hello” 是可扩张的，因为可以对它执行这两种扩张操作使得 query = “hello” -&gt; “hellooo” -&gt; “helllllooo” = s。</p>\n<p>输入一组查询单词，输出其中可扩张的单词数量。</p>\n<p>示例：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入： </span><br><span class=\"line\">s = &quot;heeellooo&quot;</span><br><span class=\"line\">words = [&quot;hello&quot;, &quot;hi&quot;, &quot;helo&quot;]</span><br><span class=\"line\">输出：1</span><br><span class=\"line\">解释：</span><br><span class=\"line\">我们能通过扩张 &quot;hello&quot; 的 &quot;e&quot; 和 &quot;o&quot; 来得到 &quot;heeellooo&quot;。</span><br><span class=\"line\">我们不能通过扩张 &quot;helo&quot; 来得到 &quot;heeellooo&quot; 因为 &quot;ll&quot; 的长度小于 3 。</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>1 &lt;= s.length, words.length &lt;= 100</li>\n<li>1 &lt;= words[i].length &lt;= 100</li>\n<li>s 和所有在 words 中的单词都只由小写字母组成。</li>\n</ul>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">expressiveWords</span><span class=\"params\">(string s, vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">const</span> string&amp; word: words) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">expand</span>(s, word)) &#123;</span><br><span class=\"line\">                ++ans;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">expand</span><span class=\"params\">(<span class=\"type\">const</span> string&amp; s, <span class=\"type\">const</span> string&amp; t)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; s.<span class=\"built_in\">size</span>() &amp;&amp; j &lt; t.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s[i] != t[j]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">char</span> ch = s[i];</span><br><span class=\"line\">            <span class=\"type\">int</span> cnti = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (i &lt; s.<span class=\"built_in\">size</span>() &amp;&amp; s[i] == ch) &#123;</span><br><span class=\"line\">                ++cnti;</span><br><span class=\"line\">                ++i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">int</span> cntj = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (j &lt; t.<span class=\"built_in\">size</span>() &amp;&amp; t[j] == ch) &#123;</span><br><span class=\"line\">                ++cntj;</span><br><span class=\"line\">                ++j;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cnti &lt; cntj) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cnti != cntj &amp;&amp; cnti &lt; <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i == s.<span class=\"built_in\">size</span>() &amp;&amp; j == t.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：$O (n|s|+\\sum_i|words_i|)$</li>\n<li>空间复杂度：$O (1)$</li>\n</ul>\n",
            "tags": [
                "每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/11/24/LeetCode/795-%E5%8C%BA%E9%97%B4%E5%AD%90%E6%95%B0%E7%BB%84%E4%B8%AA%E6%95%B0/",
            "url": "https://x-17.top/2022/11/24/LeetCode/795-%E5%8C%BA%E9%97%B4%E5%AD%90%E6%95%B0%E7%BB%84%E4%B8%AA%E6%95%B0/",
            "title": "795. 区间子数组个数",
            "date_published": "2022-11-24T02:35:01.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"795-区间子数组个数\"><a class=\"markdownIt-Anchor\" href=\"#795-区间子数组个数\">#</a> <a href=\"https://leetcode.cn/problems/number-of-subarrays-with-bounded-maximum/description/\">795. 区间子数组个数</a></h1>\n<p>给你一个整数数组 nums 和两个整数：left 及 right 。找出 nums 中连续、非空且其中最大元素在范围 [left, right] 内的子数组，并返回满足条件的子数组的个数。</p>\n<p>生成的测试用例保证结果符合 32-bit 整数范围。</p>\n<p>示例 1：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [2,1,4,3], left = 2, right = 3</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：满足条件的三个子数组：[2], [2, 1], [3]</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [2,9,2,5,6], left = 2, right = 8</span><br><span class=\"line\">输出：7</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>1 &lt;= nums.length &lt;= $10^5$</li>\n<li>0 &lt;= nums[i] &lt;= $10^9$</li>\n<li>0 &lt;= left &lt;= right &lt;= $10^9$</li>\n</ul>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">numSubarrayBoundedMax</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">count</span>(nums, right) - <span class=\"built_in\">count</span>(nums, left - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">count</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> lower)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>, cur = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> x : nums) &#123;</span><br><span class=\"line\">            cur = x &lt;= lower ? cur + <span class=\"number\">1</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">            res += cur;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：$O (n)$</li>\n<li>空间复杂度：$O (1)$</li>\n</ul>\n",
            "tags": [
                "每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/11/21/LeetCode/808-%E5%88%86%E6%B1%A4/",
            "url": "https://x-17.top/2022/11/21/LeetCode/808-%E5%88%86%E6%B1%A4/",
            "title": "808. 分汤",
            "date_published": "2022-11-21T08:36:49.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"808-分汤\"><a class=\"markdownIt-Anchor\" href=\"#808-分汤\">#</a> <a href=\"https://leetcode.cn/problems/soup-servings/description/\">808. 分汤</a></h1>\n<p>有 A 和 B 两种类型 的汤。一开始每种类型的汤有 n 毫升。有四种分配操作：</p>\n<p>提供 100ml 的 汤 A 和 0ml 的 汤 B 。<br>\n提供 75ml 的 汤 A 和 25ml 的 汤 B 。<br>\n提供 50ml 的 汤 A 和 50ml 的 汤 B 。<br>\n提供 25ml 的 汤 A 和 75ml 的 汤 B 。<br>\n当我们把汤分配给某人之后，汤就没有了。每个回合，我们将从四种概率同为 0.25 的操作中进行分配选择。如果汤的剩余量不足以完成某次操作，我们将尽可能分配。当两种类型的汤都分配完时，停止操作。</p>\n<p>注意 不存在先分配 100 ml 汤 B 的操作。</p>\n<p>需要返回的值： 汤 A 先分配完的概率 +  汤 A 和汤 B 同时分配完的概率 / 2。返回值在正确答案 10-5 的范围内将被认为是正确的。</p>\n<p>示例 1:</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: n = 50</span><br><span class=\"line\">输出: 0.62500</span><br><span class=\"line\">解释:如果我们选择前两个操作，A 首先将变为空。</span><br><span class=\"line\">对于第三个操作，A 和 B 会同时变为空。</span><br><span class=\"line\">对于第四个操作，B 首先将变为空。</span><br><span class=\"line\">所以 A 变为空的总概率加上 A 和 B 同时变为空的概率的一半是 0.25 <span class=\"emphasis\">*(1 + 1 + 0.5 + 0)= 0.625。</span></span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: n = 100</span><br><span class=\"line\">输出: 0.71875</span><br></pre></td></tr></table></figure>\n<p>提示:</p>\n<ul>\n<li>0 &lt;= n &lt;= $10^9$</li>\n</ul>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<pre><code class=\"language-C++\">class Solution &#123;\npublic:\n    double soupServings(int n) &#123;\n        n = ceil((double) n / 25);\n        if (n &gt;= 179) &#123;\n            return 1.0;\n        &#125;\n        vector&lt;vector&lt;double&gt;&gt; dp(n + 1, vector&lt;double&gt;(n + 1));\n        dp[0][0] = 0.5;\n        for (int i = 1; i &lt;= n; i++) &#123;\n            dp[0][i] = 1.0;\n        &#125;\n        for (int i = 1; i &lt;= n; i++) &#123;\n            for (int j = 1; j &lt;= n; j++) &#123;\n                dp[i][j] = (dp[max(0, i - 4)][j] + dp[max(0, i - 3)][max(0, j - 1)] +\n                           dp[max(0, i - 2)][max(0, j - 2)] + dp[max(0, i - 1)][max(0, j - 3)]) / 4.0;\n            &#125;\n        &#125;\n        return dp[n][n];\n    &#125;\n&#125;;\n```​​​​​​​\n\n复杂度分析\n\n- 时间复杂度：$O(C^2)\\$\n- 空间复杂度：$O(C^2)\\$\n</code></pre>\n",
            "tags": [
                "每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/11/20/LeetCode/799-%E9%A6%99%E6%A7%9F%E5%A1%94/",
            "url": "https://x-17.top/2022/11/20/LeetCode/799-%E9%A6%99%E6%A7%9F%E5%A1%94/",
            "title": "799. 香槟塔",
            "date_published": "2022-11-20T04:22:37.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"799-香槟塔\"><a class=\"markdownIt-Anchor\" href=\"#799-香槟塔\">#</a> <a href=\"https://leetcode.cn/problems/champagne-tower/description/\">799. 香槟塔</a></h1>\n<p>我们把玻璃杯摆成金字塔的形状，其中 第一层 有 1 个玻璃杯， 第二层 有 2 个，依次类推到第 100 层，每个玻璃杯 (250ml) 将盛有香槟。</p>\n<p>从顶层的第一个玻璃杯开始倾倒一些香槟，当顶层的杯子满了，任何溢出的香槟都会立刻等流量的流向左右两侧的玻璃杯。当左右两边的杯子也满了，就会等流量的流向它们左右两边的杯子，依次类推。（当最底层的玻璃杯满了，香槟会流到地板上）</p>\n<p>例如，在倾倒一杯香槟后，最顶层的玻璃杯满了。倾倒了两杯香槟后，第二层的两个玻璃杯各自盛放一半的香槟。在倒三杯香槟后，第二层的香槟满了 - 此时总共有三个满的玻璃杯。在倒第四杯后，第三层中间的玻璃杯盛放了一半的香槟，他两边的玻璃杯各自盛放了四分之一的香槟，如下图所示。</p>\n<p>现在当倾倒了非负整数杯香槟后，返回第 i 行 j 个玻璃杯所盛放的香槟占玻璃杯容积的比例（ i 和 j 都从 0 开始）。</p>\n<p>示例 1:</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: poured(倾倒香槟总杯数) = 1, query<span class=\"emphasis\">_glass(杯子的位置数) = 1, query_</span>row(行数) = 1</span><br><span class=\"line\">输出: 0.00000</span><br><span class=\"line\">解释: 我们在顶层（下标是（0，0））倒了一杯香槟后，没有溢出，因此所有在顶层以下的玻璃杯都是空的。</span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: poured(倾倒香槟总杯数) = 2, query<span class=\"emphasis\">_glass(杯子的位置数) = 1, query_</span>row(行数) = 1</span><br><span class=\"line\">输出: 0.50000</span><br><span class=\"line\">解释: 我们在顶层（下标是（0，0）倒了两杯香槟后，有一杯量的香槟将从顶层溢出，位于（1，0）的玻璃杯和（1，1）的玻璃杯平分了这一杯香槟，所以每个玻璃杯有一半的香槟。</span><br></pre></td></tr></table></figure>\n<p>示例 3:</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: poured = 100000009, query<span class=\"emphasis\">_row = 33, query_</span>glass = 17</span><br><span class=\"line\">输出: 1.00000</span><br></pre></td></tr></table></figure>\n<p>提示:</p>\n<ul>\n<li>0 &lt;= poured &lt;= $10^9$</li>\n<li>0 &lt;= query_glass &lt;= query_row &lt; 100</li>\n</ul>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">champagneTower</span><span class=\"params\">(<span class=\"type\">int</span> poured, <span class=\"type\">int</span> query_row, <span class=\"type\">int</span> query_glass)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">double</span>&gt; row = &#123;(<span class=\"type\">double</span>)poured&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= query_row; i++) &#123;</span><br><span class=\"line\">            <span class=\"function\">vector&lt;<span class=\"type\">double</span>&gt; <span class=\"title\">nextRow</span><span class=\"params\">(i + <span class=\"number\">1</span>, <span class=\"number\">0.0</span>)</span></span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; row.<span class=\"built_in\">size</span>(); j++) &#123;</span><br><span class=\"line\">                <span class=\"type\">double</span> volume = row[j];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (volume &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    nextRow[j] += (volume - <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">                    nextRow[j + <span class=\"number\">1</span>] += (volume - <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            row = nextRow;</span><br><span class=\"line\">        &#125;            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">min</span>(<span class=\"number\">1.0</span>, row[query_glass]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：$O (n^2)$</li>\n<li>空间复杂度：$O (n)$</li>\n</ul>\n",
            "tags": [
                "每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/11/17/LeetCode/792-%E5%8C%B9%E9%85%8D%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0/",
            "url": "https://x-17.top/2022/11/17/LeetCode/792-%E5%8C%B9%E9%85%8D%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0/",
            "title": "792. 匹配子序列的单词数",
            "date_published": "2022-11-17T05:08:43.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"792-匹配子序列的单词数\"><a class=\"markdownIt-Anchor\" href=\"#792-匹配子序列的单词数\">#</a> <a href=\"https://leetcode.cn/problems/number-of-matching-subsequences/description/\">792. 匹配子序列的单词数</a></h1>\n<p>给定字符串 s 和字符串数组 words, 返回  words [i] 中是 s 的子序列的单词个数 。</p>\n<p>字符串的 子序列 是从原始字符串中生成的新字符串，可以从中删去一些字符 (可以是 none)，而不改变其余字符的相对顺序。</p>\n<ul>\n<li>例如， “ace” 是 “abcde” 的子序列。</li>\n</ul>\n<p>示例 1:</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: s = &quot;abcde&quot;, words = [&quot;a&quot;,&quot;bb&quot;,&quot;acd&quot;,&quot;ace&quot;]</span><br><span class=\"line\">输出: 3</span><br><span class=\"line\">解释: 有三个是 s 的子序列的单词: &quot;a&quot;, &quot;acd&quot;, &quot;ace&quot;。</span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: s = &quot;dsahjpjauf&quot;, words = [&quot;ahjpjau&quot;,&quot;ja&quot;,&quot;ahbwzgqnuk&quot;,&quot;tnmlanowax&quot;]</span><br><span class=\"line\">输出: 2</span><br></pre></td></tr></table></figure>\n<p>提示:</p>\n<ul>\n<li>1 &lt;= s.length &lt;= 5 * $10^4$</li>\n<li>1 &lt;= words.length &lt;= 5000</li>\n<li>1 &lt;= words[i].length &lt;= 50</li>\n<li>words [i] 和 s 都只由小写字母组成。</li>\n</ul>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">numMatchingSubseq</span><span class=\"params\">(string s, vector&lt;string&gt; &amp;words)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">pos</span>(<span class=\"number\">26</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; s.<span class=\"built_in\">size</span>(); ++i) &#123;</span><br><span class=\"line\">            pos[s[i] - <span class=\"string\">&#x27;a&#x27;</span>].<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> res = words.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;w : words) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (w.<span class=\"built_in\">size</span>() &gt; s.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">                --res;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">int</span> p = <span class=\"number\">-1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">char</span> c : w) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">auto</span> &amp;ps = pos[c - <span class=\"string\">&#x27;a&#x27;</span>];</span><br><span class=\"line\">                <span class=\"keyword\">auto</span> it = <span class=\"built_in\">upper_bound</span>(ps.<span class=\"built_in\">begin</span>(), ps.<span class=\"built_in\">end</span>(), p);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (it == ps.<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">                    --res;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                p = *it;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：$O (\\sum_<ruby>i=0}<rp>【</rp><rt>{m-1</rt><rp>】</rp></ruby>size_i*log n)$</li>\n<li>空间复杂度：$O (n)$</li>\n</ul>\n",
            "tags": [
                "每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/11/16/LeetCode/775-%E5%85%A8%E5%B1%80%E5%80%92%E7%BD%AE%E4%B8%8E%E5%B1%80%E9%83%A8%E5%80%92%E7%BD%AE/",
            "url": "https://x-17.top/2022/11/16/LeetCode/775-%E5%85%A8%E5%B1%80%E5%80%92%E7%BD%AE%E4%B8%8E%E5%B1%80%E9%83%A8%E5%80%92%E7%BD%AE/",
            "title": "775. 全局倒置与局部倒置",
            "date_published": "2022-11-16T04:59:50.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"775-全局倒置与局部倒置\"><a class=\"markdownIt-Anchor\" href=\"#775-全局倒置与局部倒置\">#</a> <a href=\"https://leetcode.cn/problems/global-and-local-inversions/description/\">775. 全局倒置与局部倒置</a></h1>\n<p>给你一个长度为 n 的整数数组 nums ，表示由范围 [0, n - 1] 内所有整数组成的一个排列。</p>\n<p>全局倒置 的数目等于满足下述条件不同下标对 (i, j) 的数目：</p>\n<ul>\n<li>\n<p>0 &lt;= i &lt; j &lt; n</p>\n</li>\n<li>\n<p>nums[i] &gt; nums[j]<br>\n 局部倒置 的数目等于满足下述条件的下标 i 的数目：</p>\n</li>\n<li>\n<p>0 &lt;= i &lt; n - 1</p>\n</li>\n<li>\n<p>nums[i] &gt; nums[i + 1]<br>\n 当数组 nums 中 全局倒置 的数量等于 局部倒置 的数量时，返回 true ；否则，返回 false 。</p>\n</li>\n</ul>\n<p>示例 1：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,0,2]</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">解释：有 1 个全局倒置，和 1 个局部倒置。</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,2,0]</span><br><span class=\"line\">输出：false</span><br><span class=\"line\">解释：有 2 个全局倒置，和 1 个局部倒置。</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>n == nums.length</li>\n<li>1 &lt;= n &lt;= $10^5$</li>\n<li>0 &lt;= nums[i] &lt; n</li>\n<li>nums 中的所有整数 互不相同</li>\n<li>nums 是范围 [0, n - 1] 内所有数字组成的一个排列</li>\n</ul>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isIdealPermutation</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">abs</span>(nums[i] - i) &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：$O (n)$</li>\n<li>空间复杂度：$O (1)$</li>\n</ul>\n",
            "tags": [
                "每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/11/13/LeetCode/791-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F/",
            "url": "https://x-17.top/2022/11/13/LeetCode/791-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F/",
            "title": "791. 自定义字符串排序",
            "date_published": "2022-11-13T04:08:11.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"791-自定义字符串排序\"><a class=\"markdownIt-Anchor\" href=\"#791-自定义字符串排序\">#</a> <a href=\"https://leetcode.cn/problems/custom-sort-string/\">791. 自定义字符串排序</a></h1>\n<p>给定两个字符串 order 和 s 。order 的所有单词都是 唯一 的，并且以前按照一些自定义的顺序排序。</p>\n<p>对 s 的字符进行置换，使其与排序的 order 相匹配。更具体地说，如果在 order 中的字符 x 出现字符 y 之前，那么在排列后的字符串中， x 也应该出现在 y 之前。</p>\n<p>返回 满足这个性质的 s 的任意排列 。</p>\n<p>示例 1:</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: order = &quot;cba&quot;, s = &quot;abcd&quot;</span><br><span class=\"line\">输出: &quot;cbad&quot;</span><br><span class=\"line\">解释: </span><br><span class=\"line\">“a”、“b”、“c”是按顺序出现的，所以“a”、“b”、“c”的顺序应该是“c”、“b”、“a”。</span><br><span class=\"line\">因为“d”不是按顺序出现的，所以它可以在返回的字符串中的任何位置。“dcba”、“cdba”、“cbda”也是有效的输出。</span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: order = &quot;cbafg&quot;, s = &quot;abcd&quot;</span><br><span class=\"line\">输出: &quot;cbad&quot;</span><br></pre></td></tr></table></figure>\n<p>提示:</p>\n<ul>\n<li>1 &lt;= order.length &lt;= 26</li>\n<li>1 &lt;= s.length &lt;= 200</li>\n<li>order 和 s 由小写英文字母组成</li>\n<li>order 中的所有字符都 不同</li>\n</ul>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">customSortString</span><span class=\"params\">(string order, string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">val</span><span class=\"params\">(<span class=\"number\">26</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; order.<span class=\"built_in\">size</span>(); ++i) &#123;</span><br><span class=\"line\">            val[order[i] - <span class=\"string\">&#x27;a&#x27;</span>] = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(s.<span class=\"built_in\">begin</span>(), s.<span class=\"built_in\">end</span>(), [&amp;](<span class=\"type\">char</span> c0, <span class=\"type\">char</span> c1) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> val[c0 - <span class=\"string\">&#x27;a&#x27;</span>] &lt; val[c1 - <span class=\"string\">&#x27;a&#x27;</span>];</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：$O (nlogn + C)$</li>\n<li>空间复杂度：$O©$</li>\n</ul>\n",
            "tags": [
                "每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/11/12/LeetCode/790-%E5%A4%9A%E7%B1%B3%E8%AF%BA%E5%92%8C%E6%89%98%E7%B1%B3%E8%AF%BA%E5%B9%B3%E9%93%BA/",
            "url": "https://x-17.top/2022/11/12/LeetCode/790-%E5%A4%9A%E7%B1%B3%E8%AF%BA%E5%92%8C%E6%89%98%E7%B1%B3%E8%AF%BA%E5%B9%B3%E9%93%BA/",
            "title": "790. 多米诺和托米诺平铺",
            "date_published": "2022-11-12T07:35:50.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"790-多米诺和托米诺平铺\"><a class=\"markdownIt-Anchor\" href=\"#790-多米诺和托米诺平铺\">#</a> <a href=\"https://leetcode.cn/problems/domino-and-tromino-tiling/description/\">790. 多米诺和托米诺平铺</a></h1>\n<p>有两种形状的瓷砖：一种是 2 x 1 的多米诺形，另一种是形如 “L” 的托米诺形。两种形状都可以旋转。</p>\n<p><img src=\"http://img.x-17.top/leetcode/lc-domino.jpg\" alt=\"\"></p>\n<p>给定整数 n ，返回可以平铺 2 x n 的面板的方法的数量。返回对 $10^9 + 7$ 取模 的值。</p>\n<p>平铺指的是每个正方形都必须有瓷砖覆盖。两个平铺不同，当且仅当面板上有四个方向上的相邻单元中的两个，使得恰好有一个平铺有一个瓷砖占据两个正方形。</p>\n<p>示例 1:</p>\n<p><img src=\"http://img.x-17.top/leetcode/lc-domino1.jpg\" alt=\"\"></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: n = 3</span><br><span class=\"line\">输出: 5</span><br><span class=\"line\">解释: 五种不同的方法如上所示。</span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: n = 1</span><br><span class=\"line\">输出: 1</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>1 &lt;= n &lt;= 1000</li>\n</ul>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">long</span> <span class=\"type\">long</span> mod = <span class=\"number\">1e9</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">numTilings</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">long</span> <span class=\"type\">long</span>&gt;&gt; <span class=\"built_in\">dp</span>(n + <span class=\"number\">1</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">long</span> <span class=\"type\">long</span>&gt;(<span class=\"number\">4</span>));</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">3</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>] = dp[i - <span class=\"number\">1</span>][<span class=\"number\">3</span>];</span><br><span class=\"line\">            dp[i][<span class=\"number\">1</span>] = (dp[i - <span class=\"number\">1</span>][<span class=\"number\">0</span>] + dp[i - <span class=\"number\">1</span>][<span class=\"number\">2</span>]) % mod;</span><br><span class=\"line\">            dp[i][<span class=\"number\">2</span>] = (dp[i - <span class=\"number\">1</span>][<span class=\"number\">0</span>] + dp[i - <span class=\"number\">1</span>][<span class=\"number\">1</span>]) % mod;</span><br><span class=\"line\">            dp[i][<span class=\"number\">3</span>] = (dp[i - <span class=\"number\">1</span>][<span class=\"number\">0</span>] + dp[i - <span class=\"number\">1</span>][<span class=\"number\">1</span>] + dp[i - <span class=\"number\">1</span>][<span class=\"number\">2</span>] + dp[i - <span class=\"number\">1</span>][<span class=\"number\">3</span>]) % mod;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n][<span class=\"number\">3</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：$O (n)$</li>\n<li>空间复杂度：$O (n)$</li>\n</ul>\n",
            "tags": [
                "每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/11/09/LeetCode/764-%E6%9C%80%E5%A4%A7%E5%8A%A0%E5%8F%B7%E6%A0%87%E5%BF%97/",
            "url": "https://x-17.top/2022/11/09/LeetCode/764-%E6%9C%80%E5%A4%A7%E5%8A%A0%E5%8F%B7%E6%A0%87%E5%BF%97/",
            "title": "764. 最大加号标志",
            "date_published": "2022-11-09T04:03:50.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"764-最大加号标志\"><a class=\"markdownIt-Anchor\" href=\"#764-最大加号标志\">#</a> <a href=\"https://leetcode.cn/problems/largest-plus-sign/description/\">764. 最大加号标志</a></h1>\n<p>在一个 n x n 的矩阵 grid 中，除了在数组 mines 中给出的元素为 0，其他每个元素都为 1。mines [i] = [<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><msub><mi>y</mi><mi>i</mi></msub><mi mathvariant=\"normal\">$</mi><mo stretchy=\"false\">]</mo><mtext>表示</mtext><mi>g</mi><mi>r</mi><mi>i</mi><mi>d</mi><mo stretchy=\"false\">[</mo></mrow><annotation encoding=\"application/x-tex\">x_i, y_i\\$]表示 grid[</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">$</span><span class=\"mclose\">]</span><span class=\"mord cjk_fallback\">表</span><span class=\"mord cjk_fallback\">示</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">d</span><span class=\"mopen\">[</span></span></span></span>x_i$][$y_i$] == 0</p>\n<p>返回  grid 中包含 1 的最大的 轴对齐 加号标志的阶数 。如果未找到加号标志，则返回 0 。</p>\n<p>一个 k 阶由 1 组成的 “轴对称” 加号标志 具有中心网格 grid [r][c] == 1 ，以及 4 个从中心向上、向下、向左、向右延伸，长度为 k-1，由 1 组成的臂。注意，只有加号标志的所有网格要求为 1 ，别的网格可能为 0 也可能为 1 。</p>\n<p>示例 1：</p>\n<p><img src=\"http://img.x-17.top/leetcode/plus1-grid.jpg\" alt=\"\"></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: n = 5, mines = [[4, 2]]</span><br><span class=\"line\">输出: 2</span><br><span class=\"line\">解释: 在上面的网格中，最大加号标志的阶只能是2。一个标志已在图中标出。</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<p><img src=\"http://img.x-17.top/leetcode/plus2-grid.jpg\" alt=\"\"></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: n = 1, mines = [[0, 0]]</span><br><span class=\"line\">输出: 0</span><br><span class=\"line\">解释: 没有加号标志，返回 0 。</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>1 &lt;= n &lt;= 500</li>\n<li>1 &lt;= mines.length &lt;= 5000</li>\n<li>0 &lt;= $x_i, y_i$ &lt; n</li>\n<li>每一对 ($x_i, y_i$) 都 不重复</li>\n</ul>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">orderOfLargestPlusSign</span><span class=\"params\">(<span class=\"type\">int</span> n, vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; mines)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">dp</span>(n, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(n, n));</span><br><span class=\"line\">        unordered_set&lt;<span class=\"type\">int</span>&gt; banned;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;&amp;vec : mines) &#123;</span><br><span class=\"line\">            banned.<span class=\"built_in\">emplace</span>(vec[<span class=\"number\">0</span>] * n + vec[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"comment\">/* left */</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (banned.<span class=\"built_in\">count</span>(i * n + j)) &#123;</span><br><span class=\"line\">                    count = <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    count++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                dp[i][j] = <span class=\"built_in\">min</span>(dp[i][j], count);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            count = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"comment\">/* right */</span> </span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = n - <span class=\"number\">1</span>; j &gt;= <span class=\"number\">0</span>; j--) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (banned.<span class=\"built_in\">count</span>(i * n + j)) &#123;</span><br><span class=\"line\">                    count = <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    count++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                dp[i][j] = <span class=\"built_in\">min</span>(dp[i][j], count);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"comment\">/* up */</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (banned.<span class=\"built_in\">count</span>(j * n + i)) &#123;</span><br><span class=\"line\">                    count = <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    count++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                dp[j][i] = <span class=\"built_in\">min</span>(dp[j][i], count);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            count = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"comment\">/* down */</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = n - <span class=\"number\">1</span>; j &gt;= <span class=\"number\">0</span>; j--) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (banned.<span class=\"built_in\">count</span>(j * n + i)) &#123;</span><br><span class=\"line\">                    count = <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    count++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                dp[j][i] = <span class=\"built_in\">min</span>(dp[j][i], count);</span><br><span class=\"line\">                ans = <span class=\"built_in\">max</span>(ans, dp[j][i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：$O (n^2)$</li>\n<li>空间复杂度：$O (n^2)$</li>\n</ul>\n",
            "tags": [
                "每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/11/07/LeetCode/816-%E6%A8%A1%E7%B3%8A%E5%9D%90%E6%A0%87/",
            "url": "https://x-17.top/2022/11/07/LeetCode/816-%E6%A8%A1%E7%B3%8A%E5%9D%90%E6%A0%87/",
            "title": "816. 模糊坐标",
            "date_published": "2022-11-07T04:09:47.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"816-模糊坐标\"><a class=\"markdownIt-Anchor\" href=\"#816-模糊坐标\">#</a> <a href=\"https://leetcode.cn/problems/ambiguous-coordinates/description/\">816. 模糊坐标</a></h1>\n<p>我们有一些二维坐标，如 “(1, 3)” 或 “(2, 0.5)”，然后我们移除所有逗号，小数点和空格，得到一个字符串 S。返回所有可能的原始字符串到一个列表中。</p>\n<p>原始的坐标表示法不会存在多余的零，所以不会出现类似于 &quot;00&quot;, “0.0”, “0.00”, “1.0”, “001”, &quot;00.01&quot; 或一些其他更小的数来表示坐标。此外，一个小数点前至少存在一个数，所以也不会出现 “.1” 形式的数字。</p>\n<p>最后返回的列表可以是任意顺序的。而且注意返回的两个数字中间（逗号之后）都有一个空格。</p>\n<p>示例 1:</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: &quot;(123)&quot;</span><br><span class=\"line\">输出: [&quot;(1, 23)&quot;, &quot;(12, 3)&quot;, &quot;(1.2, 3)&quot;, &quot;(1, 2.3)&quot;]</span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: &quot;(00011)&quot;</span><br><span class=\"line\">输出:  [&quot;(0.001, 1)&quot;, &quot;(0, 0.011)&quot;]</span><br><span class=\"line\">解释: </span><br><span class=\"line\">0.0, 00, 0001 或 00.01 是不被允许的。</span><br></pre></td></tr></table></figure>\n<p>示例 3:</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: &quot;(0123)&quot;</span><br><span class=\"line\">输出: [&quot;(0, 123)&quot;, &quot;(0, 12.3)&quot;, &quot;(0, 1.23)&quot;, &quot;(0.1, 23)&quot;, &quot;(0.1, 2.3)&quot;, &quot;(0.12, 3)&quot;]</span><br></pre></td></tr></table></figure>\n<p>示例 4:</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: &quot;(100)&quot;</span><br><span class=\"line\">输出: [(10, 0)]</span><br><span class=\"line\">解释: </span><br><span class=\"line\">1.0 是不被允许的。</span><br></pre></td></tr></table></figure>\n<p>提示:</p>\n<ul>\n<li>4 &lt;= S.length &lt;= 12.</li>\n<li>S [0] = “(”, S [S.length - 1] = “)”, 且字符串 S 中的其他元素都是数字。</li>\n</ul>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;string&gt; <span class=\"title\">getPos</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;string&gt; pos;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s[<span class=\"number\">0</span>] != <span class=\"string\">&#x27;0&#x27;</span> || s == <span class=\"string\">&quot;0&quot;</span>) pos.<span class=\"built_in\">push_back</span>(s);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> p = <span class=\"number\">1</span>; p &lt; s.<span class=\"built_in\">size</span>(); ++p) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((p != <span class=\"number\">1</span> &amp;&amp; s[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;0&#x27;</span>) || s.<span class=\"built_in\">back</span>() == <span class=\"string\">&#x27;0&#x27;</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            pos.<span class=\"built_in\">push_back</span>(s.<span class=\"built_in\">substr</span>(<span class=\"number\">0</span>, p) + <span class=\"string\">&quot;.&quot;</span> + s.<span class=\"built_in\">substr</span>(p));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;string&gt; <span class=\"title\">ambiguousCoordinates</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = s.<span class=\"built_in\">size</span>() - <span class=\"number\">2</span>;</span><br><span class=\"line\">        vector&lt;string&gt; res;</span><br><span class=\"line\">        s = s.<span class=\"built_in\">substr</span>(<span class=\"number\">1</span>, s.<span class=\"built_in\">size</span>() - <span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> l = <span class=\"number\">1</span>; l &lt; n; ++l) &#123;</span><br><span class=\"line\">            vector&lt;string&gt; lt = <span class=\"built_in\">getPos</span>(s.<span class=\"built_in\">substr</span>(<span class=\"number\">0</span>, l));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (lt.<span class=\"built_in\">empty</span>()) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            vector&lt;string&gt; rt = <span class=\"built_in\">getPos</span>(s.<span class=\"built_in\">substr</span>(l));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (rt.<span class=\"built_in\">empty</span>()) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; i : lt) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; j : rt) &#123;</span><br><span class=\"line\">                    res.<span class=\"built_in\">push_back</span>(<span class=\"string\">&quot;(&quot;</span> + i + <span class=\"string\">&quot;, &quot;</span> + j + <span class=\"string\">&quot;)&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：$O (n^3)$</li>\n<li>空间复杂度：$O (n^3)$</li>\n</ul>\n",
            "tags": [
                "每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/11/04/LeetCode/754-%E5%88%B0%E8%BE%BE%E7%BB%88%E7%82%B9%E6%95%B0%E5%AD%97/",
            "url": "https://x-17.top/2022/11/04/LeetCode/754-%E5%88%B0%E8%BE%BE%E7%BB%88%E7%82%B9%E6%95%B0%E5%AD%97/",
            "title": "754. 到达终点数字",
            "date_published": "2022-11-04T03:51:34.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"754-到达终点数字\"><a class=\"markdownIt-Anchor\" href=\"#754-到达终点数字\">#</a> <a href=\"https://leetcode.cn/problems/reach-a-number/description/\">754. 到达终点数字</a></h1>\n<p>在一根无限长的数轴上，你站在 0 的位置。终点在 target 的位置。</p>\n<p>你可以做一些数量的移动 numMoves :</p>\n<ul>\n<li>每次你可以选择向左或向右移动。</li>\n<li>第 i 次移动（从  i == 1 开始，到 i == numMoves ），在选择的方向上走 i 步。</li>\n</ul>\n<p>给定整数 target ，返回 到达目标所需的 最小 移动次数 (即最小 numMoves) 。</p>\n<p>示例 1:</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: target = 2</span><br><span class=\"line\">输出: 3</span><br><span class=\"line\">解释:</span><br><span class=\"line\">第一次移动，从 0 到 1 。</span><br><span class=\"line\">第二次移动，从 1 到 -1 。</span><br><span class=\"line\">第三次移动，从 -1 到 2 。</span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: target = 3</span><br><span class=\"line\">输出: 2</span><br><span class=\"line\">解释:</span><br><span class=\"line\">第一次移动，从 0 到 1 。</span><br><span class=\"line\">第二次移动，从 1 到 3 。</span><br></pre></td></tr></table></figure>\n<p>提示:</p>\n<ul>\n<li>$-10^9 &lt;= target &lt;= 10^9$</li>\n<li>target != 0</li>\n</ul>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">reachNumber</span><span class=\"params\">(<span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        target = <span class=\"built_in\">abs</span>(target);</span><br><span class=\"line\">        <span class=\"type\">int</span> k = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (target &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            k++;</span><br><span class=\"line\">            target -= k;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> target % <span class=\"number\">2</span> == <span class=\"number\">0</span> ? k : k + <span class=\"number\">1</span> + k % <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：$O (n)$</li>\n<li>空间复杂度：$O (1)$</li>\n</ul>\n",
            "tags": [
                "每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/11/02/LeetCode/1620-%E7%BD%91%E7%BB%9C%E4%BF%A1%E5%8F%B7%E6%9C%80%E5%A5%BD%E7%9A%84%E5%9D%90%E6%A0%87/",
            "url": "https://x-17.top/2022/11/02/LeetCode/1620-%E7%BD%91%E7%BB%9C%E4%BF%A1%E5%8F%B7%E6%9C%80%E5%A5%BD%E7%9A%84%E5%9D%90%E6%A0%87/",
            "title": "1620. 网络信号最好的坐标",
            "date_published": "2022-11-02T02:14:18.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"1620-网络信号最好的坐标\"><a class=\"markdownIt-Anchor\" href=\"#1620-网络信号最好的坐标\">#</a> <a href=\"https://leetcode.cn/problems/coordinate-with-maximum-network-quality/\">1620. 网络信号最好的坐标</a></h1>\n<p>给你一个数组 towers 和一个整数 radius 。</p>\n<p>数组  towers  中包含一些网络信号塔，其中 towers [i] = [<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><msub><mi>y</mi><mi>i</mi></msub><mo separator=\"true\">,</mo><msub><mi>q</mi><mi>i</mi></msub><mi mathvariant=\"normal\">$</mi><mo stretchy=\"false\">]</mo><mtext> 表示第 </mtext><mi>i</mi><mtext> 个网络信号塔的坐标是 </mtext><mo stretchy=\"false\">(</mo></mrow><annotation encoding=\"application/x-tex\">x_i, y_i, q_i\\$] 表示第 i 个网络信号塔的坐标是 (</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">q</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">$</span><span class=\"mclose\">]</span><span class=\"mord\"> </span><span class=\"mord cjk_fallback\">表</span><span class=\"mord cjk_fallback\">示</span><span class=\"mord cjk_fallback\">第</span><span class=\"mord\"> </span><span class=\"mord mathnormal\">i</span><span class=\"mord\"> </span><span class=\"mord cjk_fallback\">个</span><span class=\"mord cjk_fallback\">网</span><span class=\"mord cjk_fallback\">络</span><span class=\"mord cjk_fallback\">信</span><span class=\"mord cjk_fallback\">号</span><span class=\"mord cjk_fallback\">塔</span><span class=\"mord cjk_fallback\">的</span><span class=\"mord cjk_fallback\">坐</span><span class=\"mord cjk_fallback\">标</span><span class=\"mord cjk_fallback\">是</span><span class=\"mord\"> </span><span class=\"mopen\">(</span></span></span></span>x_i, y_i$) 且信号强度参数为 $q_i$ 。所有坐标都是在  X-Y 坐标系内的 整数 坐标。两个坐标之间的距离用 欧几里得距离 计算。</p>\n<p>整数 radius 表示一个塔 能到达 的 最远距离 。如果一个坐标跟塔的距离在 radius 以内，那么该塔的信号可以到达该坐标。在这个范围以外信号会很微弱，所以 radius 以外的距离该塔是 不能到达的 。</p>\n<p>如果第 i 个塔能到达 (x, y) ，那么该塔在此处的信号为 ⌊$q_i$ / (1 + d)⌋ ，其中 d 是塔跟此坐标的距离。一个坐标的 信号强度 是所有 能到达 该坐标的塔的信号强度之和。</p>\n<p>请你返回数组 [<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>c</mi><mi>x</mi></msub><mo separator=\"true\">,</mo><msub><mi>c</mi><mi>y</mi></msub><mi mathvariant=\"normal\">$</mi><mo stretchy=\"false\">]</mo><mtext>，表示信号强度最大的整数坐标点 </mtext><mo stretchy=\"false\">(</mo></mrow><annotation encoding=\"application/x-tex\">c_x, c_y\\$] ，表示 信号强度 最大的 整数 坐标点 (</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.036108em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">x</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">c</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">y</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mord\">$</span><span class=\"mclose\">]</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord cjk_fallback\">表</span><span class=\"mord cjk_fallback\">示</span><span class=\"mord cjk_fallback\">信</span><span class=\"mord cjk_fallback\">号</span><span class=\"mord cjk_fallback\">强</span><span class=\"mord cjk_fallback\">度</span><span class=\"mord cjk_fallback\">最</span><span class=\"mord cjk_fallback\">大</span><span class=\"mord cjk_fallback\">的</span><span class=\"mord cjk_fallback\">整</span><span class=\"mord cjk_fallback\">数</span><span class=\"mord cjk_fallback\">坐</span><span class=\"mord cjk_fallback\">标</span><span class=\"mord cjk_fallback\">点</span><span class=\"mord\"> </span><span class=\"mopen\">(</span></span></span></span>c_x, c_y$) 。如果有多个坐标网络信号一样大，请你返回字典序最小的 非负 坐标。</p>\n<p>注意：</p>\n<ul>\n<li>坐标 (x1, y1) 字典序比另一个坐标 (x2, y2) 小，需满足以下条件之一：\n<ul>\n<li>要么 x1 &lt; x2 ，</li>\n<li>要么 x1 == x2 且 y1 &lt; y2 。</li>\n</ul>\n</li>\n<li>⌊val⌋ 表示小于等于 val 的最大整数（向下取整函数）。</li>\n</ul>\n<p>示例 1：<br>\n<img src=\"http://img.x-17.top/leetcode/untitled-diagram.png\" alt=\"\"></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：towers = [[1,2,5],[2,1,7],[3,1,9]], radius = 2</span><br><span class=\"line\">输出：[2,1]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">坐标 (2, 1) 信号强度之和为 13</span><br><span class=\"line\"><span class=\"bullet\">-</span> 塔 (2, 1) 强度参数为 7 ，在该点强度为 ⌊7 / (1 + sqrt(0)⌋ = ⌊7⌋ = 7</span><br><span class=\"line\"><span class=\"bullet\">-</span> 塔 (1, 2) 强度参数为 5 ，在该点强度为 ⌊5 / (1 + sqrt(2)⌋ = ⌊2.07⌋ = 2</span><br><span class=\"line\"><span class=\"bullet\">-</span> 塔 (3, 1) 强度参数为 9 ，在该点强度为 ⌊9 / (1 + sqrt(1)⌋ = ⌊4.5⌋ = 4</span><br><span class=\"line\">没有别的坐标有更大的信号强度。</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：towers = [[23,11,21]], radius = 9</span><br><span class=\"line\">输出：[23,11]</span><br><span class=\"line\">解释：由于仅存在一座信号塔，所以塔的位置信号强度最大。</span><br></pre></td></tr></table></figure>\n<p>示例 3：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：towers = [[1,2,13],[2,1,7],[0,1,9]], radius = 2</span><br><span class=\"line\">输出：[1,2]</span><br><span class=\"line\">解释：坐标 (1, 2) 的信号强度最大。</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>1 &lt;= towers.length &lt;= 50</li>\n<li>towers[i].length == 3</li>\n<li>0 &lt;= $x_i, y_i, q_i$ &lt;= 50</li>\n<li>1 &lt;= radius &lt;= 50</li>\n</ul>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">bestCoordinate</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; towers, <span class=\"type\">int</span> radius)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> xMax = INT_MIN, yMax = INT_MIN;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;&amp;tower : towers) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> x = tower[<span class=\"number\">0</span>], y = tower[<span class=\"number\">1</span>];</span><br><span class=\"line\">            xMax = <span class=\"built_in\">max</span>(xMax, x);</span><br><span class=\"line\">            yMax = <span class=\"built_in\">max</span>(yMax, y);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> cx = <span class=\"number\">0</span>, cy = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> maxQuality = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> x = <span class=\"number\">0</span>; x &lt;= xMax; x++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> y = <span class=\"number\">0</span>; y &lt;= yMax; y++) &#123;</span><br><span class=\"line\">                vector&lt;<span class=\"type\">int</span>&gt; coordinate = &#123;x, y&#125;;</span><br><span class=\"line\">                <span class=\"type\">int</span> quality = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;&amp;tower : towers) &#123;</span><br><span class=\"line\">                    <span class=\"type\">int</span> squaredDistance = <span class=\"built_in\">getSquaredDistance</span>(coordinate, tower);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (squaredDistance &lt;= radius * radius) &#123;</span><br><span class=\"line\">                        <span class=\"type\">double</span> distance = <span class=\"built_in\">sqrt</span>((<span class=\"type\">double</span>)squaredDistance);</span><br><span class=\"line\">                        quality += <span class=\"built_in\">floor</span>((<span class=\"type\">double</span>)tower[<span class=\"number\">2</span>] / (<span class=\"number\">1</span> + distance));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (quality &gt; maxQuality) &#123;</span><br><span class=\"line\">                    cx = x;</span><br><span class=\"line\">                    cy = y;</span><br><span class=\"line\">                    maxQuality = quality;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;cx, cy&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getSquaredDistance</span><span class=\"params\">(<span class=\"type\">const</span> vector&lt;<span class=\"type\">int</span>&gt; &amp;coordinate, <span class=\"type\">const</span> vector&lt;<span class=\"type\">int</span>&gt; &amp;tower)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (tower[<span class=\"number\">0</span>] - coordinate[<span class=\"number\">0</span>]) * (tower[<span class=\"number\">0</span>] - coordinate[<span class=\"number\">0</span>]) + (tower[<span class=\"number\">1</span>] - coordinate[<span class=\"number\">1</span>]) * (tower[<span class=\"number\">1</span>] - coordinate[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：$O (n)$</li>\n<li>空间复杂度：$O (1)$</li>\n</ul>\n",
            "tags": [
                "每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/10/31/LeetCode/481-%E7%A5%9E%E5%A5%87%E5%AD%97%E7%AC%A6%E4%B8%B2/",
            "url": "https://x-17.top/2022/10/31/LeetCode/481-%E7%A5%9E%E5%A5%87%E5%AD%97%E7%AC%A6%E4%B8%B2/",
            "title": "481. 神奇字符串",
            "date_published": "2022-10-31T00:40:05.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"481-神奇字符串\"><a class=\"markdownIt-Anchor\" href=\"#481-神奇字符串\">#</a> <a href=\"https://leetcode.cn/problems/magical-string/\">481. 神奇字符串</a></h1>\n<p>神奇字符串 s 仅由 ‘1’ 和 ‘2’ 组成，并需要遵守下面的规则：</p>\n<ul>\n<li>神奇字符串 s 的神奇之处在于，串联字符串中 ‘1’ 和 ‘2’ 的连续出现次数可以生成该字符串。</li>\n</ul>\n<p>s 的前几个元素是 s = “1221121221221121122……” 。如果将 s 中连续的若干 1 和 2 进行分组，可以得到 “1 22 11 2 1 22 1 22 11 2 11 22 …” 。每组中 1 或者 2 的出现次数分别是 “1 2 2 1 1 2 1 2 2 1 2 2 …” 。上面的出现次数正是 s 自身。</p>\n<p>给你一个整数 n ，返回在神奇字符串 s 的前 n 个数字中 1 的数目。</p>\n<p></p>\n<p>示例 1：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：n = 6</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：神奇字符串 s 的前 6 个元素是 “122112”，它包含三个 1，因此返回 3 。 </span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：n = 1</span><br><span class=\"line\">输出：1</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>$1 &lt;= n &lt;= 10^5$</li>\n</ul>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">magicalString</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\">string <span class=\"title\">s</span><span class=\"params\">(n, <span class=\"string\">&#x27;0&#x27;</span>)</span></span>;</span><br><span class=\"line\">        s[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;1&#x27;</span>, s[<span class=\"number\">1</span>] = <span class=\"string\">&#x27;2&#x27;</span>, s[<span class=\"number\">2</span>] = <span class=\"string\">&#x27;2&#x27;</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> i = <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> j = <span class=\"number\">3</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (j &lt; n) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> size = s[i] - <span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> num = <span class=\"number\">3</span> - (s[j - <span class=\"number\">1</span>] - <span class=\"string\">&#x27;0&#x27;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (size &gt; <span class=\"number\">0</span> &amp;&amp; j &lt; n) &#123;</span><br><span class=\"line\">                s[j] = <span class=\"string\">&#x27;0&#x27;</span> + num;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (num == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    ++res;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                ++j;</span><br><span class=\"line\">                --size;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ++i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：$O (n)$</li>\n<li>空间复杂度：$O (n)$</li>\n</ul>\n",
            "tags": [
                "每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/10/30/LeetCode/784-%E5%AD%97%E6%AF%8D%E5%A4%A7%E5%B0%8F%E5%86%99%E5%85%A8%E6%8E%92%E5%88%97/",
            "url": "https://x-17.top/2022/10/30/LeetCode/784-%E5%AD%97%E6%AF%8D%E5%A4%A7%E5%B0%8F%E5%86%99%E5%85%A8%E6%8E%92%E5%88%97/",
            "title": "784. 字母大小写全排列",
            "date_published": "2022-10-30T00:16:54.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"784-字母大小写全排列\"><a class=\"markdownIt-Anchor\" href=\"#784-字母大小写全排列\">#</a> <a href=\"https://leetcode.cn/problems/letter-case-permutation/\">784. 字母大小写全排列</a></h1>\n<p>给定一个字符串 s ，通过将字符串 s 中的每个字母转变大小写，我们可以获得一个新的字符串。</p>\n<p>返回 所有可能得到的字符串集合 。以 任意顺序 返回输出。</p>\n<p></p>\n<p>示例 1：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;a1b2&quot;</span><br><span class=\"line\">输出：[&quot;a1b2&quot;, &quot;a1B2&quot;, &quot;A1b2&quot;, &quot;A1B2&quot;]</span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: s = &quot;3z4&quot;</span><br><span class=\"line\">输出: [&quot;3z4&quot;,&quot;3Z4&quot;]</span><br></pre></td></tr></table></figure>\n<p>提示:</p>\n<ul>\n<li>1 &lt;= s.length &lt;= 12</li>\n<li>s 由小写英文字母、大写英文字母和数字组成</li>\n</ul>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;string&gt; <span class=\"title\">letterCasePermutation</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;string&gt; ans;</span><br><span class=\"line\">        queue&lt;string&gt; qu;</span><br><span class=\"line\">        qu.<span class=\"built_in\">emplace</span>(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!qu.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">            string &amp;curr = qu.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (curr.<span class=\"built_in\">size</span>() == s.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">                ans.<span class=\"built_in\">emplace_back</span>(curr);</span><br><span class=\"line\">                qu.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> pos = curr.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"built_in\">isalpha</span>(s[pos])) &#123;</span><br><span class=\"line\">                    string next = curr;</span><br><span class=\"line\">                    next.<span class=\"built_in\">push_back</span>(s[pos] ^ <span class=\"number\">32</span>);</span><br><span class=\"line\">                    qu.<span class=\"built_in\">emplace</span>(next);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                curr.<span class=\"built_in\">push_back</span>(s[pos]);                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：$O (n*2^n)$</li>\n<li>空间复杂度：$O (n*2^n)$</li>\n</ul>\n",
            "tags": [
                "每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/10/28/LeetCode/907-%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%E4%B9%8B%E5%92%8C/",
            "url": "https://x-17.top/2022/10/28/LeetCode/907-%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%E4%B9%8B%E5%92%8C/",
            "title": "907. 子数组的最小值之和",
            "date_published": "2022-10-28T04:11:33.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"907-子数组的最小值之和\"><a class=\"markdownIt-Anchor\" href=\"#907-子数组的最小值之和\">#</a> <a href=\"https://leetcode.cn/problems/sum-of-subarray-minimums/\">907. 子数组的最小值之和</a></h1>\n<p>给定一个整数数组 arr，找到 min (b) 的总和，其中 b 的范围为 arr 的每个（连续）子数组。</p>\n<p>由于答案可能很大，因此 返回答案模 $10^9 + 7$ 。</p>\n<p></p>\n<p>示例 1：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：arr = [3,1,2,4]</span><br><span class=\"line\">输出：17</span><br><span class=\"line\">解释：</span><br><span class=\"line\">子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。 </span><br><span class=\"line\">最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：arr = [11,81,94,43,3]</span><br><span class=\"line\">输出：444</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>1 &lt;= arr.length &lt;= $3 * 10^4$</li>\n<li>1 &lt;= arr[i] &lt;= $3 * 10^4$</li>\n</ul>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">sumSubarrayMins</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = arr.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"type\">long</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"type\">long</span> mod = <span class=\"number\">1e9</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\">        stack&lt;<span class=\"type\">int</span>&gt; monoStack;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!monoStack.<span class=\"built_in\">empty</span>() &amp;&amp; arr[monoStack.<span class=\"built_in\">top</span>()] &gt; arr[i]) &#123;</span><br><span class=\"line\">                monoStack.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">int</span> k = monoStack.<span class=\"built_in\">empty</span>() ? (i + <span class=\"number\">1</span>) : (i - monoStack.<span class=\"built_in\">top</span>());</span><br><span class=\"line\">            dp[i] = k * arr[i] + (monoStack.<span class=\"built_in\">empty</span>() ? <span class=\"number\">0</span> : dp[i - k]);</span><br><span class=\"line\">            ans = (ans + dp[i]) % mod;</span><br><span class=\"line\">            monoStack.<span class=\"built_in\">emplace</span>(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：$O (n)$</li>\n<li>空间复杂度：$O (n)$</li>\n</ul>\n",
            "tags": [
                "每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/10/25/LeetCode/934-%E6%9C%80%E7%9F%AD%E7%9A%84%E6%A1%A5/",
            "url": "https://x-17.top/2022/10/25/LeetCode/934-%E6%9C%80%E7%9F%AD%E7%9A%84%E6%A1%A5/",
            "title": "934. 最短的桥",
            "date_published": "2022-10-25T01:36:49.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"934-最短的桥\"><a class=\"markdownIt-Anchor\" href=\"#934-最短的桥\">#</a> <a href=\"https://leetcode.cn/problems/shortest-bridge/\">934. 最短的桥</a></h1>\n<p>给你一个大小为 n x n 的二元矩阵 grid ，其中 1 表示陆地，0 表示水域。</p>\n<p>岛 是由四面相连的 1 形成的一个最大组，即不会与非组内的任何其他 1 相连。grid 中 恰好存在两座岛 。</p>\n<p>你可以将任意数量的 0 变为 1 ，以使两座岛连接起来，变成 一座岛 。</p>\n<p>返回必须翻转的 0 的最小数目。</p>\n<p></p>\n<p>示例 1：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：grid = [[0,1],[1,0]]</span><br><span class=\"line\">输出：1</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：grid = [[0,1,0],[0,0,0],[0,0,1]]</span><br><span class=\"line\">输出：2</span><br></pre></td></tr></table></figure>\n<p>示例 3：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：grid = [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]</span><br><span class=\"line\">输出：1</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>n == grid.length == grid[i].length</li>\n<li>2 &lt;= n &lt;= 100</li>\n<li>grid [i][j] 为 0 或 1</li>\n<li>grid 中恰有两个岛</li>\n</ul>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">shortestBridge</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = grid.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; dirs = &#123;&#123;<span class=\"number\">-1</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>&#125;, &#123;<span class=\"number\">0</span>, <span class=\"number\">-1</span>&#125;&#125;;</span><br><span class=\"line\">        vector&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;&gt; island;</span><br><span class=\"line\">        queue&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;&gt; qu;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (grid[i][j] == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    qu.<span class=\"built_in\">emplace</span>(i, j);</span><br><span class=\"line\">                    grid[i][j] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (!qu.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">auto</span> [x, y] = qu.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">                        qu.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                        island.<span class=\"built_in\">emplace_back</span>(x, y);</span><br><span class=\"line\">                        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">0</span>; k &lt; <span class=\"number\">4</span>; k++) &#123;</span><br><span class=\"line\">                            <span class=\"type\">int</span> nx = x + dirs[k][<span class=\"number\">0</span>];</span><br><span class=\"line\">                            <span class=\"type\">int</span> ny = y + dirs[k][<span class=\"number\">1</span>];</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (nx &gt;= <span class=\"number\">0</span> &amp;&amp; ny &gt;= <span class=\"number\">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; n &amp;&amp; grid[nx][ny] == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                                qu.<span class=\"built_in\">emplace</span>(nx, ny);</span><br><span class=\"line\">                                grid[nx][ny] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;&amp;[x, y] : island) &#123;</span><br><span class=\"line\">                        qu.<span class=\"built_in\">emplace</span>(x, y);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"type\">int</span> step = <span class=\"number\">0</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (!qu.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">                        <span class=\"type\">int</span> sz = qu.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">                        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; sz; i++) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">auto</span> [x, y] = qu.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">                            qu.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">0</span>; k &lt; <span class=\"number\">4</span>; k++) &#123;</span><br><span class=\"line\">                                <span class=\"type\">int</span> nx = x + dirs[k][<span class=\"number\">0</span>];</span><br><span class=\"line\">                                <span class=\"type\">int</span> ny = y + dirs[k][<span class=\"number\">1</span>];</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (nx &gt;= <span class=\"number\">0</span> &amp;&amp; ny &gt;= <span class=\"number\">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; n) &#123;</span><br><span class=\"line\">                                    <span class=\"keyword\">if</span> (grid[nx][ny] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                                        qu.<span class=\"built_in\">emplace</span>(nx, ny);</span><br><span class=\"line\">                                        grid[nx][ny] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">                                    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (grid[nx][ny] == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                                        <span class=\"keyword\">return</span> step;</span><br><span class=\"line\">                                    &#125;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        step++;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：$O (n^2)$</li>\n<li>空间复杂度：$O (n^2)$</li>\n</ul>\n",
            "tags": [
                "每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/10/24/LeetCode/915-%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84/",
            "url": "https://x-17.top/2022/10/24/LeetCode/915-%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84/",
            "title": "915. 分割数组",
            "date_published": "2022-10-24T02:45:33.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"915-分割数组\"><a class=\"markdownIt-Anchor\" href=\"#915-分割数组\">#</a> <a href=\"https://leetcode.cn/problems/partition-array-into-disjoint-intervals/\">915. 分割数组</a></h1>\n<p>给定一个数组 nums ，将其划分为两个连续子数组 left 和 right， 使得：</p>\n<p>left 中的每个元素都小于或等于 right 中的每个元素。<br>\nleft 和 right 都是非空的。<br>\nleft 的长度要尽可能小。<br>\n在完成这样的分组后返回 left 的 长度 。</p>\n<p>用例可以保证存在这样的划分方法。</p>\n<p></p>\n<p>示例 1：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [5,0,3,8,6]</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：left = [5,0,3]，right = [8,6]</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,1,1,0,6,12]</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：left = [1,1,1,0]，right = [6,12]</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>2 &lt;= nums.length &lt;= $10^5$</li>\n<li>0 &lt;= nums[i] &lt;= $10^6$</li>\n<li>可以保证至少有一种方法能够按题目所描述的那样对 nums 进行划分。</li>\n</ul>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">partitionDisjoint</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">ma</span><span class=\"params\">(nums.size()+<span class=\"number\">2</span>,<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">mi</span><span class=\"params\">(nums.size()+<span class=\"number\">2</span>,<span class=\"number\">100000000</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;nums.<span class=\"built_in\">size</span>();i++)&#123;</span><br><span class=\"line\">            ma[i+<span class=\"number\">1</span>]=<span class=\"built_in\">max</span>(nums[i],ma[i]);</span><br><span class=\"line\">            mi[nums.<span class=\"built_in\">size</span>()-i]=<span class=\"built_in\">min</span>(nums[nums.<span class=\"built_in\">size</span>()-i<span class=\"number\">-1</span>],mi[nums.<span class=\"built_in\">size</span>()-i+<span class=\"number\">1</span>]);</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=nums.<span class=\"built_in\">size</span>();i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ma[i]&lt;=mi[i+<span class=\"number\">1</span>])</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：$O (n)$</li>\n<li>空间复杂度：$O (n)$</li>\n</ul>\n",
            "tags": [
                "每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/10/21/LeetCode/901-%E8%82%A1%E7%A5%A8%E4%BB%B7%E6%A0%BC%E8%B7%A8%E5%BA%A6/",
            "url": "https://x-17.top/2022/10/21/LeetCode/901-%E8%82%A1%E7%A5%A8%E4%BB%B7%E6%A0%BC%E8%B7%A8%E5%BA%A6/",
            "title": "901. 股票价格跨度",
            "date_published": "2022-10-21T00:37:37.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"901-股票价格跨度\"><a class=\"markdownIt-Anchor\" href=\"#901-股票价格跨度\">#</a> <a href=\"https://leetcode.cn/problems/online-stock-span/\">901. 股票价格跨度</a></h1>\n<p>编写一个 StockSpanner 类，它收集某些股票的每日报价，并返回该股票当日价格的跨度。</p>\n<p>今天股票价格的跨度被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。</p>\n<p>例如，如果未来 7 天股票的价格是 [100, 80, 60, 70, 60, 75, 85]，那么股票跨度将是 [1, 1, 1, 2, 1, 4, 6]。</p>\n<p></p>\n<p>示例：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：[&quot;StockSpanner&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;], [[],[100],[80],[60],[70],[60],[75],[85]]</span><br><span class=\"line\">输出：[null,1,1,1,2,1,4,6]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">首先，初始化 S = StockSpanner()，然后：</span><br><span class=\"line\">S.next(100) 被调用并返回 1，</span><br><span class=\"line\">S.next(80) 被调用并返回 1，</span><br><span class=\"line\">S.next(60) 被调用并返回 1，</span><br><span class=\"line\">S.next(70) 被调用并返回 2，</span><br><span class=\"line\">S.next(60) 被调用并返回 1，</span><br><span class=\"line\">S.next(75) 被调用并返回 4，</span><br><span class=\"line\">S.next(85) 被调用并返回 6。</span><br><span class=\"line\"></span><br><span class=\"line\">注意 (例如) S.next(75) 返回 4，因为截至今天的最后 4 个价格</span><br><span class=\"line\">(包括今天的价格 75) 小于或等于今天的价格。</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>调用 StockSpanner.next (int price) 时，将有 1 &lt;= price &lt;= $10^5$。</li>\n<li>每个测试用例最多可以调用  10000 次 StockSpanner.next。</li>\n<li>在所有测试用例中，最多调用 150000 次 StockSpanner.next。</li>\n<li>此问题的总时间限制减少了 50%。</li>\n</ul>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">StockSpanner</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">StockSpanner</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;stk.<span class=\"built_in\">emplace</span>(<span class=\"number\">-1</span>, INT_MAX);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;idx = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">next</span><span class=\"params\">(<span class=\"type\">int</span> price)</span> </span>&#123;</span><br><span class=\"line\">        idx++;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (price &gt;= stk.<span class=\"built_in\">top</span>().second) &#123;</span><br><span class=\"line\">            stk.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> ret = idx - stk.<span class=\"built_in\">top</span>().first;</span><br><span class=\"line\">        stk.<span class=\"built_in\">emplace</span>(idx, price);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    stack&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;&gt; stk; </span><br><span class=\"line\">    <span class=\"type\">int</span> idx;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：$O (n)$</li>\n<li>空间复杂度：$O (n)$</li>\n</ul>\n",
            "tags": [
                "每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/10/20/LeetCode/779-%E7%AC%ACK%E4%B8%AA%E8%AF%AD%E6%B3%95%E7%AC%A6%E5%8F%B7/",
            "url": "https://x-17.top/2022/10/20/LeetCode/779-%E7%AC%ACK%E4%B8%AA%E8%AF%AD%E6%B3%95%E7%AC%A6%E5%8F%B7/",
            "title": "779. 第K个语法符号",
            "date_published": "2022-10-20T00:00:20.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"779-第k个语法符号\"><a class=\"markdownIt-Anchor\" href=\"#779-第k个语法符号\">#</a> <a href=\"https://leetcode.cn/problems/k-th-symbol-in-grammar/\">779. 第 K 个语法符号</a></h1>\n<p>我们构建了一个包含 n 行 ( 索引从 1  开始 ) 的表。首先在第一行我们写上一个 0。接下来的每一行，将前一行中的 0 替换为 01，1 替换为 10。</p>\n<ul>\n<li>例如，对于 n = 3 ，第 1 行是 0 ，第 2 行是 01 ，第 3 行是 0110 。</li>\n</ul>\n<p>给定行数 n 和序数 k，返回第 n 行中第 k 个字符。（ k 从索引 1 开始）</p>\n<p>示例 1:</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: n = 1, k = 1</span><br><span class=\"line\">输出: 0</span><br><span class=\"line\">解释: 第一行：0</span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: n = 2, k = 1</span><br><span class=\"line\">输出: 0</span><br><span class=\"line\">解释: </span><br><span class=\"line\">第一行: 0 </span><br><span class=\"line\">第二行: 01</span><br></pre></td></tr></table></figure>\n<p>示例 3:</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: n = 2, k = 2</span><br><span class=\"line\">输出: 1</span><br><span class=\"line\">解释:</span><br><span class=\"line\">第一行: 0</span><br><span class=\"line\">第二行: 01</span><br></pre></td></tr></table></figure>\n<p>提示:</p>\n<ul>\n<li>1 &lt;= n &lt;= 30</li>\n<li>1 &lt;= k &lt;= $2^n - 1$</li>\n</ul>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<p>这道题和腾讯笔试题很像。<br>\n本质上每一次操作都是在上一行基础上添加其按位取反后的结果。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">kthGrammar</span><span class=\"params\">(<span class=\"type\">int</span> n, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        k--;</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (k &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            k &amp;= k - <span class=\"number\">1</span>;</span><br><span class=\"line\">            res ^= <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：$O (logk)$</li>\n<li>空间复杂度：$O (1)$</li>\n</ul>\n",
            "tags": [
                "每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/10/17/LeetCode/904-%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE/",
            "url": "https://x-17.top/2022/10/17/LeetCode/904-%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE/",
            "title": "904. 水果成篮",
            "date_published": "2022-10-16T23:32:21.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"904-水果成篮\"><a class=\"markdownIt-Anchor\" href=\"#904-水果成篮\">#</a> <a href=\"https://leetcode.cn/problems/fruit-into-baskets/\">904. 水果成篮</a></h1>\n<p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits [i] 是第 i 棵树上的水果 种类 。</p>\n<p>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</p>\n<p>你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。<br>\n你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。<br>\n一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。<br>\n给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。</p>\n<p>示例 1：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：fruits = [1,2,1]</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：可以采摘全部 3 棵树。</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：fruits = [0,1,2,2]</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：可以采摘 [1,2,2] 这三棵树。</span><br><span class=\"line\">如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。</span><br></pre></td></tr></table></figure>\n<p>示例 3：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：fruits = [1,2,3,2,2]</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：可以采摘 [2,3,2,2] 这四棵树。</span><br><span class=\"line\">如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。</span><br></pre></td></tr></table></figure>\n<p>示例 4：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]</span><br><span class=\"line\">输出：5</span><br><span class=\"line\">解释：可以采摘 [1,2,1,1,2] 这五棵树。</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>$1 &lt;= fruits.length &lt;= 10^5$</li>\n<li>$0 &lt;= fruits[i] &lt; fruits.length$</li>\n</ul>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<p>滑动窗口加哈希表</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">totalFruit</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; fruits)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = fruits.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        unordered_map&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; cnt;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> left = <span class=\"number\">0</span>, ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> right = <span class=\"number\">0</span>; right &lt; n; ++right) &#123;</span><br><span class=\"line\">            ++cnt[fruits[right]];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (cnt.<span class=\"built_in\">size</span>() &gt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">auto</span> it = cnt.<span class=\"built_in\">find</span>(fruits[left]);</span><br><span class=\"line\">                --it-&gt;second;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (it-&gt;second == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    cnt.<span class=\"built_in\">erase</span>(it);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                ++left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ans = <span class=\"built_in\">max</span>(ans, right - left + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：$O (n)$</li>\n<li>空间复杂度：$O (1)$</li>\n</ul>\n",
            "tags": [
                "每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/10/16/LeetCode/886-%E5%8F%AF%E8%83%BD%E7%9A%84%E4%BA%8C%E5%88%86%E6%B3%95/",
            "url": "https://x-17.top/2022/10/16/LeetCode/886-%E5%8F%AF%E8%83%BD%E7%9A%84%E4%BA%8C%E5%88%86%E6%B3%95/",
            "title": "886. 可能的二分法",
            "date_published": "2022-10-16T00:18:27.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"886-可能的二分法\"><a class=\"markdownIt-Anchor\" href=\"#886-可能的二分法\">#</a> <a href=\"https://leetcode.cn/problems/possible-bipartition/https://leetcode.cn/problems/possible-bipartition/\">886. 可能的二分法</a></h1>\n<p>给定一组 n 人（编号为 1, 2, …, n）， 我们想把每个人分进任意大小的两组。每个人都可能不喜欢其他人，那么他们不应该属于同一组。</p>\n<p>给定整数 n 和数组 dislikes ，其中 dislikes [i] = [ai, bi] ，表示不允许将编号为 ai 和  bi 的人归入同一组。当可以用这种方法将所有人分进两组时，返回 true；否则返回 false。</p>\n<p></p>\n<p>示例 1：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：n = 4, dislikes = [[1,2],[1,3],[2,4]]</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">解释：group1 [1,4], group2 [2,3]</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：n = 3, dislikes = [[1,2],[1,3],[2,3]]</span><br><span class=\"line\">输出：false</span><br></pre></td></tr></table></figure>\n<p>示例 3：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：n = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]]</span><br><span class=\"line\">输出：false</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>1 &lt;= n &lt;= 2000</li>\n<li>0 &lt;= dislikes.length &lt;= $10^4$</li>\n<li>dislikes[i].length == 2</li>\n<li>1 &lt;= dislikes[i][j] &lt;= n</li>\n<li>ai &lt; bi</li>\n<li>dislikes 中每一组都 不同</li>\n</ul>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<p>染色法加深搜</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> curnode, <span class=\"type\">int</span> nowcolor, vector&lt;<span class=\"type\">int</span>&gt;&amp; color, <span class=\"type\">const</span> vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; g)</span> </span>&#123;</span><br><span class=\"line\">        color[curnode] = nowcolor;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; nextnode : g[curnode]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (color[nextnode] &amp;&amp; color[nextnode] == color[curnode]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!color[nextnode] &amp;&amp; !<span class=\"built_in\">dfs</span>(nextnode, <span class=\"number\">3</span> ^ nowcolor, color, g)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">possibleBipartition</span><span class=\"params\">(<span class=\"type\">int</span> n, vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; dislikes)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">color</span><span class=\"params\">(n + <span class=\"number\">1</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">g</span>(n + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; p : dislikes) &#123;</span><br><span class=\"line\">            g[p[<span class=\"number\">0</span>]].<span class=\"built_in\">push_back</span>(p[<span class=\"number\">1</span>]);</span><br><span class=\"line\">            g[p[<span class=\"number\">1</span>]].<span class=\"built_in\">push_back</span>(p[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (color[i] == <span class=\"number\">0</span> &amp;&amp; !<span class=\"built_in\">dfs</span>(i, <span class=\"number\">1</span>, color, g)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：$O (n+m)$</li>\n<li>空间复杂度：$O (n+m)$</li>\n</ul>\n",
            "tags": [
                "每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/10/15/LeetCode/1441-%E7%94%A8%E6%A0%88%E6%93%8D%E4%BD%9C%E6%9E%84%E5%BB%BA%E6%95%B0%E7%BB%84/",
            "url": "https://x-17.top/2022/10/15/LeetCode/1441-%E7%94%A8%E6%A0%88%E6%93%8D%E4%BD%9C%E6%9E%84%E5%BB%BA%E6%95%B0%E7%BB%84/",
            "title": "1441. 用栈操作构建数组",
            "date_published": "2022-10-15T00:10:19.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"1441-用栈操作构建数组\"><a class=\"markdownIt-Anchor\" href=\"#1441-用栈操作构建数组\">#</a> <a href=\"https://leetcode.cn/problems/build-an-array-with-stack-operations/\">1441. 用栈操作构建数组</a></h1>\n<p>给你一个数组 target 和一个整数 n。每次迭代，需要从  list = {1 , 2 , 3 …, n} 中依次读取一个数字。</p>\n<p>请使用下述操作来构建目标数组 target ：</p>\n<ul>\n<li>“Push”：从 list 中读取一个新元素， 并将其推入数组中。</li>\n<li>“Pop”：删除数组中的最后一个元素。</li>\n<li>如果目标数组构建完成，就停止读取更多元素。<br>\n题目数据保证目标数组严格递增，并且只包含 1 到 n 之间的数字。</li>\n</ul>\n<p>请返回构建目标数组所用的操作序列。如果存在多个可行方案，返回任一即可。</p>\n<p></p>\n<p>示例 1：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：target = [1,3], n = 3</span><br><span class=\"line\">输出：[&quot;Push&quot;,&quot;Push&quot;,&quot;Pop&quot;,&quot;Push&quot;]</span><br><span class=\"line\">解释： </span><br><span class=\"line\">读取 1 并自动推入数组 -&gt; [1]</span><br><span class=\"line\">读取 2 并自动推入数组，然后删除它 -&gt; [1]</span><br><span class=\"line\">读取 3 并自动推入数组 -&gt; [1,3]</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：target = [1,2,3], n = 3</span><br><span class=\"line\">输出：[&quot;Push&quot;,&quot;Push&quot;,&quot;Push&quot;]</span><br></pre></td></tr></table></figure>\n<p>示例 3：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：target = [1,2], n = 4</span><br><span class=\"line\">输出：[&quot;Push&quot;,&quot;Push&quot;]</span><br><span class=\"line\">解释：只需要读取前 2 个数字就可以停止。</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>1 &lt;= target.length &lt;= 100</li>\n<li>1 &lt;= n &lt;= 100</li>\n<li>1 &lt;= target[i] &lt;= n</li>\n<li>target 严格递增</li>\n</ul>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<p>这道题其实就是模拟压栈出栈操作，使得一个从 1 到 n 的递增序列最终成为在栈中的 target 序列。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;string&gt; <span class=\"title\">buildArray</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; target, <span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;string&gt; ans;</span><br><span class=\"line\">        <span class=\"type\">int</span> flag=<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;target.<span class=\"built_in\">size</span>();)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(target[i]==flag)&#123;</span><br><span class=\"line\">                ans.<span class=\"built_in\">push_back</span>(<span class=\"string\">&quot;Push&quot;</span>);</span><br><span class=\"line\">                flag++;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                ans.<span class=\"built_in\">push_back</span>(<span class=\"string\">&quot;Push&quot;</span>);</span><br><span class=\"line\">                ans.<span class=\"built_in\">push_back</span>(<span class=\"string\">&quot;Pop&quot;</span>);</span><br><span class=\"line\">                flag++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度：$O (n)$</li>\n<li>空间复杂度：$O (1)$</li>\n</ul>\n",
            "tags": [
                "每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/10/13/LeetCode/769-%E6%9C%80%E5%A4%9A%E8%83%BD%E5%AE%8C%E6%88%90%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9D%97/",
            "url": "https://x-17.top/2022/10/13/LeetCode/769-%E6%9C%80%E5%A4%9A%E8%83%BD%E5%AE%8C%E6%88%90%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9D%97/",
            "title": "769. 最多能完成排序的块",
            "date_published": "2022-10-12T23:37:18.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"769-最多能完成排序的块\"><a class=\"markdownIt-Anchor\" href=\"#769-最多能完成排序的块\">#</a> <a href=\"https://leetcode.cn/problems/max-chunks-to-make-sorted/\">769. 最多能完成排序的块</a></h1>\n<p>给定一个长度为 n 的整数数组 arr ，它表示在 [0, n - 1] 范围内的整数的排列。</p>\n<p>我们将 arr 分割成若干 块 (即分区)，并对每个块单独排序。将它们连接起来后，使得连接的结果和按升序排序后的原数组相同。</p>\n<p>返回数组能分成的最多块数量。</p>\n<p>示例 1:</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: arr = [4,3,2,1,0]</span><br><span class=\"line\">输出: 1</span><br><span class=\"line\">解释:</span><br><span class=\"line\">将数组分成2块或者更多块，都无法得到所需的结果。</span><br><span class=\"line\">例如，分成 [4, 3], [2, 1, 0] 的结果是 [3, 4, 0, 1, 2]，这不是有序的数组。</span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: arr = [1,0,2,3,4]</span><br><span class=\"line\">输出: 4</span><br><span class=\"line\">解释:</span><br><span class=\"line\">我们可以把它分成两块，例如 [1, 0], [2, 3, 4]。</span><br><span class=\"line\">然而，分成 [1, 0], [2], [3], [4] 可以得到最多的块数。</span><br></pre></td></tr></table></figure>\n<p>提示:</p>\n<ul>\n<li>n == arr.length</li>\n<li>1 &lt;= n &lt;= 10</li>\n<li>0 &lt;= arr[i] &lt; n</li>\n<li>arr 中每个元素都 不同</li>\n</ul>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<p>其实只要理解题意，这道题很简单，无非就是要我们依次找出数组前缀排序后与原数组排序后相同；又因为数组中的数为 [0,n-1] 并且只有 n 个数，那么一定不会重复；因此我们只需要找出当前前缀最大值和前缀最后一位下标是否相等即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maxChunksToSorted</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> m=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;arr.<span class=\"built_in\">size</span>();i++)&#123;</span><br><span class=\"line\">            m=<span class=\"built_in\">max</span>(arr[i],m);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(m==i)&#123;</span><br><span class=\"line\">                ans++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度：$O (n)$</li>\n<li>空间复杂度：$O (1)$</li>\n</ul>\n",
            "tags": [
                "每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/10/12/LeetCode/817-%E9%93%BE%E8%A1%A8%E7%BB%84%E4%BB%B6/",
            "url": "https://x-17.top/2022/10/12/LeetCode/817-%E9%93%BE%E8%A1%A8%E7%BB%84%E4%BB%B6/",
            "title": "817. 链表组件",
            "date_published": "2022-10-11T23:47:40.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"817-链表组件\"><a class=\"markdownIt-Anchor\" href=\"#817-链表组件\">#</a> <a href=\"https://leetcode.cn/problems/linked-list-components/\">817. 链表组件</a></h1>\n<p>给定链表头结点  <code>head</code> ，该链表上的每个结点都有一个 唯一的整型值 。同时给定列表  <code>nums</code> ，该列表是上述链表中整型值的一个子集。</p>\n<p>返回列表  <code>nums</code>  中组件的个数，这里对组件的定义为：链表中一段最长连续结点的值（该值必须在列表  <code>nums</code>  中）构成的集合。</p>\n<p></p>\n<p>示例 1：</p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/07/22/lc-linkedlistcom1.jpg\" alt=\"\"></p>\n<p>输入: head = [0,1,2,3], nums = [0,1,3]<br>\n 输出: 2<br>\n 解释：链表中，0 和 1 是相连接的，且 nums 中不包含 2，所以 [0, 1] 是 nums 的一个组件，同理 [3] 也是一个组件，故返回 2。<br>\n示例 2：</p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/07/22/lc-linkedlistcom2.jpg\" alt=\"\"></p>\n<p>输入: head = [0,1,2,3,4], nums = [0,3,1,4]<br>\n 输出: 2<br>\n 解释：链表中，0 和 1 是相连接的，3 和 4 是相连接的，所以 [0, 1] 和 [3, 4] 是两个组件，故返回 2。</p>\n<p>提示：</p>\n<ul>\n<li>链表中节点数为 n</li>\n<li>1 &lt;= n &lt;= 104</li>\n<li>0 &lt;= Node.val &lt; n</li>\n<li>Node.val 中所有值 不同</li>\n<li>1 &lt;= nums.length &lt;= n</li>\n<li>0 &lt;= nums[i] &lt; n</li>\n<li>nums 中所有值 不同</li>\n</ul>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<p>根据题意，我们只需要找出数组中的 在链表中是连续的数 的组数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">numComponents</span><span class=\"params\">(ListNode* head, vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">        unordered_set&lt;<span class=\"type\">int</span>&gt; m;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;nums.<span class=\"built_in\">size</span>();i++)&#123;</span><br><span class=\"line\">            m.<span class=\"built_in\">emplace</span>(nums[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> flag=<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(head!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(flag&amp;&amp;m.<span class=\"built_in\">count</span>(head-&gt;val))&#123;</span><br><span class=\"line\">                flag=<span class=\"number\">0</span>;</span><br><span class=\"line\">                head=head-&gt;next;</span><br><span class=\"line\">                ans++;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(!flag&amp;&amp;m.<span class=\"built_in\">count</span>(head-&gt;val))&#123;</span><br><span class=\"line\">                head=head-&gt;next;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                flag=<span class=\"number\">1</span>;</span><br><span class=\"line\">                head=head-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：$O (n)$</li>\n<li>空间复杂度：$O (m)$</li>\n</ul>\n",
            "tags": [
                "每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/10/09/LeetCode/856-%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%88%86%E6%95%B0/",
            "url": "https://x-17.top/2022/10/09/LeetCode/856-%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%88%86%E6%95%B0/",
            "title": "856. 括号的分数",
            "date_published": "2022-10-09T00:11:15.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"856-括号的分数\"><a class=\"markdownIt-Anchor\" href=\"#856-括号的分数\">#</a> <a href=\"https://leetcode.cn/problems/score-of-parentheses/\">856. 括号的分数</a></h1>\n<p>给定一个平衡括号字符串 S，按下述规则计算该字符串的分数：</p>\n<ul>\n<li>\n<p>() 得 1 分。</p>\n</li>\n<li>\n<p>AB 得 A + B 分，其中 A 和 B 是平衡括号字符串。</p>\n</li>\n<li>\n<p>(A) 得 2 * A 分，其中 A 是平衡括号字符串。</p>\n</li>\n</ul>\n<p>示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入： &quot;()&quot;</span><br><span class=\"line\">输出： 1</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入： &quot;(())&quot;</span><br><span class=\"line\">输出： 2</span><br></pre></td></tr></table></figure>\n<p>示例 3：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入： &quot;()()&quot;</span><br><span class=\"line\">输出： 2</span><br></pre></td></tr></table></figure>\n<p>示例 4：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入： &quot;(()(()))&quot;</span><br><span class=\"line\">输出： 6</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>\n<p>S 是平衡括号字符串，且只含有 ( 和 ) 。</p>\n</li>\n<li>\n<p>2 &lt;= S.length &lt;= 50</p>\n</li>\n</ul>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<p>根据题意，我们可以求每组 &quot;()“对应的深度 d，那么 $2^d$ 就是这组”()&quot; 所贡献的分数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">scoreOfParentheses</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> ans=<span class=\"number\">0</span>,flag=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;s.<span class=\"built_in\">length</span>();i++)&#123;</span><br><span class=\"line\">            flag+=(s[i]==<span class=\"string\">&#x27;(&#x27;</span>?<span class=\"number\">1</span>:<span class=\"number\">-1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[i]==<span class=\"string\">&#x27;)&#x27;</span>&amp;&amp;s[i<span class=\"number\">-1</span>]==<span class=\"string\">&#x27;(&#x27;</span>)&#123;</span><br><span class=\"line\">                ans+=<span class=\"number\">1</span>&lt;&lt;flag;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析</p>\n<ul>\n<li>时间复杂度：$O (n)$</li>\n<li>空间复杂度：$O (1)$</li>\n</ul>\n",
            "tags": [
                "每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/10/08/LeetCode/870-%E4%BC%98%E5%8A%BF%E6%B4%97%E7%89%8C/",
            "url": "https://x-17.top/2022/10/08/LeetCode/870-%E4%BC%98%E5%8A%BF%E6%B4%97%E7%89%8C/",
            "title": "870. 优势洗牌",
            "date_published": "2022-10-08T07:32:59.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"870-优势洗牌\"><a class=\"markdownIt-Anchor\" href=\"#870-优势洗牌\">#</a> <a href=\"https://leetcode.cn/problems/advantage-shuffle/\">870. 优势洗牌</a></h1>\n<p>给定两个大小相等的数组 nums1 和 nums2，nums1 相对于 nums2 的优势可以用满足 nums1 [i] &gt; nums2 [i] 的索引 i 的数目来描述。</p>\n<p>返回 nums1 的任意排列，使其相对于 nums2 的优势最大化。</p>\n<p></p>\n<p>示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums1 = [2,7,11,15], nums2 = [1,10,4,11]</span><br><span class=\"line\">输出：[2,11,7,15]</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums1 = [12,24,8,32], nums2 = [13,25,32,11]</span><br><span class=\"line\">输出：[24,32,8,12]</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>\n<p>1 &lt;= nums1.length &lt;= 105</p>\n</li>\n<li>\n<p>nums2.length == nums1.length</p>\n</li>\n<li>\n<p>0 &lt;= nums1[i], nums2[i] &lt;= 109</p>\n</li>\n</ul>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">advantageCount</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt; &amp;nums1, vector&lt;<span class=\"type\">int</span>&gt; &amp;nums2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = nums1.<span class=\"built_in\">size</span>(), ids[n];</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">ans</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(nums1.<span class=\"built_in\">begin</span>(), nums1.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"built_in\">iota</span>(ids, ids + n, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(ids, ids + n, [&amp;](<span class=\"type\">int</span> i, <span class=\"type\">int</span> j) &#123; <span class=\"keyword\">return</span> nums2[i] &lt; nums2[j]; &#125;);</span><br><span class=\"line\">        <span class=\"type\">int</span> left = <span class=\"number\">0</span>, right = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> x : nums1)</span><br><span class=\"line\">            ans[x &gt; nums2[ids[left]] ? ids[left++] : ids[right--]] = x;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度：$$O (nlogn)$$</li>\n<li>空间复杂度：$$O (n)$$</li>\n</ul>\n",
            "tags": [
                "leetcode每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/10/05/LeetCode/811-%E5%AD%90%E5%9F%9F%E5%90%8D%E8%AE%BF%E9%97%AE%E8%AE%A1%E6%95%B0/",
            "url": "https://x-17.top/2022/10/05/LeetCode/811-%E5%AD%90%E5%9F%9F%E5%90%8D%E8%AE%BF%E9%97%AE%E8%AE%A1%E6%95%B0/",
            "title": "811. 子域名访问计数",
            "date_published": "2022-10-04T23:48:49.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"811-子域名访问计数\"><a class=\"markdownIt-Anchor\" href=\"#811-子域名访问计数\">#</a> <a href=\"https://leetcode.cn/problems/subdomain-visit-count/\">811. 子域名访问计数</a></h1>\n<blockquote>\n<p>网站域名 “<a href=\"http://discuss.leetcode.com\">discuss.leetcode.com</a>” 由多个子域名组成。顶级域名为 “com” ，二级域名为 “<a href=\"http://leetcode.com\">leetcode.com</a>” ，最低一级为 “<a href=\"http://discuss.leetcode.com\">discuss.leetcode.com</a>” 。当访问域名 “<a href=\"http://discuss.leetcode.com\">discuss.leetcode.com</a>” 时，同时也会隐式访问其父域名 “<a href=\"http://leetcode.com\">leetcode.com</a>” 以及 “com” 。</p>\n<p>计数配对域名 是遵循 “rep d1.d2.d3” 或 “rep d1.d2” 格式的一个域名表示，其中 rep 表示访问域名的次数，d1.d2.d3 为域名本身。</p>\n<p>例如，“9001 <a href=\"http://discuss.leetcode.com\">discuss.leetcode.com</a>” 就是一个 计数配对域名 ，表示 <a href=\"http://discuss.leetcode.com\">discuss.leetcode.com</a> 被访问了 9001 次。<br>\n给你一个 计数配对域名 组成的数组 cpdomains ，解析得到输入中每个子域名对应的 计数配对域名 ，并以数组形式返回。可以按 任意顺序 返回答案。</p>\n<p>示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：cpdomains = [&quot;9001 discuss.leetcode.com&quot;]</span><br><span class=\"line\">输出：[&quot;9001 leetcode.com&quot;,&quot;9001 discuss.leetcode.com&quot;,&quot;9001 com&quot;]</span><br><span class=\"line\">解释：例子中仅包含一个网站域名：&quot;discuss.leetcode.com&quot;。</span><br><span class=\"line\">按照前文描述，子域名 &quot;leetcode.com&quot; 和 &quot;com&quot; 都会被访问，所以它们都被访问了 9001 次。</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：cpdomains = [&quot;900 google.mail.com&quot;, &quot;50 yahoo.com&quot;, &quot;1 intel.mail.com&quot;, &quot;5 wiki.org&quot;]</span><br><span class=\"line\">输出：[&quot;901 mail.com&quot;,&quot;50 yahoo.com&quot;,&quot;900 google.mail.com&quot;,&quot;5 wiki.org&quot;,&quot;5 org&quot;,&quot;1 intel.mail.com&quot;,&quot;951 com&quot;]</span><br><span class=\"line\">解释：按照前文描述，会访问 &quot;google.mail.com&quot; 900 次，&quot;yahoo.com&quot; 50 次，&quot;intel.mail.com&quot; 1 次，&quot;wiki.org&quot; 5 次。</span><br><span class=\"line\">而对于父域名，会访问 &quot;mail.com&quot; 900 + 1 = 901 次，&quot;com&quot; 900 + 50 + 1 = 951 次，和 &quot;org&quot; 5 次。</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>\n<p>1 &lt;= cpdomain.length &lt;= 100</p>\n</li>\n<li>\n<p>1 &lt;= cpdomain[i].length &lt;= 100</p>\n</li>\n<li>\n<p>cpdomain [i] 会遵循 “repi d1i.d2i.d3i” 或 “repi d1i.d2i” 格式</p>\n</li>\n<li>\n<p>repi 是范围 [1, 104] 内的一个整数</p>\n</li>\n<li>\n<p>d1i、d2i 和 d3i 由小写英文字母组成</p>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;string&gt; <span class=\"title\">subdomainVisits</span><span class=\"params\">(vector&lt;string&gt;&amp; cpdomains)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;string&gt; ans;</span><br><span class=\"line\">        unordered_map&lt;string, <span class=\"type\">int</span>&gt; counts;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;&amp;cpdomain : cpdomains) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> space = cpdomain.<span class=\"built_in\">find</span>(<span class=\"string\">&#x27; &#x27;</span>);</span><br><span class=\"line\">            <span class=\"type\">int</span> count = <span class=\"built_in\">stoi</span>(cpdomain.<span class=\"built_in\">substr</span>(<span class=\"number\">0</span>, space));</span><br><span class=\"line\">            string domain = cpdomain.<span class=\"built_in\">substr</span>(space + <span class=\"number\">1</span>);</span><br><span class=\"line\">            counts[domain] += count;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; domain.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (domain[i] == <span class=\"string\">&#x27;.&#x27;</span>) &#123;</span><br><span class=\"line\">                    string subdomain = domain.<span class=\"built_in\">substr</span>(i + <span class=\"number\">1</span>);</span><br><span class=\"line\">                    counts[subdomain] += count;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;&amp;[subdomain, count] : counts) &#123;</span><br><span class=\"line\">            ans.<span class=\"built_in\">emplace_back</span>(<span class=\"built_in\">to_string</span>(count) + <span class=\"string\">&quot; &quot;</span> + subdomain);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"时间复杂度\"><a class=\"markdownIt-Anchor\" href=\"#时间复杂度\">#</a> 时间复杂度</h2>\n<ul>\n<li>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></li>\n<li>空间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></li>\n</ul>\n",
            "tags": [
                "leetcode每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/10/02/LeetCode/777-%E5%9C%A8lr%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E4%BA%A4%E6%8D%A2%E7%9B%B8%E9%82%BB%E5%AD%97%E7%AC%A6/",
            "url": "https://x-17.top/2022/10/02/LeetCode/777-%E5%9C%A8lr%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E4%BA%A4%E6%8D%A2%E7%9B%B8%E9%82%BB%E5%AD%97%E7%AC%A6/",
            "title": "777. 在LR字符串中交换相邻字符",
            "date_published": "2022-10-01T23:42:54.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/swap-adjacent-in-lr-string/\">https://leetcode.cn/problems/swap-adjacent-in-lr-string/</a> 在一个由 ‘L’ , ‘R’ 和 ‘X’ 三个字符组成的字符串（例如 &quot;RXXLRXRXL&quot;）中进行移动操作。一次移动操作指用一个 &quot;LX&quot; 替换一个 &quot;XL&quot;，或者用一个 &quot;XR&quot; 替换一个 &quot;RX&quot;。现给定起始字符串 start 和结束字符串 end，请编写代码，当且仅当存在一系列移动操作使得 start 可以转换成 end 时， 返回 True。 示例 :</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: start = &quot;RXXLRXRXL&quot;, end = &quot;XRLXXRRLX&quot;</span><br><span class=\"line\">输出: True</span><br><span class=\"line\">解释:</span><br><span class=\"line\">我们可以通过以下几步将start转换成end:</span><br><span class=\"line\">RXXLRXRXL -&gt;</span><br><span class=\"line\">XRXLRXRXL -&gt;</span><br><span class=\"line\">XRLXRXRXL -&gt;</span><br><span class=\"line\">XRLXXRRXL -&gt;</span><br><span class=\"line\">XRLXXRRLX</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>1 &lt;= len(start) = len(end) &lt;= 10000。</li>\n<li>start 和 end 中的字符串仅限于’L’, ‘R’和’X’。</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    bool canTransform(string start, string end) &#123;</span><br><span class=\"line\">        int n = start.length();</span><br><span class=\"line\">        int i = 0, j = 0;</span><br><span class=\"line\">        while (i &lt; n &amp;&amp; j &lt; n) &#123;</span><br><span class=\"line\">            while (i &lt; n &amp;&amp; start[i] == &#x27;X&#x27;) &#123;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            while (j &lt; n &amp;&amp; end[j] == &#x27;X&#x27;) &#123;</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (i &lt; n &amp;&amp; j &lt; n) &#123;</span><br><span class=\"line\">                if (start[i] != end[j]) &#123;</span><br><span class=\"line\">                    return false;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                char c = start[i];</span><br><span class=\"line\">                if ((c == &#x27;L&#x27; &amp;&amp; i &lt; j)  (c == &#x27;R&#x27; &amp;&amp; i &gt; j)) &#123;</span><br><span class=\"line\">                    return false;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        while (i &lt; n) &#123;</span><br><span class=\"line\">            if (start[i] != &#x27;X&#x27;) &#123;</span><br><span class=\"line\">                return false;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        while (j &lt; n) &#123;</span><br><span class=\"line\">            if (end[j] != &#x27;X&#x27;) &#123;</span><br><span class=\"line\">                return false;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度 \\(O (n)\\)</li>\n<li>空间复杂度 \\(O (1)\\)</li>\n</ul>\n",
            "tags": [
                "leetcode每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/09/30/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%98-01-08-%E9%9B%B6%E7%9F%A9%E9%98%B5/",
            "url": "https://x-17.top/2022/09/30/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%98-01-08-%E9%9B%B6%E7%9F%A9%E9%98%B5/",
            "title": "面试题 01.08. 零矩阵",
            "date_published": "2022-09-29T23:41:21.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/zero-matrix-lcci/\">https://leetcode.cn/problems/zero-matrix-lcci/</a> 编写一种算法，若 M × N 矩阵中某个元素为 0，则将其所在的行与列清零。 示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\">[</span><br><span class=\"line\">[1,1,1],</span><br><span class=\"line\">[1,0,1],</span><br><span class=\"line\">[1,1,1]</span><br><span class=\"line\">]</span><br><span class=\"line\">输出：</span><br><span class=\"line\">[</span><br><span class=\"line\">[1,0,1],</span><br><span class=\"line\">[0,0,0],</span><br><span class=\"line\">[1,0,1]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\">[</span><br><span class=\"line\">[0,1,2,0],</span><br><span class=\"line\">[3,4,5,2],</span><br><span class=\"line\">[1,3,1,5]</span><br><span class=\"line\">]</span><br><span class=\"line\">输出：</span><br><span class=\"line\">[</span><br><span class=\"line\">[0,0,0,0],</span><br><span class=\"line\">[0,4,5,0],</span><br><span class=\"line\">[0,3,1,0]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class=\"line\">        vector&lt;int&gt; h(matrix[0].size(),0);</span><br><span class=\"line\">        vector&lt;int&gt; s(matrix.size(),0);</span><br><span class=\"line\">        for(int i=0;i&lt;matrix.size();i++)&#123;</span><br><span class=\"line\">            for(int j=0;j&lt;matrix[0].size();j++)&#123;</span><br><span class=\"line\">                if(matrix[i][j]==0)&#123;</span><br><span class=\"line\">                    h[j]=1;</span><br><span class=\"line\">                    s[i]=1;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        for(int i=0;i&lt;matrix.size();i++)&#123;</span><br><span class=\"line\">            if(s[i]==1)&#123;</span><br><span class=\"line\">                for(int j=0;j&lt;matrix[0].size();j++)&#123;</span><br><span class=\"line\">                    matrix[i][j]=0;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        for(int i=0;i&lt;matrix[0].size();i++)&#123;</span><br><span class=\"line\">            if(h[i]==1)&#123;</span><br><span class=\"line\">                for(int j=0;j&lt;matrix.size();j++)&#123;</span><br><span class=\"line\">                    matrix[j][i]=0;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度 \\(O (mn)\\)</li>\n<li>空间复杂度 \\(O (m+n)\\)</li>\n</ul>\n",
            "tags": [
                "leetcode每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/09/28/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%98-17-09-%E7%AC%AC-k-%E4%B8%AA%E6%95%B0/",
            "url": "https://x-17.top/2022/09/28/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%98-17-09-%E7%AC%AC-k-%E4%B8%AA%E6%95%B0/",
            "title": "面试题 17.09. 第 k 个数",
            "date_published": "2022-09-27T23:37:35.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/get-kth-magic-number-lcci/\">https://leetcode.cn/problems/get-kth-magic-number-lcci/</a> 有些数的素因子只有 3，5，7，请设计一个算法找出第 k 个数。注意，不是必须有这些素因子，而是必须不包含其他的素因子。例如，前几个数按顺序应该是 1，3，5，7，9，15，21。 示例 1:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: k = 5</span><br><span class=\"line\">输出: 9</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int getKthMagicNumber(int k) &#123;</span><br><span class=\"line\">        vector&lt;int&gt; factors = &#123;3, 5, 7&#125;;</span><br><span class=\"line\">        unordered_set&lt;long&gt; seen;</span><br><span class=\"line\">        priority_queue&lt;long, vector&lt;long&gt;, greater&lt;long&gt;&gt; heap;</span><br><span class=\"line\">        seen.insert(1L);</span><br><span class=\"line\">        heap.push(1L);</span><br><span class=\"line\">        int ugly = 0;</span><br><span class=\"line\">        for (int i = 0; i &lt; k; i++) &#123;</span><br><span class=\"line\">            long curr = heap.top();</span><br><span class=\"line\">            heap.pop();</span><br><span class=\"line\">            ugly = (int)curr;</span><br><span class=\"line\">            for (int factor : factors) &#123;</span><br><span class=\"line\">                long next = curr * factor;</span><br><span class=\"line\">                if (!seen.count(next)) &#123;</span><br><span class=\"line\">                    seen.insert(next);</span><br><span class=\"line\">                    heap.push(next);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ugly;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度 \\(O (klogk)\\)</li>\n<li>空间复杂度 \\(O (logk)\\)</li>\n</ul>\n",
            "tags": [
                "leetcode每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/09/25/LeetCode/788-%E6%97%8B%E8%BD%AC%E6%95%B0%E5%AD%97/",
            "url": "https://x-17.top/2022/09/25/LeetCode/788-%E6%97%8B%E8%BD%AC%E6%95%B0%E5%AD%97/",
            "title": "788. 旋转数字",
            "date_published": "2022-09-24T23:47:22.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/rotated-digits/\">https://leetcode.cn/problems/rotated-digits/</a> 我们称一个数 X 为好数，如果它的每位数字逐个地被旋转 180 度后，我们仍可以得到一个有效的，且和 X 不同的数。要求每位数字都要被旋转。 如果一个数的每位数字被旋转以后仍然还是一个数字， 则这个数是有效的。0, 1, 和 8 被旋转后仍然是它们自己；2 和 5 可以互相旋转成对方（在这种情况下，它们以不同的方向旋转，换句话说，2 和 5 互为镜像）；6 和 9 同理，除了这些以外其他的数字旋转以后都不再是有效的数字。 现在我们有一个正整数 N, 计算从 1 到 N 中有多少个数 X 是好数？ 示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: 10</span><br><span class=\"line\">输出: 4</span><br><span class=\"line\">解释: </span><br><span class=\"line\">在[1, 10]中有四个好数： 2, 5, 6, 9。</span><br><span class=\"line\">注意 1 和 10 不是好数, 因为他们在旋转之后不变。</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>N 的取值范围是 [1, 10000]。</li>\n</ul>\n<p></p>\n</blockquote>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    map&lt;int,int&gt; m;</span><br><span class=\"line\"></span><br><span class=\"line\">    bool is(int n)&#123;</span><br><span class=\"line\">        bool flag=false;</span><br><span class=\"line\">        while(n)&#123;</span><br><span class=\"line\">            if(m.count(n%10)&amp;&amp;m[n%10]==1)&#123;</span><br><span class=\"line\">                flag=true;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if(m.count(n%10)==0)&#123;</span><br><span class=\"line\">                flag=false;</span><br><span class=\"line\">                return flag;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            n/=10;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return flag;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    int rotatedDigits(int n) &#123;</span><br><span class=\"line\">        m[0]=0;</span><br><span class=\"line\">        m[1]=0;</span><br><span class=\"line\">        m[2]=1;</span><br><span class=\"line\">        m[5]=1;</span><br><span class=\"line\">        m[6]=1;</span><br><span class=\"line\">        m[8]=0;</span><br><span class=\"line\">        m[9]=1;</span><br><span class=\"line\">        int ans=0;</span><br><span class=\"line\">        for(int i=1;i&lt;=n;i++)&#123;</span><br><span class=\"line\">            if(is(i))&#123;</span><br><span class=\"line\">                ans++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度 \\(O (nlogn)\\)</li>\n<li>空间复杂度 \\(O (1)\\)</li>\n</ul>\n",
            "tags": [
                "leetcode每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/09/23/LeetCode/707-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/",
            "url": "https://x-17.top/2022/09/23/LeetCode/707-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/",
            "title": "707. 设计链表",
            "date_published": "2022-09-23T00:17:08.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/design-linked-list/\">https://leetcode.cn/problems/design-linked-list/</a> 设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针 / 引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。 在链表类中实现这些功能： get (index)：获取链表中第 index 个节点的值。如果索引无效，则返回 - 1。 addAtHead (val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。 addAtTail (val)：将值为 val 的节点追加到链表的最后一个元素。 addAtIndex (index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果 index 小于 0，则在头部插入节点。 deleteAtIndex (index)：如果索引 index 有效，则删除链表中的第 index 个节点。 示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">MyLinkedList linkedList = new MyLinkedList();</span><br><span class=\"line\">linkedList.addAtHead(1);</span><br><span class=\"line\">linkedList.addAtTail(3);</span><br><span class=\"line\">linkedList.addAtIndex(1,2); //链表变为1-&gt; 2-&gt; 3</span><br><span class=\"line\">linkedList.get(1); //返回2</span><br><span class=\"line\">linkedList.deleteAtIndex(1); //现在链表是1-&gt; 3</span><br><span class=\"line\">linkedList.get(1); //返回3</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>所有 val 值都在 [1, 1000] 之内。</li>\n<li>操作次数将在  [1, 1000] 之内。</li>\n<li>请不要使用内置的 LinkedList 库。</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class MyLinkedList &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">    struct ListNode&#123;</span><br><span class=\"line\">        int val;</span><br><span class=\"line\">        ListNode* next;</span><br><span class=\"line\">        ListNode* prev;</span><br><span class=\"line\">        ListNode(int val):val(val), next(nullptr), prev(nullptr) &#123;&#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    int _size;</span><br><span class=\"line\">    ListNode* _dummyHead;</span><br><span class=\"line\">    ListNode* _dummyTail;</span><br><span class=\"line\">    </span><br><span class=\"line\">public:</span><br><span class=\"line\">    MyLinkedList() &#123;</span><br><span class=\"line\">        _dummyHead = new ListNode(0);</span><br><span class=\"line\">        _dummyTail = new ListNode(0);</span><br><span class=\"line\">        _dummyHead-&gt;next = _dummyTail;</span><br><span class=\"line\">        _dummyTail-&gt;prev = _dummyHead;</span><br><span class=\"line\">        _size = 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    int get(int index) &#123;</span><br><span class=\"line\">        if(index &gt; _size - 1  index &lt; 0)&#123; return -1; &#125; ListNode* cur = _dummyHead-&gt;next;</span><br><span class=\"line\">        while(index--)&#123;</span><br><span class=\"line\">            cur = cur-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return cur-&gt;val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    void addAtHead(int val) &#123;</span><br><span class=\"line\">        ListNode* p = new ListNode(val);</span><br><span class=\"line\">        p-&gt;next = _dummyHead-&gt;next;</span><br><span class=\"line\">        _dummyHead-&gt;next-&gt;prev = p;</span><br><span class=\"line\">        _dummyHead-&gt;next = p;</span><br><span class=\"line\">        p-&gt;prev = _dummyHead;</span><br><span class=\"line\">        _size++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    void addAtTail(int val) &#123;</span><br><span class=\"line\">        ListNode* p = new ListNode(val);</span><br><span class=\"line\">        _dummyTail-&gt;prev-&gt;next = p;</span><br><span class=\"line\">        p-&gt;prev = _dummyTail-&gt;prev;</span><br><span class=\"line\">        p-&gt;next = _dummyTail;</span><br><span class=\"line\">        _dummyTail-&gt;prev = p;</span><br><span class=\"line\">        _size++;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    void addAtIndex(int index, int val) &#123;</span><br><span class=\"line\">        if(index &gt; _size  index &lt; 0)&#123; return ; &#125; ListNode* cur = _dummyHead-&gt;next;</span><br><span class=\"line\">        ListNode* p = new ListNode(val);</span><br><span class=\"line\">        while(index--)&#123;</span><br><span class=\"line\">            cur = cur-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cur-&gt;prev-&gt;next = p;</span><br><span class=\"line\">        p-&gt;prev = cur-&gt;prev;</span><br><span class=\"line\">        p-&gt;next = cur;</span><br><span class=\"line\">        cur-&gt;prev = p;</span><br><span class=\"line\">        _size++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    void deleteAtIndex(int index) &#123;</span><br><span class=\"line\">        if(index &gt; _size - 1  index &lt; 0)&#123; return ; &#125; ListNode* cur = _dummyHead-&gt;next;</span><br><span class=\"line\">        while(index--)&#123;</span><br><span class=\"line\">            cur = cur-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cur-&gt;prev-&gt;next = cur-&gt;next;</span><br><span class=\"line\">        cur-&gt;next-&gt;prev = cur-&gt;prev;</span><br><span class=\"line\">        delete(cur);</span><br><span class=\"line\">        _size--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Your MyLinkedList object will be instantiated and called as such:</span><br><span class=\"line\"> * MyLinkedList* obj = new MyLinkedList();</span><br><span class=\"line\"> * int param_1 = obj-&gt;get(index);</span><br><span class=\"line\"> * obj-&gt;addAtHead(val);</span><br><span class=\"line\"> * obj-&gt;addAtTail(val);</span><br><span class=\"line\"> * obj-&gt;addAtIndex(index,val);</span><br><span class=\"line\"> * obj-&gt;deleteAtIndex(index);</span><br><span class=\"line\"> */</span><br></pre></td></tr></table></figure>",
            "tags": [
                "leetcode每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/09/20/LeetCode/698-%E5%88%92%E5%88%86%E4%B8%BAk%E4%B8%AA%E7%9B%B8%E7%AD%89%E7%9A%84%E5%AD%90%E9%9B%86/",
            "url": "https://x-17.top/2022/09/20/LeetCode/698-%E5%88%92%E5%88%86%E4%B8%BAk%E4%B8%AA%E7%9B%B8%E7%AD%89%E7%9A%84%E5%AD%90%E9%9B%86/",
            "title": "698. 划分为k个相等的子集",
            "date_published": "2022-09-20T00:20:31.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/\">https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/</a> 给定一个整数数组  nums 和一个正整数 k，找出是否有可能把这个数组分成 k 个非空子集，其总和都相等。 示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入： nums = [4, 3, 2, 3, 5, 2, 1], k = 4</span><br><span class=\"line\">输出： True</span><br><span class=\"line\">说明： 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和。</span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: nums = [1,2,3,4], k = 3</span><br><span class=\"line\">输出: false</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>1 &lt;= k &lt;= len(nums) &lt;= 16</li>\n<li>0 &lt; nums[i] &lt; 10000</li>\n<li>每个元素的频率在 [1,4] 范围内</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    bool canPartitionKSubsets(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class=\"line\">        int all = accumulate(nums.begin(), nums.end(), 0);</span><br><span class=\"line\">        if (all % k &gt; 0) &#123;</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        int per = all / k; </span><br><span class=\"line\">        sort(nums.begin(), nums.end());</span><br><span class=\"line\">        if (nums.back() &gt; per) &#123;</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        int n = nums.size();</span><br><span class=\"line\">        vector&lt;bool&gt; dp(1 &lt;&lt; n, false);</span><br><span class=\"line\">        vector&lt;int&gt; curSum(1 &lt;&lt; n, 0);</span><br><span class=\"line\">        dp[0] = true;</span><br><span class=\"line\">        for (int i = 0; i &lt; 1 &lt;&lt; n; i++) &#123;</span><br><span class=\"line\">            if (!dp[i]) &#123;</span><br><span class=\"line\">                continue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            for (int j = 0; j &lt; n; j++) &#123; if (curSum[i] + nums[j] &gt; per) &#123;</span><br><span class=\"line\">                    break;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if (((i &gt;&gt; j) &amp; 1) == 0) &#123;</span><br><span class=\"line\">                    int next = i  (1 &lt;&lt; j);</span><br><span class=\"line\">                    if (!dp[next]) &#123;</span><br><span class=\"line\">                        curSum[next] = (curSum[i] + nums[j]) % per;</span><br><span class=\"line\">                        dp[next] = true;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return dp[(1 &lt;&lt; n) - 1];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度 \\(O (n*2^n)\\)</li>\n<li>空间复杂度 \\(O (2^n)\\)</li>\n</ul>\n",
            "tags": [
                "leetcode每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/09/15/LeetCode/672-%E7%81%AF%E6%B3%A1%E5%BC%80%E5%85%B3-%E2%85%B1/",
            "url": "https://x-17.top/2022/09/15/LeetCode/672-%E7%81%AF%E6%B3%A1%E5%BC%80%E5%85%B3-%E2%85%B1/",
            "title": "672. 灯泡开关 Ⅱ",
            "date_published": "2022-09-15T12:55:47.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/bulb-switcher-ii/\">https://leetcode.cn/problems/bulb-switcher-ii/</a> 房间中有 n 只已经打开的灯泡，编号从 1 到 n 。墙上挂着 4 个开关 。 这 4 个开关各自都具有不同的功能，其中： 开关 1 ：反转当前所有灯的状态（即开变为关，关变为开） 开关 2 ：反转编号为偶数的灯的状态（即 2, 4, …） 开关 3 ：反转编号为奇数的灯的状态（即 1, 3, …） 开关 4 ：反转编号为 j = 3k + 1 的灯的状态，其中 k = 0, 1, 2, …（即 1, 4, 7, 10, …） 你必须 恰好 按压开关 presses 次。每次按压，你都需要从 4 个开关中选出一个来执行按压操作。 给你两个整数 n 和 presses ，执行完所有按压之后，返回 不同可能状态 的数量。 示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：n = 1, presses = 1</span><br><span class=\"line\">输出：2</span><br><span class=\"line\">解释：状态可以是：</span><br><span class=\"line\">- 按压开关 1 ，[关]</span><br><span class=\"line\">- 按压开关 2 ，[开]</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：n = 2, presses = 1</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：状态可以是：</span><br><span class=\"line\">- 按压开关 1 ，[关, 关]</span><br><span class=\"line\">- 按压开关 2 ，[开, 关]</span><br><span class=\"line\">- 按压开关 3 ，[关, 开]</span><br></pre></td></tr></table></figure>\n<p>示例 3：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：n = 3, presses = 1</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：状态可以是：</span><br><span class=\"line\">- 按压开关 1 ，[关, 关, 关]</span><br><span class=\"line\">- 按压开关 2 ，[关, 开, 关]</span><br><span class=\"line\">- 按压开关 3 ，[开, 开, 开]</span><br><span class=\"line\">- 按压开关 4 ，[关, 开, 开]</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>1 &lt;= n &lt;= 1000</li>\n<li>0 &lt;= presses &lt;= 1000</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int flipLights(int n, int presses) &#123;</span><br><span class=\"line\">        if(presses==0)</span><br><span class=\"line\">            return 1;</span><br><span class=\"line\">        if(n==1)</span><br><span class=\"line\">            return 2;</span><br><span class=\"line\">        else if(n==2)</span><br><span class=\"line\">            return presses==1?3:4;</span><br><span class=\"line\">        else</span><br><span class=\"line\">            return presses==1?4:presses==2?7:8;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度 \\(O (1)\\)</li>\n<li>空间复杂度 \\(O (1)\\)</li>\n</ul>\n",
            "tags": [
                "leetcode每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/09/13/LeetCode/670-%E6%9C%80%E5%A4%A7%E4%BA%A4%E6%8D%A2/",
            "url": "https://x-17.top/2022/09/13/LeetCode/670-%E6%9C%80%E5%A4%A7%E4%BA%A4%E6%8D%A2/",
            "title": "670. 最大交换",
            "date_published": "2022-09-13T05:28:29.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/maximum-swap/\">https://leetcode.cn/problems/maximum-swap/</a> 给定一个非负整数，你至多可以交换一次数字中的任意两位。返回你能得到的最大值。 示例 1 :</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: 2736</span><br><span class=\"line\">输出: 7236</span><br><span class=\"line\">解释: 交换数字2和数字7。</span><br></pre></td></tr></table></figure>\n<p>示例 2 :</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: 9973</span><br><span class=\"line\">输出: 9973</span><br><span class=\"line\">解释: 不需要交换。</span><br></pre></td></tr></table></figure>\n<p>注意:</p>\n<ul>\n<li>给定数字的范围是 \\([0, 10^8]\\)</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<p>暴力</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int maximumSwap(int num) &#123;</span><br><span class=\"line\">        vector&lt;int&gt; a;</span><br><span class=\"line\">        while(num)&#123;</span><br><span class=\"line\">            a.push_back(num%10);</span><br><span class=\"line\">            num/=10;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        int t=1;</span><br><span class=\"line\">        for(int j=1;j&lt;a.size();j++)&#123; </span><br><span class=\"line\">            if(t)&#123; </span><br><span class=\"line\">                int n=a[a.size()-j]; </span><br><span class=\"line\">                int flag=a.size()-j; </span><br><span class=\"line\">                for(int i=flag-1;i&gt;=0;i--)&#123;</span><br><span class=\"line\">                    if((a[i]&gt;n&amp;&amp;t==1)(a[i]&gt;=n&amp;&amp;t==0))&#123;</span><br><span class=\"line\">                        n=a[i];</span><br><span class=\"line\">                        flag=i;</span><br><span class=\"line\">                        t=0;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                a[flag]=a[a.size()-j];</span><br><span class=\"line\">                a[a.size()-j]=n;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        for(int i=a.size()-1;i&gt;=0;i--)&#123;</span><br><span class=\"line\">            num*=10;</span><br><span class=\"line\">            num+=a[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return num;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度 \\(O (log^2n)\\)</li>\n<li>空间复杂度 \\(O (logn)\\)</li>\n</ul>\n",
            "tags": [
                "leetcode每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/09/10/LeetCode/669-%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/",
            "url": "https://x-17.top/2022/09/10/LeetCode/669-%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/",
            "title": "669. 修剪二叉搜索树",
            "date_published": "2022-09-10T10:58:44.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/trim-a-binary-search-tree/\">https://leetcode.cn/problems/trim-a-binary-search-tree/</a> 给你二叉搜索树的根节点 root ，同时给定最小边界 low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在 [low, high] 中。修剪树 不应该 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 唯一的答案 。 所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。 示例 1： <img src=\"https://assets.leetcode.com/uploads/2020/09/09/trim1.jpg\" alt=\"\"> 输入：root = [1,0,2], low = 1, high = 2 输出：[1,null,2] 示例 2： <img src=\"https://assets.leetcode.com/uploads/2020/09/09/trim2.jpg\" alt=\"\"> 输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3 输出：[3,2,null,1] 提示：</p>\n<ul>\n<li>树中节点数在范围 [1, 104] 内</li>\n<li>0 &lt;= Node.val &lt;= 104</li>\n<li>树中每个节点的值都是 唯一 的</li>\n<li>题目数据保证输入是一棵有效的二叉搜索树</li>\n<li>0 &lt;= low &lt;= high &lt;= 104</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    TreeNode* trimBST(TreeNode* root, int low, int high) &#123;</span><br><span class=\"line\">        if (root == nullptr) &#123;</span><br><span class=\"line\">            return nullptr;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (root-&gt;val &lt; low) &#123; </span><br><span class=\"line\">            return trimBST(root-&gt;right, low, high);</span><br><span class=\"line\">        &#125; else if (root-&gt;val &gt; high) &#123;</span><br><span class=\"line\">            return trimBST(root-&gt;left, low, high);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            root-&gt;left = trimBST(root-&gt;left, low, high);</span><br><span class=\"line\">            root-&gt;right = trimBST(root-&gt;right, low, high);</span><br><span class=\"line\">            return root;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度 \\(O (n)\\)</li>\n<li>空间复杂度 \\(O (n)\\)</li>\n</ul>\n",
            "tags": [
                "leetcode每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/09/08/LeetCode/667-%E4%BC%98%E7%BE%8E%E7%9A%84%E6%8E%92%E5%88%97-ii/",
            "url": "https://x-17.top/2022/09/08/LeetCode/667-%E4%BC%98%E7%BE%8E%E7%9A%84%E6%8E%92%E5%88%97-ii/",
            "title": "667. 优美的排列 II",
            "date_published": "2022-09-08T08:32:21.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/beautiful-arrangement-ii/\">https://leetcode.cn/problems/beautiful-arrangement-ii/</a> 给你两个整数 n 和 k ，请你构造一个答案列表 answer ，该列表应当包含从 1 到 n 的 n 个不同正整数，并同时满足下述条件： 假设该列表是 answer = [a1, a2, a3, … , an] ，那么列表 [a1 - a2, a2 - a3, a3 - a4, … , an-1 - an] 中应该有且仅有 k 个不同整数。 返回列表 answer 。如果存在多种答案，只需返回其中 任意一种 。 示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：n = 3, k = 1</span><br><span class=\"line\">输出：[1, 2, 3]</span><br><span class=\"line\">解释：[1, 2, 3] 包含 3 个范围在 1-3 的不同整数，并且 [1, 1] 中有且仅有 1 个不同整数：1</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：n = 3, k = 2</span><br><span class=\"line\">输出：[1, 3, 2]</span><br><span class=\"line\">解释：[1, 3, 2] 包含 3 个范围在 1-3 的不同整数，并且 [2, 1] 中有且仅有 2 个不同整数：1 和 2</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>\\(1 &lt;= k &lt; n &lt;= 10^4\\)</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<p>思维题</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    vector&lt;int&gt; constructArray(int n, int k) &#123;</span><br><span class=\"line\">        vector&lt;int&gt; answer;</span><br><span class=\"line\">        for (int i = 1; i &lt; n - k; ++i) &#123;</span><br><span class=\"line\">            answer.push_back(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        for (int i = n - k, j = n; i &lt;= j; ++i, --j) &#123;</span><br><span class=\"line\">            answer.push_back(i);</span><br><span class=\"line\">            if (i != j) &#123;</span><br><span class=\"line\">                answer.push_back(j);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return answer;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度 \\(O (n)\\)</li>\n<li>空间复杂度 \\(O (1)\\)</li>\n</ul>\n",
            "tags": [
                "leetcode每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/09/05/LeetCode/652-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E6%A0%91/",
            "url": "https://x-17.top/2022/09/05/LeetCode/652-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E6%A0%91/",
            "title": "652. 寻找重复的子树",
            "date_published": "2022-09-05T00:13:56.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"652-寻找重复的子树\"><a class=\"markdownIt-Anchor\" href=\"#652-寻找重复的子树\">#</a> <a href=\"https://leetcode.cn/problems/find-duplicate-subtrees/\">652. 寻找重复的子树</a></h1>\n<p>给定一棵二叉树 root，返回所有重复的子树。 对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。 如果两棵树具有相同的结构和相同的结点值，则它们是重复的。 示例 1： <img src=\"https://assets.leetcode.com/uploads/2020/08/16/e1.jpg\" alt=\"\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [1,2,3,4,null,2,4,null,null,4]</span><br><span class=\"line\">输出：[[2,4],[4]]</span><br></pre></td></tr></table></figure>\n<p>示例 2： <img src=\"https://assets.leetcode.com/uploads/2020/08/16/e2.jpg\" alt=\"\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [2,1,1]</span><br><span class=\"line\">输出：[[1]]</span><br></pre></td></tr></table></figure>\n<p>示例 3： <img src=\"https://assets.leetcode.com/uploads/2020/08/16/e33.jpg\" alt=\"\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [2,2,2,3,null,3,null]</span><br><span class=\"line\">输出：[[2,3],[3]]</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>树中的结点数在 \\([1,10^4]\\) 范围内。</li>\n<li>-200 &lt;= Node.val &lt;= 200</li>\n</ul>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<p>emmm, 这是中等题？ 参考<a href=\"https://leetcode.cn/problems/find-duplicate-subtrees/solution/xun-zhao-zhong-fu-de-zi-shu-by-leetcode-zoncw/\">官方题解</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector <span class=\"title\">findDuplicateSubtrees</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;repeat.<span class=\"built_in\">begin</span>(), repeat.<span class=\"built_in\">end</span>()&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">dfs</span><span class=\"params\">(TreeNode* node)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!node) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        string serial = <span class=\"built_in\">to_string</span>(node-&gt;val) + <span class=\"string\">&quot;(&quot;</span> + <span class=\"built_in\">dfs</span>(node-&gt;left) + <span class=\"string\">&quot;)(&quot;</span> + <span class=\"built_in\">dfs</span>(node-&gt;right) + <span class=\"string\">&quot;)&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">auto</span> it = seen.<span class=\"built_in\">find</span>(serial); it != seen.<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">            repeat.<span class=\"built_in\">insert</span>(it-&gt;second);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            seen[serial] = node;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> serial;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    unordered_map seen;</span><br><span class=\"line\">    unordered_set repeat;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度 $O (n)$</li>\n<li>空间复杂度 $O (n)$</li>\n</ul>\n",
            "tags": [
                "每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/09/03/LeetCode/646-%E6%9C%80%E9%95%BF%E6%95%B0%E5%AF%B9%E9%93%BE/",
            "url": "https://x-17.top/2022/09/03/LeetCode/646-%E6%9C%80%E9%95%BF%E6%95%B0%E5%AF%B9%E9%93%BE/",
            "title": "646. 最长数对链",
            "date_published": "2022-09-03T07:26:13.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"646-最长数对链\"><a class=\"markdownIt-Anchor\" href=\"#646-最长数对链\">#</a> <a href=\"https://leetcode.cn/problems/maximum-length-of-pair-chain/\">646. 最长数对链</a></h1>\n<p>给出 n 个数对。 在每一个数对中，第一个数字总是比第二个数字小。 现在，我们定义一种跟随关系，当且仅当 b &lt;c 时，数对 (c, d) 才可以跟在 (a, b) 后面。我们用这种形式来构造一个数对链。 给定一个数对集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。 示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：[[1,2], [2,3], [3,4]]</span><br><span class=\"line\">输出：2</span><br><span class=\"line\">解释：最长的数对链是 [1,2] -&gt; [3,4]</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>给出数对的个数在 [1, 1000] 范围内。</li>\n</ul>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<p>动态规划</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">findLongestChain</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; pairs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(pairs.<span class=\"built_in\">begin</span>(),pairs.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"function\">vector <span class=\"title\">dp</span><span class=\"params\">(pairs.size(),<span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;pairs.<span class=\"built_in\">size</span>();i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;i;j++)&#123; </span><br><span class=\"line\">                <span class=\"keyword\">if</span>(pairs[i][<span class=\"number\">0</span>]&gt;pairs[j][<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">                    dp[i]=<span class=\"built_in\">max</span>(dp[i],dp[j]+<span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[pairs.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度 $O (n^2)$</li>\n<li>空间复杂度 $O (n)$</li>\n</ul>\n",
            "tags": [
                "每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/09/02/LeetCode/687-%E6%9C%80%E9%95%BF%E5%90%8C%E5%80%BC%E8%B7%AF%E5%BE%84/",
            "url": "https://x-17.top/2022/09/02/LeetCode/687-%E6%9C%80%E9%95%BF%E5%90%8C%E5%80%BC%E8%B7%AF%E5%BE%84/",
            "title": "687. 最长同值路径",
            "date_published": "2022-09-02T11:08:40.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/longest-univalue-path/\">https://leetcode.cn/problems/longest-univalue-path/</a> 给定一个二叉树的 root ，返回 最长的路径的长度 ，这个路径中的 每个节点具有相同值 。 这条路径可以经过也可以不经过根节点。 两个节点之间的路径长度 由它们之间的边数表示。 示例 1: <img src=\"https://assets.leetcode.com/uploads/2020/10/13/ex1.jpg\" alt=\"\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [5,4,5,1,1,5]</span><br><span class=\"line\">输出：2</span><br></pre></td></tr></table></figure>\n<p>示例 2: <img src=\"https://assets.leetcode.com/uploads/2020/10/13/ex2.jpg\" alt=\"\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [1,4,5,4,4,5]</span><br><span class=\"line\">输出：2</span><br></pre></td></tr></table></figure>\n<p>提示:</p>\n<ul>\n<li>树的节点数的范围是 [0, 104]</li>\n<li>-1000 &lt;= Node.val &lt;= 1000</li>\n<li>树的深度将不超过 1000</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<p>利用深搜递归获得经过某个父节点得到的最长规定路径，从而得到全局最长规定路径</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for a binary tree node.</span><br><span class=\"line\"> * struct TreeNode &#123;</span><br><span class=\"line\"> *     int val;</span><br><span class=\"line\"> *     TreeNode *left;</span><br><span class=\"line\"> *     TreeNode *right;</span><br><span class=\"line\"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class=\"line\"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class=\"line\"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class=\"line\"> * &#125;;</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    int ans;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int longestUnivaluePath(TreeNode* root) &#123;</span><br><span class=\"line\">        ans=0;</span><br><span class=\"line\">        dfs(root);</span><br><span class=\"line\">        return ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    int dfs(TreeNode* root)&#123;</span><br><span class=\"line\">        if(!root)&#123;</span><br><span class=\"line\">            return 0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        int left=dfs(root-&gt;left);</span><br><span class=\"line\">        int right=dfs(root-&gt;right);</span><br><span class=\"line\">        if(root&amp;&amp;root-&gt;left&amp;&amp;root-&gt;val==root-&gt;left-&gt;val)&#123;</span><br><span class=\"line\">            left++;</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            left=0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if(root&amp;&amp;root-&gt;right&amp;&amp;root-&gt;val==root-&gt;right-&gt;val)&#123;</span><br><span class=\"line\">            right++;</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            right=0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans=max(ans,right+left);</span><br><span class=\"line\">        return max(right,left);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度 \\(O (n)\\)</li>\n<li>空间复杂度 \\(O (n)\\)</li>\n</ul>\n",
            "tags": [
                "leetcode每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/08/31/LeetCode/946-%E9%AA%8C%E8%AF%81%E6%A0%88%E5%BA%8F%E5%88%97/",
            "url": "https://x-17.top/2022/08/31/LeetCode/946-%E9%AA%8C%E8%AF%81%E6%A0%88%E5%BA%8F%E5%88%97/",
            "title": "946. 验证栈序列",
            "date_published": "2022-08-31T04:53:01.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/validate-stack-sequences/\">https://leetcode.cn/problems/validate-stack-sequences/</a> 给定 pushed 和 popped 两个序列，每个序列中的 值都不重复，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 true；否则，返回 false 。 示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">解释：我们可以按以下顺序执行：</span><br><span class=\"line\">push(1), push(2), push(3), push(4), pop() -&gt; 4,</span><br><span class=\"line\">push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]</span><br><span class=\"line\">输出：false</span><br><span class=\"line\">解释：1 不能在 2 之前弹出。</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>1 &lt;= pushed.length &lt;= 1000</li>\n<li>0 &lt;= pushed[i] &lt;= 1000</li>\n<li>pushed 的所有元素 互不相同</li>\n<li>popped.length == pushed.length</li>\n<li>popped 是 pushed 的一个排列</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<p>栈模拟</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    bool validateStackSequences(vector&lt;int&gt;&amp; pushed, vector&lt;int&gt;&amp; popped) &#123;</span><br><span class=\"line\">        int flag=0;</span><br><span class=\"line\">        stack s;</span><br><span class=\"line\">        for(int i=0;i&lt;pushed.size();i++)&#123;</span><br><span class=\"line\">            s.push(pushed[i]);</span><br><span class=\"line\">            while(s.top()==popped[flag])&#123;</span><br><span class=\"line\">                s.pop();</span><br><span class=\"line\">                flag++;</span><br><span class=\"line\">                if(flag==popped.size())&#123;</span><br><span class=\"line\">                    return true;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if(s.empty())&#123;</span><br><span class=\"line\">                    break;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度：\\(O (n)\\)</li>\n<li>空间复杂度：\\(O (n)\\)</li>\n</ul>\n",
            "tags": [
                "leetcode每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/08/30/LeetCode/998-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91-ii/",
            "url": "https://x-17.top/2022/08/30/LeetCode/998-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91-ii/",
            "title": "998. 最大二叉树 II",
            "date_published": "2022-08-30T02:42:42.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/maximum-binary-tree-ii/\">https://leetcode.cn/problems/maximum-binary-tree-ii/</a> 最大树 定义：一棵树，并满足：其中每个节点的值都大于其子树中的任何其他值。 给你最大树的根节点 root 和一个整数 val 。 就像 之前的问题 那样，给定的树是利用 Construct (a) 例程从列表 a（root = Construct (a)）递归地构建的： 如果 a 为空，返回 null 。 否则，令 a [i] 作为 a 的最大元素。创建一个值为 a [i] 的根节点 root 。 root 的左子树将被构建为 Construct ([a [0], a [1], …, a [i - 1]]) 。 root 的右子树将被构建为 Construct ([a [i + 1], a [i + 2], …, a [a.length - 1]]) 。 返回 root 。 请注意，题目没有直接给出 a ，只是给出一个根节点 root = Construct (a) 。 假设 b 是 a 的副本，并在末尾附加值 val。题目数据保证 b 中的值互不相同。 返回 Construct (b) 。 示例 1： <img src=\"https://x-17.top/wp-content/uploads/2022/08/maximum-binary-tree-1-1.png\" alt=\"\"><img src=\"https://x-17.top/wp-content/uploads/2022/08/maximum-binary-tree-1-2.png\" alt=\"\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [4,1,3,null,null,2], val = 5</span><br><span class=\"line\">输出：[5,4,null,1,3,null,null,2]</span><br><span class=\"line\">解释：a = [1,4,2,3], b = [1,4,2,3,5]</span><br></pre></td></tr></table></figure>\n<p>示例 2： <img src=\"https://x-17.top/wp-content/uploads/2022/08/maximum-binary-tree-2-1.png\" alt=\"\"><img src=\"https://x-17.top/wp-content/uploads/2022/08/maximum-binary-tree-2-2.png\" alt=\"\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [5,2,4,null,1], val = 3</span><br><span class=\"line\">输出：[5,2,4,null,1,null,3]</span><br><span class=\"line\">解释：a = [2,1,5,4], b = [2,1,5,4,3]</span><br></pre></td></tr></table></figure>\n<p>示例 3： <img src=\"https://x-17.top/wp-content/uploads/2022/08/maximum-binary-tree-3-1.png\" alt=\"\"><img src=\"https://x-17.top/wp-content/uploads/2022/08/maximum-binary-tree-3-2.png\" alt=\"\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [5,2,3,null,1], val = 4</span><br><span class=\"line\">输出：[5,2,4,null,1,3]</span><br><span class=\"line\">解释：a = [2,1,5,3], b = [2,1,5,3,4]</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>\\(树中节点数目在范围 [1, 100] 内 \\)</li>\n<li>\\(1 &lt;= Node.val &lt;= 100\\)</li>\n<li>\\(树中的所有值 互不相同 \\)</li>\n<li>\\(1 &lt;= val &lt;= 100\\)</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<p>因为 val 是附加在末尾的，所以根据题意，如果 val 大于 a 中所有值，那只需要将整个 a 作为以 val 为根节点的左子树即可得到 b；否则就在 a 的右子树中找到小于 val 的节点值，将值为 val 的节点插在此处并将该节点及其子树作为 val 节点的左子树即可。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    TreeNode* insertIntoMaxTree(TreeNode* root, int val) &#123;</span><br><span class=\"line\">        TreeNode* parent = nullptr;</span><br><span class=\"line\">        TreeNode* cur = root;</span><br><span class=\"line\">        while (cur) &#123;</span><br><span class=\"line\">            if (val &gt; cur-&gt;val) &#123;</span><br><span class=\"line\">                if (!parent) &#123;</span><br><span class=\"line\">                    return new TreeNode(val, root, nullptr);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                TreeNode* node = new TreeNode(val, cur, nullptr);</span><br><span class=\"line\">                parent-&gt;right = node;</span><br><span class=\"line\">                return root;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else &#123;</span><br><span class=\"line\">                parent = cur;</span><br><span class=\"line\">                cur = cur-&gt;right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        parent-&gt;right = new TreeNode(val);</span><br><span class=\"line\">        return root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度：\\(O (n)\\)</li>\n<li>空间复杂度：\\(O (1)\\)</li>\n</ul>\n",
            "tags": [
                "leetcode每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/08/27/LeetCode/662-%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6/",
            "url": "https://x-17.top/2022/08/27/LeetCode/662-%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6/",
            "title": "662. 二叉树最大宽度",
            "date_published": "2022-08-27T04:07:20.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/maximum-width-of-binary-tree/\">https://leetcode.cn/problems/maximum-width-of-binary-tree/</a> 给你一棵二叉树的根节点 root ，返回树的 最大宽度 。 树的 最大宽度 是所有层中最大的 宽度 。 每一层的 宽度 被定义为该层最左和最右的非空节点（即，两个端点）之间的长度。将这个二叉树视作与满二叉树结构相同，两端点间会出现一些延伸到这一层的 null 节点，这些 null 节点也计入长度。 题目数据保证答案将会在  32 位 带符号整数范围内。 示例 1： <img src=\"https://assets.leetcode.com/uploads/2021/05/03/width1-tree.jpg\" alt=\"\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [1,3,2,5,3,null,9]</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：最大宽度出现在树的第 3 层，宽度为 4 (5,3,null,9) 。</span><br></pre></td></tr></table></figure>\n<p>示例 2： <img src=\"https://assets.leetcode.com/uploads/2022/03/14/maximum-width-of-binary-tree-v3.jpg\" alt=\"\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [1,3,2,5,null,null,9,6,null,7]</span><br><span class=\"line\">输出：7</span><br><span class=\"line\">解释：最大宽度出现在树的第 4 层，宽度为 7 (6,null,null,null,null,null,7) 。</span><br></pre></td></tr></table></figure>\n<p>示例 3： <img src=\"https://assets.leetcode.com/uploads/2021/05/03/width3-tree.jpg\" alt=\"\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [1,3,2,5]</span><br><span class=\"line\">输出：2</span><br><span class=\"line\">解释：最大宽度出现在树的第 2 层，宽度为 2 (3,2) 。</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<ul>\n<li>\\(树中节点的数目范围是 [1, 3000]\\)</li>\n<li>\\(-100&lt;=Node.val&lt;=100\\)</li>\n</ul>\n</blockquote>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<p>解法一：广度优先遍历（官方题解）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int widthOfBinaryTree(TreeNode* root) &#123;</span><br><span class=\"line\">        unsigned long long res = 1;</span><br><span class=\"line\">        vector&lt;pair&gt; arr;</span><br><span class=\"line\">        arr.emplace_back(root, 1L);</span><br><span class=\"line\">        while (!arr.empty()) &#123;</span><br><span class=\"line\">            vector&lt;pair&gt; tmp;</span><br><span class=\"line\">            for (auto &amp;[node, index] : arr) &#123;</span><br><span class=\"line\">                if (node-&gt;left) &#123;</span><br><span class=\"line\">                    tmp.emplace_back(node-&gt;left, index * 2);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if (node-&gt;right) &#123;</span><br><span class=\"line\">                    tmp.emplace_back(node-&gt;right, index * 2 + 1);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res = max(res, arr.back().second - arr[0].second + 1);</span><br><span class=\"line\">            arr = move(tmp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度：\\(O (n)\\)</li>\n<li>空间复杂度：\\(O (n)\\)</li>\n</ul>\n<p>解法二：深度优先遍历（官方题解）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">using ULL = unsigned long long;</span><br><span class=\"line\"></span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int widthOfBinaryTree(TreeNode* root) &#123;</span><br><span class=\"line\">        unordered_map&lt;int, ULL&gt; levelMin;</span><br><span class=\"line\">        function&lt;ULL(TreeNode*, int, ULL)&gt; dfs = [&amp;](TreeNode* node, int depth, ULL index)-&gt;ULL &#123;</span><br><span class=\"line\">            if (node == nullptr) &#123;</span><br><span class=\"line\">                return 0LL;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (!levelMin.count(depth)) &#123;</span><br><span class=\"line\">                levelMin[depth] = index; // 每一层最先访问到的节点会是最左边的节点，即每一层编号的最小值</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return max(&#123;index - levelMin[depth] + 1LL, dfs(node-&gt;left, depth + 1, index * 2), dfs(node-&gt;right, depth + 1, index * 2 + 1)&#125;);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        return dfs(root, 1, 1LL);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复杂度分析：</p>\n<ul>\n<li>时间复杂度：\\(O (n)\\)</li>\n<li>空间复杂度：\\(O (n)\\)</li>\n</ul>\n",
            "tags": [
                "leetcode每日一题",
                "Medium"
            ]
        },
        {
            "id": "https://x-17.top/2022/08/25/LeetCode/658-%E6%89%BE%E5%88%B0-k-%E4%B8%AA%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E5%85%83%E7%B4%A0/",
            "url": "https://x-17.top/2022/08/25/LeetCode/658-%E6%89%BE%E5%88%B0-k-%E4%B8%AA%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E5%85%83%E7%B4%A0/",
            "title": "658. 找到 K 个最接近的元素",
            "date_published": "2022-08-25T03:36:02.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p><a href=\"https://leetcode.cn/problems/find-k-closest-elements/\">https://leetcode.cn/problems/find-k-closest-elements/</a> 给定一个 排序好 的数组 arr ，两个整数 k 和 x ，从数组中找到最靠近 x（两数之差最小）的 k 个数。返回的结果必须要是按升序排好的。 整数 a 比整数 b 更接近 x 需要满足： a - x &lt; b - x 或者 a - x == b - x 且 a &lt; b 示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：arr = [1,2,3,4,5], k = 4, x = 3</span><br><span class=\"line\">输出：[1,2,3,4]</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：arr = [1,2,3,4,5], k = 4, x = -1</span><br><span class=\"line\">输出：[1,2,3,4]</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1 &lt;= k &lt;= arr.length</span><br><span class=\"line\">1 &lt;= arr.length &lt;= 104</span><br><span class=\"line\">arr 按 升序 排列</span><br><span class=\"line\">-104 &lt;= arr[i], x &lt;= 104</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"题解\"><a class=\"markdownIt-Anchor\" href=\"#题解\">#</a> 题解</h2>\n<p>解法一：按照题意进行排序，返回前 k 个，官方解法写的确实短。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    vector findClosestElements(vector&lt;int&gt;&amp; arr, int k, int x) &#123;</span><br><span class=\"line\">        sort(arr.begin(), arr.end(), [x](int a, int b) -&gt; bool &#123;</span><br><span class=\"line\">            return abs(a - x) &lt; abs(b - x)  abs(a - x) == abs(b - x) &amp;&amp; a &lt; b;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        sort(arr.begin(), arr.begin() + k);</span><br><span class=\"line\">        return vector(arr.begin(), arr.begin() + k);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>解法二：二分加双指针，依旧是简短的官方代码。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    vector findClosestElements(vector&lt;int&gt;&amp; arr, int k, int x) &#123;</span><br><span class=\"line\">        int right = lower_bound(arr.begin(), arr.end(), x) - arr.begin();</span><br><span class=\"line\">        int left = right - 1;</span><br><span class=\"line\">        while (k--) &#123;</span><br><span class=\"line\">            if (left &lt; 0) &#123; right++; &#125; else if (right &gt;= arr.size()) &#123;</span><br><span class=\"line\">                left--;</span><br><span class=\"line\">            &#125; else if (x - arr[left] &lt;= arr[right] - x) &#123;</span><br><span class=\"line\">                left--;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                right++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return vector(arr.begin() + left + 1, arr.begin() + right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>",
            "tags": [
                "leetcode每日一题",
                "Medium"
            ]
        }
    ]
}